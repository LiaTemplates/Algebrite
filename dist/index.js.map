{"mappings":"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","sources":["node_modules/algebrite/dist/algebrite.js","node_modules/big-integer/BigInteger.js","src/index.js"],"sourcesContent":["// Generated by CoffeeScript 2.5.1\n(function() {\n\n  /* arg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the angle of complex z.\n\n  */\n  /*\n   Argument (angle) of complex z\n\n    z    arg(z)\n    -    ------\n\n    a    0\n\n    -a    -pi      See note 3 below\n\n    (-1)^a    a pi\n\n    exp(a + i b)  b\n\n    a b    arg(a) + arg(b)\n\n    a + i b    arctan(b/a)\n\n  Result by quadrant\n\n    z    arg(z)\n    -    ------\n\n    1 + i    1/4 pi\n\n    1 - i    -1/4 pi\n\n    -1 + i    3/4 pi\n\n    -1 - i    -3/4 pi\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. Symbols in z are assumed to be positive and real.\n\n    3. Negative direction adds -pi to angle.\n\n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n\n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      arg(numerator(z)) - arg(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  /*\n   Returns the coefficient of the imaginary part of complex z\n\n    z    imag(z)\n    -    -------\n\n    a + i b    b\n\n    exp(i a)  sin(a)\n  */\n  /* Power function\n\n    Input:    push  Base\n\n        push  Exponent\n\n    Output:    Result on stack\n  */\n  /*\n  Convert complex z to rectangular form\n\n    Input:    push  z\n\n    Output:    Result on stack\n  */\n  /* det =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n\n  Example:\n\n    det(((1,2),(3,4)))\n    > -2\n\n  */\n  /* adj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n\n  */\n  /*\n   Guesses a rational for each float in the passed expression\n  */\n  /* arccos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse cosine of x.\n\n  */\n  /* arccosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n\n  */\n  /* arcsin =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse sine of x.\n\n  */\n  /* arcsinh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n\n  */\n  /* arctan =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse tangent of x.\n\n  */\n  /* arctanh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n\n  */\n  /* besselj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n\n  Recurrence relation:\n\n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n\n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n\n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n\n  For negative n, reorder the recurrence relation as:\n\n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n\n  Substitute n+2 for n to obtain\n\n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n\n  Examples:\n\n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n\n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n\n  */\n  /* bessely =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Bessel function of second kind.\n\n  */\n  /* ceiling =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns the smallest integer not less than x.\n\n  */\n  /* check =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p\n\n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n\n  */\n  /* choose =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  n,k\n\n  General description\n  -------------------\n\n  Returns the number of combinations of n items taken k at a time.\n\n  For example, the number of five card hands is choose(52,5)\n\n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n  */\n  /* circexp =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n\n  */\n  /* clear =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n\n  */\n  /* clearall =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n\n  Completely wipes all variables from the environment.\n\n  */\n  /* cofactor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,i,j\n\n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n\n  */\n  /* conj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the complex conjugate of z.\n\n  */\n  /* contract =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,i,j\n\n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n\n  */\n  /* cosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n\n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n\n  */\n  /* deg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x\n\n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n\n  */\n  /* denominator =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the denominator of expression x.\n\n  */\n  /* dim =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,n\n\n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n\n  */\n  /* do =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n\n  */\n  /* eigenval =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n\n  */\n  /* eigenvec =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n\n  */\n  /* erf =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Authors\n  -------\n  philippe.billet@noos.fr\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n\n  */\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n\n    filter(x^2 + x + 1, x)    =>  1\n\n    filter(x^2 + x + 1, x^2)  =>  x + 1\n  */\n  /* dot =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n\n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n\n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n\n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n\n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n\n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n\n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n\n  scalar product of vectors:\n\n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n\n  products of matrices and vectors:\n\n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n\n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n\n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n\n  matrix product:\n\n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n\n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n\n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n\n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n\n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n\n  */\n  /*\n   Laguerre function\n\n  Example\n\n    laguerre(x,3)\n\n  Result\n\n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n\n  The computation uses the following recurrence relation.\n\n    L(x,0,k) = 1\n\n    L(x,1,k) = -x + k + 1\n\n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n\n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n\n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n  */\n  /*\n   Return the leading coefficient of a polynomial.\n\n  Example\n\n    leading(5x^2+x+1,x)\n\n  Result\n\n    5\n\n  The result is undefined if P is not a polynomial.\n  */\n  /*\n   Legendre function\n\n  Example\n\n    legendre(x,3,0)\n\n  Result\n\n     5   3    3\n    --- x  - --- x\n     2        2\n\n  The computation uses the following recurrence relation.\n\n    P(x,0) = 1\n\n    P(x,1) = x\n\n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n\n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n\n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n\n  For m > 0\n\n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n  */\n  /*\n  Convert complex z to polar form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    polar(z) = abs(z) * exp(i * arg(z))\n  */\n  /*\n   Returns the real part of complex z\n\n    z    real(z)\n    -    -------\n\n    a + i b    a\n\n    exp(i a)  cos(a)\n  */\n  /*\n  Taylor expansion of a function\n\n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n  */\n  /*\n  // up to 100 blocks of 100,000 atoms\n\n  #define M 100\n  #define N 100000\n\n  U *mem[M]\n  int mcount\n\n  U *free_list\n  int free_count\n\n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n\n    Returns the number of terms remaining in s[].\n\n    n  number of terms in s[] initially\n  */\n  /* cross =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u,v\n\n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n\n  */\n  /* curl =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u\n\n  General description\n  -------------------\n  Returns the curl of vector u.\n\n  */\n  /*\n    Clear all patterns\n  */\n  /*\n  if 0\n\n   * left brace\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = x - 2\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n   * right brace\n\n    emit_x++\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = emit_x\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n    emit_x++\n\n  endif\n   */\n  /*\n   For example...\n\n    push(F)\n    push(X)\n    filter()\n    F = pop()\n  */\n  /*\n   Symbolic addition\n\n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n\n    For example, A + 2A becomes 3A.\n\n    However, the sum A + sqrt(2) A is not modified.\n\n    Combining terms can lead to second-order effects.\n\n    For example, consider the case of\n\n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n\n    The first two terms are combined to yield 2 sqrt(2) A.\n\n    This result can now be combined with the third term to yield\n\n      3 sqrt(2) A\n  */\n  /*\n   Table of integrals\n\n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n\n    A  is the template expression\n\n    B  is the result expression\n\n    C  is an optional list of conditional expressions\n  */\n  /*\n   Partition a term\n\n    Input stack:\n\n      term (factor or product of factors)\n\n      free variable\n\n    Output stack:\n\n      constant expression\n\n      variable expression\n  */\n  /*\n    Substitute new expr for old expr in expr.\n\n    Input:  push  expr\n\n      push  old expr\n\n      push  new expr\n\n    Output:  Result on stack\n  */\n  var $, ABS, ADD, ADJ, AND, APPROXRATIO, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ASSUME_REAL_VARIABLES, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARALL, CLEARPATTERNS, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DEBUG_ABS, DEBUG_ARG, DEBUG_CLOCKFORM, DEBUG_IMAG, DEBUG_IS, DEBUG_MULTIPLY, DEBUG_POWER, DEBUG_RATIONALIZE, DEBUG_RECT, DEBUG_SIMPLIFY, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_approxratio, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearall, Eval_clearpatterns, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_patternsinfo, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_print2dascii, Eval_printcomputer, Eval_printhuman, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_round, Eval_setq, Eval_sgn, Eval_shape, Eval_silentpattern, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_symbolsinfo, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FORCE_FIXED_PRINTOUT, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_2DASCII_PRINT, LAST_FULL_PRINT, LAST_LATEX_PRINT, LAST_LIST_PRINT, LAST_PLAIN_PRINT, LAST_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAXDIM, MAXPRIMETAB, MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES, MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE, MAX_FIXED_PRINTOUT_DIGITS, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PATTERNSINFO, PI, POLAR, POWER, PRIME, PRINT, PRINT2DASCII, PRINTFULL, PRINTLATEX, PRINTLIST, PRINTMODE_2DASCII, PRINTMODE_COMPUTER, PRINTMODE_HUMAN, PRINTMODE_LATEX, PRINTMODE_LIST, PRINTOUTRESULT, PRINTPLAIN, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, ROUND, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SILENTPATTERN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOLSINFO, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TIMING_DEBUGS, TOS, TRACE, TRANSPOSE, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEQ, T_NEWLINE, T_QUOTASSIGN, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, VERSION, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _print, abs, absValFloat, absval, absval_tensor, add, addSymbolLeftOfAssignment, addSymbolRightOfAssignment, add_all, add_factor_to_accumulator, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, approxAll, approxLogs, approxLogsOfRationals, approxOneRatioOnly, approxRadicals, approxRadicalsOfRationals, approxRationalsOfLogs, approxRationalsOfPowersOfE, approxRationalsOfPowersOfPI, approxRationalsOfRadicals, approxSineOfRationalMultiplesOfPI, approxSineOfRationals, approxTrigonometric, approx_just_an_integer, approx_logarithmsOfRationals, approx_nothingUseful, approx_radicalOfRatio, approx_ratioOfRadical, approx_rationalOfE, approx_rationalOfPi, approx_rationalsOfLogarithms, approx_sine_of_pi_times_rational, approx_sine_of_rational, approxratioRecursive, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, areunivarpolysfactoredorexpandedform, arg, arglist, assignmentFound, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, called_from_Algebra_block, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, chainOfUserSymbolsNotFunctionsBeingEvaluated, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, check_tensor_dimensions, choose, choose_check_args, circexp, clearAlgebraEnvironment, clearRenamedVariablesToAvoidBindingToExternalScope, clear_symbols, clear_term, clearall, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexStringFromReturnValue, collectUserSymbols, combine_factors, combine_gammas, combine_terms, compareState, compare_numbers, compare_rationals, compare_tensors, compatible, computeDependenciesFromAlgebra, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, countsize, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, defineSomeHandyConstants, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_clearPatterns, do_clearall, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, evaluatingPolar, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findPossibleClockForm, findPossibleExponentialForm, findroot, fixup_fraction, fixup_power, flag, floatToRatioRoutine, fmt_index, fmt_level, fmt_x, frame, freeze, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_main, gcd_numbers, gcd_polys, gcd_powers_with_same_base, gcd_product_product, gcd_product_sum, gcd_sum, gcd_sum_product, gcd_sum_sum, gen, getSimpleRoots, getStateHash, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_innerprod_factors, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hasNegativeRationalExponent, hash_addition, hash_function, hash_multiplication, hash_power, hashcode_values, hashed_itab, hermite, hilbert, i1, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isNumberOneOverSomething, isNumericAtom, isNumericAtomOrTensor, isSimpleRoot, isSmall, isSymbolLeftOfAssignment, isSymbolReclaimable, isZeroAtom, isZeroAtomOrTensor, isZeroLikeOrNonZeroLikeOrUndetermined, isZeroTensor, is_denominator, is_factor, is_small_integer, is_square_matrix, is_usr_symbol, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isintegerorintegerfloat, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, isminussqrtthreeovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispolyexpandedform, ispolyexpandedform_expr, ispolyexpandedform_factor, ispolyexpandedform_term, ispolyfactoredorexpandedform, ispolyfactoredorexpandedform_factor, ispolyfactoredorexpandedform_power, isposint, ispositivenumber, ispower, isquarterturn, isrational, isspace, issqrtthree, issqrtthreeovertwo, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, isunivarpolyfactoredorexpandedform, itab, italu_hashcode, j1, laguerre, laguerre2, lastFoundSymbol, latexErrorSign, lcm, leading, legendre, length, lessp, level, list, listLength, logarithm, logbuf, lookupsTotal, lu_decomp, madd, makePositive, makeSignSameAs, make_hashed_itab, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, moveTos, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_integer, new_string, newline_flag, nil_symbols, normaliseDots, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, nthCadr, numerator, numericRootOfPolynomial, o, one, oneElement, one_as_double, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, patternHasBeenFound, patternsinfo, performing_roots, polar, polarRectAMinusOneBase, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print2dascii, printMode, print_ABS_latex, print_ARCCOS_codegen, print_ARCSIN_codegen, print_ARCTAN_codegen, print_BINOMIAL_latex, print_COS_codegen, print_DEFINT_latex, print_DOT_codegen, print_DOT_latex, print_DO_codegen, print_FOR_codegen, print_INV_codegen, print_INV_latex, print_PRODUCT_codegen, print_PRODUCT_latex, print_SETQ_codegen, print_SIN_codegen, print_SQRT_latex, print_SUM_codegen, print_SUM_latex, print_TAN_codegen, print_TESTEQ_latex, print_TESTGE_latex, print_TESTGT_latex, print_TESTLE_latex, print_TESTLT_latex, print_TEST_codegen, print_TEST_latex, print_TRANSPOSE_codegen, print_TRANSPOSE_latex, print_UNIT_codegen, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_glyphs, print_index_function, print_list, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_tensor_inner_latex, print_tensor_latex, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, pushTryNotToDuplicate, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, rememberPrint, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, saveMetaBindings, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call_with_function_name, scan_function_call_without_function_name, scan_index, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_tensor, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simpleComplexityMeasure, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_rational_expressions, simplify_rectToClock, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringsEmittedByUserPrintouts, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsHavingReassignments, symbolsInExpressionsWithoutAssignments, symbolsLeftOfAssignment, symbolsRightOfAssignment, symbolsinfo, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, testApprox, test_flag, text_metric, theRandom, token, token_buf, token_str, top, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, turnErrorMessageToLatex, ucmp, unfreeze, unique, unique_f, update_token_buf, userSimplificationsInListForm, userSimplificationsInStringForm, usr_symbol, verbosing, version, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, yround, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymultiply, yyouter, yypower, yyrationalize, yyround, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat,\n    hasProp = {}.hasOwnProperty;\n\n  bigInt = require('big-integer');\n\n  // also change the version in the package.json file\n  version = \"1.4.0\";\n\n  SELFTEST = 1;\n\n  // size of the symbol table\n  NSYM = 1000;\n\n  DEBUG = false;\n\n  PRINTOUTRESULT = false;\n\n  // printing-related constants\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n\n  // when the user uses the generic \"print\" statement\n  // this setting kicks-in.\n  printMode = PRINTMODE_COMPUTER;\n\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n\n  recursionLevelNestedRadicalsRemoval = 0;\n\n  do_simplify_nested_radicals = true;\n\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = (function() {\n    // Symbolic expressions are built by connecting U structs.\n\n    // For example, (a b + c) is built like this:\n\n    //           _______      _______                                _______\n    //          |CONS   |--->|CONS   |----------------------------->|CONS   |\n    //          |       |    |       |                              |       |\n    //          |_______|    |_______|                              |_______|\n    //              |            |                                      |\n    //           ___v___      ___v___      _______      _______      ___v___\n    //          |ADD    |    |CONS   |--->|CONS   |--->|CONS   |    |SYM c  |\n    //          |       |    |       |    |       |    |       |    |       |\n    //          |_______|    |_______|    |_______|    |_______|    |_______|\n    //                           |            |            |\n    //                        ___v___      ___v___      ___v___\n    //                       |MUL    |    |SYM a  |    |SYM b  |\n    //                       |       |    |       |    |       |\n    //                       |_______|    |_______|    |_______|\n    class rational {};\n\n    rational.prototype.a = null; // a bigInteger\n\n    rational.prototype.b = null; // a bigInteger\n\n    return rational;\n\n  }).call(this);\n\n  U = (function() {\n    class U {\n      toString() {\n        return print_expr(this);\n      }\n\n      toLatexString() {\n        return collectLatexStringFromReturnValue(this);\n      }\n\n      constructor() {\n        this.cons = {};\n        this.cons.car = null;\n        this.cons.cdr = null;\n        this.q = new rational();\n      }\n\n    };\n\n    U.prototype.cons = null; // will have a car and cdr\n\n    U.prototype.printname = \"\";\n\n    U.prototype.str = \"\";\n\n    U.prototype.tensor = null;\n\n    // rational number a over b\n    U.prototype.q = null; // will point to a rational\n\n    U.prototype.d = 0.0; // a double\n\n    U.prototype.k = 0;\n\n    U.prototype.tag = 0;\n\n    return U;\n\n  }).call(this);\n\n  errorMessage = \"\";\n\n  // the following enum is for struct U, member k\n  CONS = 0;\n\n  NUM = 1;\n\n  DOUBLE = 2;\n\n  STR = 3;\n\n  TENSOR = 4;\n\n  SYM = 5;\n\n  // the following enum is for indexing the symbol table\n\n  // standard functions first, then nil, then everything else\n  counter = 0;\n\n  ABS = counter++;\n\n  ADD = counter++;\n\n  ADJ = counter++;\n\n  AND = counter++;\n\n  APPROXRATIO = counter++;\n\n  ARCCOS = counter++;\n\n  ARCCOSH = counter++;\n\n  ARCSIN = counter++;\n\n  ARCSINH = counter++;\n\n  ARCTAN = counter++;\n\n  ARCTANH = counter++;\n\n  ARG = counter++;\n\n  ATOMIZE = counter++;\n\n  BESSELJ = counter++;\n\n  BESSELY = counter++;\n\n  BINDING = counter++;\n\n  BINOMIAL = counter++;\n\n  CEILING = counter++;\n\n  CHECK = counter++;\n\n  CHOOSE = counter++;\n\n  CIRCEXP = counter++;\n\n  CLEAR = counter++;\n\n  CLEARALL = counter++;\n\n  CLEARPATTERNS = counter++;\n\n  CLOCK = counter++;\n\n  COEFF = counter++;\n\n  COFACTOR = counter++;\n\n  CONDENSE = counter++;\n\n  CONJ = counter++;\n\n  CONTRACT = counter++;\n\n  COS = counter++;\n\n  COSH = counter++;\n\n  DECOMP = counter++;\n\n  DEFINT = counter++;\n\n  DEGREE = counter++;\n\n  DENOMINATOR = counter++;\n\n  DERIVATIVE = counter++;\n\n  DET = counter++;\n\n  DIM = counter++;\n\n  DIRAC = counter++;\n\n  DIVISORS = counter++;\n\n  DO = counter++;\n\n  DOT = counter++;\n\n  DRAW = counter++;\n\n  DSOLVE = counter++;\n\n  EIGEN = counter++;\n\n  EIGENVAL = counter++;\n\n  EIGENVEC = counter++;\n\n  ERF = counter++;\n\n  ERFC = counter++;\n\n  EVAL = counter++;\n\n  EXP = counter++;\n\n  EXPAND = counter++;\n\n  EXPCOS = counter++;\n\n  EXPSIN = counter++;\n\n  FACTOR = counter++;\n\n  FACTORIAL = counter++;\n\n  FACTORPOLY = counter++;\n\n  FILTER = counter++;\n\n  FLOATF = counter++;\n\n  FLOOR = counter++;\n\n  FOR = counter++;\n\n  FUNCTION = counter++;\n\n  GAMMA = counter++;\n\n  GCD = counter++;\n\n  HERMITE = counter++;\n\n  HILBERT = counter++;\n\n  IMAG = counter++;\n\n  INDEX = counter++;\n\n  INNER = counter++;\n\n  INTEGRAL = counter++;\n\n  INV = counter++;\n\n  INVG = counter++;\n\n  ISINTEGER = counter++;\n\n  ISPRIME = counter++;\n\n  LAGUERRE = counter++;\n\n  //  LAPLACE = counter++\n  LCM = counter++;\n\n  LEADING = counter++;\n\n  LEGENDRE = counter++;\n\n  LOG = counter++;\n\n  LOOKUP = counter++;\n\n  MOD = counter++;\n\n  MULTIPLY = counter++;\n\n  NOT = counter++;\n\n  NROOTS = counter++;\n\n  NUMBER = counter++;\n\n  NUMERATOR = counter++;\n\n  OPERATOR = counter++;\n\n  OR = counter++;\n\n  OUTER = counter++;\n\n  PATTERN = counter++;\n\n  PATTERNSINFO = counter++;\n\n  POLAR = counter++;\n\n  POWER = counter++;\n\n  PRIME = counter++;\n\n  PRINT_LEAVE_E_ALONE = counter++;\n\n  PRINT_LEAVE_X_ALONE = counter++;\n\n  PRINT = counter++;\n\n  PRINT2DASCII = counter++;\n\n  PRINTFULL = counter++;\n\n  PRINTLATEX = counter++;\n\n  PRINTLIST = counter++;\n\n  PRINTPLAIN = counter++;\n\n  PRODUCT = counter++;\n\n  QUOTE = counter++;\n\n  QUOTIENT = counter++;\n\n  RANK = counter++;\n\n  RATIONALIZE = counter++;\n\n  REAL = counter++;\n\n  ROUND = counter++;\n\n  YYRECT = counter++;\n\n  ROOTS = counter++;\n\n  SETQ = counter++;\n\n  SGN = counter++;\n\n  SILENTPATTERN = counter++;\n\n  SIMPLIFY = counter++;\n\n  SIN = counter++;\n\n  SINH = counter++;\n\n  SHAPE = counter++;\n\n  SQRT = counter++;\n\n  STOP = counter++;\n\n  SUBST = counter++;\n\n  SUM = counter++;\n\n  SYMBOLSINFO = counter++;\n\n  TAN = counter++;\n\n  TANH = counter++;\n\n  TAYLOR = counter++;\n\n  TEST = counter++;\n\n  TESTEQ = counter++;\n\n  TESTGE = counter++;\n\n  TESTGT = counter++;\n\n  TESTLE = counter++;\n\n  TESTLT = counter++;\n\n  TRANSPOSE = counter++;\n\n  UNIT = counter++;\n\n  ZERO = counter++;\n\n  // ALL THE SYMBOLS ABOVE NIL ARE KEYWORDS,\n  // WHICH MEANS THAT USER CANNOT REDEFINE THEM\n  NIL = counter++; // nil goes here, after standard functions\n\n  LAST = counter++;\n\n  LAST_PRINT = counter++;\n\n  LAST_2DASCII_PRINT = counter++;\n\n  LAST_FULL_PRINT = counter++;\n\n  LAST_LATEX_PRINT = counter++;\n\n  LAST_LIST_PRINT = counter++;\n\n  LAST_PLAIN_PRINT = counter++;\n\n  AUTOEXPAND = counter++;\n\n  BAKE = counter++;\n\n  ASSUME_REAL_VARIABLES = counter++;\n\n  TRACE = counter++;\n\n  FORCE_FIXED_PRINTOUT = counter++;\n\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n\n  YYE = counter++;\n\n  DRAWX = counter++; // special purpose internal symbols\n\n  METAA = counter++;\n\n  METAB = counter++;\n\n  METAX = counter++;\n\n  SECRETX = counter++;\n\n  VERSION = counter++;\n\n  PI = counter++;\n\n  SYMBOL_A = counter++;\n\n  SYMBOL_B = counter++;\n\n  SYMBOL_C = counter++;\n\n  SYMBOL_D = counter++;\n\n  SYMBOL_I = counter++;\n\n  SYMBOL_J = counter++;\n\n  SYMBOL_N = counter++;\n\n  SYMBOL_R = counter++;\n\n  SYMBOL_S = counter++;\n\n  SYMBOL_T = counter++;\n\n  SYMBOL_X = counter++;\n\n  SYMBOL_Y = counter++;\n\n  SYMBOL_Z = counter++;\n\n  SYMBOL_IDENTITY_MATRIX = counter++;\n\n  SYMBOL_A_UNDERSCORE = counter++;\n\n  SYMBOL_B_UNDERSCORE = counter++;\n\n  SYMBOL_X_UNDERSCORE = counter++;\n\n  C1 = counter++;\n\n  C2 = counter++;\n\n  C3 = counter++;\n\n  C4 = counter++;\n\n  C5 = counter++;\n\n  C6 = counter++;\n\n  USR_SYMBOLS = counter++; // this must be last\n\n  E = YYE;\n\n  // TOS cannot be arbitrarily large because the OS seg faults on deep recursion.\n  // For example, a circular evaluation like x=x+1 can cause a seg fault.\n  // At this setting (100,000) the evaluation stack overruns before seg fault.\n  TOS = 100000;\n\n  BUF = 10000;\n\n  MAX_PROGRAM_SIZE = 100001;\n\n  MAXPRIMETAB = 10000;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n\n  //define _USE_MATH_DEFINES // for MS C++\n  MAXDIM = 24;\n\n  // needed for the mechanism to\n  // find all dependencies between variables\n  // in a script\n  symbolsDependencies = {};\n\n  symbolsHavingReassignments = [];\n\n  symbolsInExpressionsWithoutAssignments = [];\n\n  patternHasBeenFound = false;\n\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n\n  // you can do some little simplifications\n  // at parse time, such as calculating away\n  // immediately simple operations on\n  // constants, removing 1s from products\n  // etc.\n  parse_time_simplifications = true;\n\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n  stringsEmittedByUserPrintouts = \"\";\n\n  // flag use to potentially switch on/off some quirks \"deep\"\n  // in the code due to call from Algebra block.\n  // Currently not used.\n  called_from_Algebra_block = false;\n\n  tensor = (function() {\n    class tensor {\n      constructor() {\n        this.dim = (function() {\n          var o, ref, results;\n          results = [];\n          for (o = 0, ref = MAXDIM; (0 <= ref ? o <= ref : o >= ref); 0 <= ref ? o++ : o--) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.elem = [];\n      }\n\n    };\n\n    tensor.prototype.ndim = 0; // number of dimensions\n\n    tensor.prototype.dim = null; // dimension length, for each dimension\n\n    tensor.prototype.nelem = 0; // total number of elements\n\n    tensor.prototype.elem = null; // an array containing all the data\n\n    return tensor;\n\n  }).call(this);\n\n  display = (function() {\n    class display {};\n\n    display.prototype.h = 0;\n\n    display.prototype.w = 0;\n\n    display.prototype.n = 0;\n\n    display.prototype.a = []; // will contain an array of c,x,y (color,x,y)\n\n    return display;\n\n  }).call(this);\n\n  text_metric = (function() {\n    class text_metric {};\n\n    text_metric.prototype.ascent = 0;\n\n    text_metric.prototype.descent = 0;\n\n    text_metric.prototype.width = 0;\n\n    return text_metric;\n\n  }).call(this);\n\n  tos = 0; // top of stack\n\n  expanding = 0;\n\n  evaluatingAsFloats = 0;\n\n  evaluatingPolar = 0;\n\n  fmt_x = 0;\n\n  fmt_index = 0;\n\n  fmt_level = 0;\n\n  verbosing = 0;\n\n  primetab = (function() {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n        j++;\n      }\n      if (j !== -1) {\n        primes.push(i);\n      }\n      i += 2;\n    }\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  })();\n\n  esc_flag = 0;\n\n  draw_flag = 0;\n\n  mtotal = 0;\n\n  trigmode = 0;\n\n  logbuf = \"\";\n\n  program_buf = \"\";\n\n  // will contain the variable names\n  symtab = [];\n\n  // will contain the contents of the variable\n  // in the corresponding position in symtab array\n  binding = [];\n\n  isSymbolReclaimable = [];\n\n  arglist = []; // will contain U\n\n  stack = []; // will contain *U\n\n  frame = 0;\n\n  p0 = null; // will contain U\n\n  p1 = null; // will contain U\n\n  p2 = null; // will contain U\n\n  p3 = null; // will contain U\n\n  p4 = null; // will contain U\n\n  p5 = null; // will contain U\n\n  p6 = null; // will contain U\n\n  p7 = null; // will contain U\n\n  p8 = null; // will contain U\n\n  p9 = null; // will contain U\n\n  zero = null; // will contain U\n\n  one = null; // will contain U\n\n  one_as_double = null;\n\n  imaginaryunit = null; // will contain U\n\n  out_buf = \"\";\n\n  out_count = 0;\n\n  test_flag = 0;\n\n  codeGen = false;\n\n  draw_stop_return = null; // extern jmp_buf ?????\n\n  userSimplificationsInListForm = [];\n\n  userSimplificationsInStringForm = [];\n\n  transpose_unicode = 7488;\n\n  dotprod_unicode = 183;\n\n  symbol = function(x) {\n    return symtab[x];\n  };\n\n  iscons = function(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function(p) {\n    return p.k === STR;\n  };\n\n  istensor = function(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  // because of recursion, we consider a scalar to be\n  // a tensor, so a numeric scalar will return true\n  isNumericAtomOrTensor = function(p) {\n    var a, i, n, o, ref;\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n    if (!istensor(p) && !isNumericAtom(p)) {\n      //console.log \"p not an atom nor a tensor: \" + p\n      return 0;\n    }\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtomOrTensor(a[i])) {\n        //console.log \"non-numeric element: \" + a[i]\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  issymbol = function(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function(p) {\n    return car(car(p));\n  };\n\n  cadr = function(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  // not used yet\n  listLength = function(p) {\n    var startCount;\n    startCount = -1;\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n    return startCount;\n  };\n\n  // not used yet\n  nthCadr = function(p, n) {\n    var startCount;\n    startCount = 0;\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n    return car(p);\n  };\n\n  isadd = function(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function(p) {\n    return (car(p) === symbol(INNER)) || (car(p) === symbol(DOT));\n  };\n\n  istranspose = function(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function(p) {\n    return car(p) === symbol(INV);\n  };\n\n  // TODO this is a bit of a shallow check, we should\n  // check when we are passed an actual tensor and possibly\n  // cache the test result.\n  isidentitymatrix = function(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function(p, n) {\n    if (p == null) {\n      debugger;\n    }\n    return p.equals(n);\n  };\n\n  reset_after_error = function() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n\n  $.version = version;\n\n  $.isadd = isadd;\n\n  $.ismultiply = ismultiply;\n\n  $.ispower = ispower;\n\n  $.isfactorial = isfactorial;\n\n  $.car = car;\n\n  $.cdr = cdr;\n\n  $.caar = caar;\n\n  $.cadr = cadr;\n\n  $.cdar = cdar;\n\n  $.cddr = cddr;\n\n  $.caadr = caadr;\n\n  $.caddr = caddr;\n\n  $.cadar = cadar;\n\n  $.cdadr = cdadr;\n\n  $.cddar = cddar;\n\n  $.cdddr = cdddr;\n\n  $.caaddr = caaddr;\n\n  $.cadadr = cadadr;\n\n  $.caddar = caddar;\n\n  $.cdaddr = cdaddr;\n\n  $.cadddr = cadddr;\n\n  $.cddddr = cddddr;\n\n  $.caddddr = caddddr;\n\n  $.cadaddr = cadaddr;\n\n  $.cddaddr = cddaddr;\n\n  $.caddadr = caddadr;\n\n  $.cdddaddr = cdddaddr;\n\n  $.caddaddr = caddaddr;\n\n  $.symbol = symbol;\n\n  $.iscons = iscons;\n\n  $.isrational = isrational;\n\n  $.isdouble = isdouble;\n\n  $.isNumericAtom = isNumericAtom;\n\n  $.isstr = isstr;\n\n  $.istensor = istensor;\n\n  $.issymbol = issymbol;\n\n  $.iskeyword = iskeyword;\n\n  $.CONS = CONS;\n\n  $.NUM = NUM;\n\n  $.DOUBLE = DOUBLE;\n\n  $.STR = STR;\n\n  $.TENSOR = TENSOR;\n\n  $.SYM = SYM;\n\n  \n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* abs =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n\n  */\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n\n    z    abs(z)\n    -    ------\n\n    a    a\n\n    -a    a\n\n    (-1)^a    1\n\n    exp(a + i b)  exp(a)\n\n    a b    abs(a) abs(b)\n\n    a + i b    sqrt(a^2 + b^2)\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      abs(numerator(z)) / abs(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  DEBUG_ABS = false;\n\n  Eval_abs = function() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function() {\n    Eval();\n    absval();\n    Eval();\n    return zzfloat();\n  };\n\n  // zzfloat of an abs doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, these two lines come handy to highlight\n  // when that doesn't happen for those tests.\n  //if !isdouble(stack[tos-1])\n  //  stop(\"absValFloat should return a double and instead got: \" + stack[tos-1])\n  abs = function() {\n    var theArgument;\n    theArgument = top();\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n    numerator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n    push(theArgument);\n    denominator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n    divide();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  absval = function() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n    // handle all the \"number\" cases first -----------------------------------------\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n      push(zero);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // ??? should there be a shortcut case here for the imaginary unit?\n\n    // now handle decomposition cases ----------------------------------------------\n\n    // we catch the \"add\", \"power\", \"multiply\" cases first,\n    // before falling back to the\n    // negative/positive cases because there are some\n    // simplification thay we might be able to do.\n    // Note that for this routine to give a correct result, this\n    // must be a sum where a complex number appears.\n    // If we apply this to \"a+b\", we get an incorrect result.\n    if (car(p1) === symbol(ADD) && (findPossibleClockForm(p1) || findPossibleExponentialForm(p1) || Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n      // sum\n      push(p1);\n      rect(); // convert polar terms, if any\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n      // -1 to any power\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n        push_integer(1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(a^b) is equal to abs(a)^b IF b is positive\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(e^something)\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n      // exponential\n      push(caddr(p1));\n      real();\n      exponential();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n      // product\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        absval();\n        if (anyFactorsYet) {\n          multiply();\n        }\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n      // abs of a abs\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n\n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n\n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n\n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // also called the \"norm\" of a vector\n  absval_tensor = function() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    inner();\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n\n  flag = 0;\n\n  Eval_add = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n    return add_terms(tos - h);\n  };\n\n  // Add n terms, returns one expression on the stack.\n  stackAddsCount = 0;\n\n  add_terms = function(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n    // ensure no infinite loop, use \"for\"\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 137\n    //  debugger\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        console.log(print_list(stack[i]));\n      }\n    }\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n      flag = 0;\n      //qsort(s, n, sizeof (U *), cmp_terms)\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n      if (flag === 0) {\n        break;\n      }\n      n = combine_terms(h, n);\n    }\n    moveTos(h + n);\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        break;\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 5\n    //  debugger\n    if (DEBUG) {\n      results = [];\n      for (i = j1 = 0, ref1 = tos; (0 <= ref1 ? j1 < ref1 : j1 > ref1); i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(print_list(stack[i])));\n      }\n      return results;\n    }\n  };\n\n  // Compare terms for order, clobbers p1 and p2.\n  cmp_terms_count = 0;\n\n  cmp_terms = function(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    //if cmp_terms_count == 52\n    //  debugger\n    i = 0;\n    // numbers can be combined\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    // congruent tensors can be combined\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n        return -1;\n      }\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n        return 1;\n      }\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n          return -1;\n        }\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n          return 1;\n        }\n      }\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n    t = cmp_expr(p1, p2);\n    if (t === 0) {\n      flag = 1;\n    }\n    //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns \" + t\n    return t;\n  };\n\n  combine_terms = function(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    //debugger\n\n    // I had to turn the coffeescript for loop into\n    // a more mundane while loop because the i\n    // variable was changed from within the body,\n    // which is something that is not supposed to\n    // happen in the coffeescript 'vector' form.\n    // Also this means I had to add a 'i++' jus before\n    // the end of the body and before the \"continue\"s\n    i = 0;\n    while (i < (n - 1)) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n          for (j = o = ref = i + 1, ref1 = n - 1; (ref <= ref1 ? o < ref1 : o > ref1); j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n          i--;\n        }\n        i++;\n        continue;\n      }\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n        }\n        i--;\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n      t = 0;\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; (ref6 <= ref7 ? l1 < ref7 : l1 > ref7); j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n      push(p1);\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n      multiply();\n      stack[s + i] = pop();\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; (ref8 <= ref9 ? m1 < ref9 : m1 > ref9); j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n      n--;\n      i--;\n      // this i++ is to match the while\n      i++;\n    }\n    return n;\n  };\n\n  push_terms = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  // add two expressions\n  add = function() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n    for (i = o = 0, ref = k; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function() {\n    negate();\n    return add();\n  };\n\n  Eval_adj = function() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop(); // transpose\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  Eval_approxratio = function() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return approxratioRecursive();\n  };\n\n  approxratioRecursive = function() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n        approxratioRecursive();\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n      approxratioRecursive();\n      push(cdr(p1));\n      approxratioRecursive();\n      cons();\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  approxOneRatioOnly = function() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n      return;\n    }\n    // we didn't manage, just leave unexpressed\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  // original routine by John Kennedy, see\n  // https://web.archive.org/web/20111027100847/http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF\n  // courtesy of Michael Borcherds\n  // who ported this to JavaScript under MIT licence\n  // also see\n  // https://github.com/geogebra/geogebra/blob/master/common/src/main/java/org/geogebra/common/kernel/algos/AlgoFractionText.java\n  // potential other ways to do this:\n  //   https://rosettacode.org/wiki/Convert_decimal_number_to_rational\n  //   http://www.homeschoolmath.net/teaching/rational_numbers.php\n  //   http://stackoverflow.com/questions/95727/how-to-convert-floats-to-human-readable-fractions\n  floatToRatioRoutine = function(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n    if (isNaN(decimal)) {\n      return ret;\n    }\n    // return 0/0 \n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      // 1/0\n      return ret;\n    }\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      // -1/0\n      return ret;\n    }\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n    decimal = Math.abs(decimal);\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      // handles exact integers including 0 \n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal < 1.0e-19) {\n      // X = 0 already taken care of \n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n      // Rounding Function\n      if (!(Math.abs(decimal - (FractionNumerator / FractionDenominator)) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n\n  approx_sine_of_rational = 1;\n\n  approx_sine_of_pi_times_rational = 2;\n\n  approx_rationalOfPi = 3;\n\n  approx_radicalOfRatio = 4;\n\n  approx_nothingUseful = 5;\n\n  approx_ratioOfRadical = 6;\n\n  approx_rationalOfE = 7;\n\n  approx_logarithmsOfRationals = 8;\n\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n    // this one catches things like Math.sqrt(3/4), but\n    // things like Math.sqrt(1/2) are caught by the paragraph\n    // above (and in a better form)\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n\n    // we always prefer a rational of a radical of an integer\n    // to a radical of a rational. Radicals of rationals generate\n    // radicals at the denominator which we'd rather avoid\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxLogs = function(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a rational of a log to a log of\n    // a rational\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxRationalsOfLogs = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of logs\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n\n        // it does happen that due to roundings \n        // a \"higher multiple\" is picked, which is obviously\n        // unintended.\n        // E.g. 1 * log(1 / 3 ) doesn't match log( 3 ) BUT\n        // it matches -5 * log( 3 ) / 5\n        // so we avoid any case where the multiplier is a multiple\n        // of the divisor.\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple logs of rationals\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of e\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.E, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    // here we do somethng a little special: since\n    // the powers of pi can get quite big, there might\n    // be multiple hypothesis where more of the\n    // magnitude is shifted to the multiplier, and some\n    // where more of the magnitude is shifted towards the\n    // exponent of pi. So we prefer the hypotheses with the\n    // lower multiplier since it's likely to insert more\n    // information.\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of PI\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.PI, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    //console.log \"approxRationalsOfPowersOfPI returning: \" + bestResultSoFar\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a sin of a rational without the PI\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n    return null;\n  };\n\n  approxSineOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// we only check very simple rationals because they begin to get tricky\n// quickly, also they collide often with the \"rational of pi\" hypothesis.\n// For example sin(11) is veeery close to 1 (-0.99999020655)\n// (see: http://mathworld.wolfram.com/AlmostInteger.html )\n// we stop at rationals that mention up to 10\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// check rational multiples of pi\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        // magic number 23 comes from the case sin(pi/10)\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxAll = function(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxLogsResult = approxLogs(theFloat);\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function(aResult, b, c) {\n    var theSum;\n    theSum = null;\n    if (aResult instanceof Array) {\n      // we want PI and E to somewhat increase the\n      // complexity of the expression, so basically they count\n      // more than any integer lower than 3, i.e. we consider\n      // 1,2,3 to be more fundamental than PI or E.\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n        // exponents of PI and E need to be penalised as well\n        // otherwise they come to explain any big number\n        // so we count them just as much as the multiplier\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        default:\n          theSum = 0;\n      }\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n    \n    // heavily discount unit constants\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (theSum < 0) {\n      theSum = 0;\n    }\n    return theSum;\n  };\n\n  testApprox = function() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n        if (i === 1 && j === 1) {\n          continue;\n        }\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n// 5 digits create no problem\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n// 4 digits create two collisions\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    value = 0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n    value = 0.0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n    value = 0.00;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n    value = 0.000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n    value = 0.0000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n    value = 1;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n    value = 1.0;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n    value = 1.00;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n    value = 1.000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 1.00000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n    value = Math.sqrt(2);\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n    value = 1.41;\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n    // if we narrow down to a particular family then we can get\n    // an OK guess even with few digits, expecially for really \"famous\" numbers\n    value = 1.4;\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n    value = 0.6;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n    value = 0.69;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n    value = 0.7;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n    value = 1.09;\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n    value = 1.09;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n    value = 1.098;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n    value = 1.1;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n    value = 1.11;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n    value = Math.sqrt(3);\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 3.141592;\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n    value = 31.41592;\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n    value = 314.1592;\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n    value = 31415926.53589793;\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n    value = Math.sqrt(2);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n    value = Math.sqrt(3);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n    value = (Math.sqrt(5) - 1) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 7);\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 9);\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n    value = 1836.15267;\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        // with four digits, there are two collisions with the\n        // \"simple fraction\" argument hypotesis, which we prefer since\n        // it's a simpler expression, so let's skip those\n        // two tests\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n\n  $.approxAll = approxAll;\n\n  $.testApprox = testApprox;\n\n  Eval_arccos = function() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return 3/4*pi (135 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/6*pi (30 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 6.0);\n      } else {\n        push_rational(1, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return 5/6*pi (150 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(5.0 * Math.PI / 6.0);\n      } else {\n        push_rational(5, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arccosh = function() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arcsin = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return -1/4*pi (-45 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/3*pi (60 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 3.0);\n      } else {\n        push_rational(1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return -1/3*pi (-60 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 3.0);\n      } else {\n        push_rational(-1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arcsinh = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctan = function() {\n    push(cadr(p1));\n    Eval();\n    return arctan();\n  };\n\n  arctan = function() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      arctan();\n      negate();\n      restore();\n      return;\n    }\n    // arctan(sin(a) / cos(a)) ?\n    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {\n      push(p1);\n      numerator();\n      p2 = pop();\n      push(p1);\n      denominator();\n      p3 = pop();\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n    // arctan(1/sqrt(3)) -> pi/6\n    // second if catches the other way of saying it, sqrt(3)/3\n    if ((car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 6);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(1) -> pi/4\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(sqrt(3)) -> pi/3\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctanh = function() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function() {\n    save();\n    p1 = pop();\n    push(p1);\n    numerator();\n    yyarg();\n    push(p1);\n    denominator();\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  //define RE p2\n  //define IM p3\n  yyarg = function() {\n    save();\n    p1 = pop();\n    // case of plain number\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      negate();\n    // you'd think that something like\n    // arg(a) is always 0 when a is real but no,\n    // arg(a) is pi when a is negative so we have\n    // to leave unexpressed\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      // -1 to a power\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      // exponential\n      push(caddr(p1));\n      imag();\n    // arg(a^(1/2)) is always equal to 1/2 * arg(a)\n    // this can obviously be made more generic TODO\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n      if (DEBUG_ARG) {\n        debugger;\n      }\n      push(cadr(p1));\n      arg();\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      // product of factors\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      // sum of terms\n      push(p1);\n      rect();\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n        arctan();\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n          if (isnegative(p3)) {\n            subtract(); // quadrant 1 -> 3\n          } else {\n            add(); // quadrant 4 -> 2\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        // if we assume all passed values are real\n        push_integer(0);\n      } else {\n        // if we don't assume all passed values are real, all\n        // we con do is to leave unexpressed\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n    return restore();\n  };\n\n  // pretty print\n  bake = function() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    // don't bake the contents of some constructs such as \"for\"\n    // because we don't want to evaluate the body of\n    // such constructs \"statically\", i.e. without fully running\n    // the loops.\n    } else if ((iscons(p1)) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        bake();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n    return expanding--;\n  };\n\n  polyform = function() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        polyform();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  bake_poly = function() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    //U **a\n    a = tos;\n    k = coeff(p2, p1);\n    h = tos;\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  // p1 points to coefficient of p2 ^ k\n\n  // k is an int\n  bake_poly_term = function(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    // constant term?\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n      return;\n    }\n    h = tos;\n    // coefficient\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n    // x ^ k\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n\n  Eval_besselj = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  //define SGN p3\n  yybesselj = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    // numerical result\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    // bessej(0,0) = 1\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n    // besselj(0,n) = 0\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n    // half arguments\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      // n = 1/2\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n      // n = -1/2\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n      // besselj(x,n) = (2/x) (n-sgn(n)) besselj(x,n-sgn(n)) - besselj(x,n-2*sgn(n))\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n    //if 0 # test cases needed\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    //endif\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n\n  Eval_bessely = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  yybessely = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  //double convert_rational_to_double(U *)\n  //double convert_bignum_to_double(unsigned int *)\n  //int ge(unsigned int *, unsigned int *, int)\n  mint = function(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  // b is +1 or -1, a is a bigint\n  setSignTo = function(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makeSignSameAs = function(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makePositive = function(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n    return a;\n  };\n\n  // n is an int\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n\n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n   *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n  // p is the index of array of ints\n  // !!! array wasn't passed here\n  /*\n  free_stack = []\n\n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n  */\n  // convert int to bignum\n\n  // n is an int\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n   * !!! this is FU\n   * MSIGN(p) = -1\n      fu = true\n    else\n   * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n   * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n  // copy bignum\n\n  // a is an array of ints\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n\n    b = mnew(MLENGTH(a))\n\n   * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n\n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n\n    return b\n   */\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n  add_numbers = function() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n    //if DEBUG then console.log(\"add_numbers adding numbers: \" + print_list(stack[tos - 1]) + \" and \" + print_list(stack[tos - 2]))\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function() {\n    var a, b;\n    //unsigned int *a, *b\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  // a and b are Us\n  compare_rationals = function(a, b) {\n    var ab, ba, t;\n    t = 0;\n    //unsigned int *ab, *ba\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  // a and b are Us\n  compare_numbers = function(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n  negate_number = function() {\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n    return restore();\n  };\n\n  bignum_truncate = function() {\n    var a;\n    //unsigned int *a\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  // expo is an integer\n  bignum_power_number = function(expo) {\n    var a, b, t;\n    //unsigned int *a, *b, *t\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n    if (expo < 0) {\n      // swap a and b\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  // p an array of ints\n  convert_bignum_to_double = function(p) {\n    return p.toJSNumber();\n  };\n\n  // p is a U\n  convert_rational_to_double = function(p) {\n    var quotientAndRemainder, result;\n    if (p.q == null) {\n      debugger;\n    }\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  // n an integer\n  new_integer = function(n) {\n    var theNewInteger;\n    theNewInteger = new U();\n    theNewInteger.k = NUM;\n    theNewInteger.q.a = bigInt(n);\n    theNewInteger.q.b = bigInt(1);\n    return theNewInteger;\n  };\n\n  // n an integer\n  push_integer = function(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n    return push(new_integer(n));\n  };\n\n  // d a double\n  push_double = function(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  // a,b parts of a rational\n  push_rational = function(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function() {\n    var n;\n    n = 0/0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n        break;\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n          n = p1.d;\n        }\n    }\n    restore();\n    return n;\n  };\n\n  // p is a U, flag is an int\n  print_double = function(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n    return accumulator;\n  };\n\n  // s is a string\n  bignum_scan_integer = function(s) {\n    var a, scounter, sign_;\n    //unsigned int *a\n    //char sign\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n    // !!!! some mess in here, added an argument\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    if (sign_ === '-') {\n      negate();\n    }\n    return restore();\n  };\n\n  // s a string\n  bignum_scan_float = function(s) {\n    return push_double(parseFloat(s));\n  };\n\n  // gives the capability of printing the unsigned\n  // value. This is handy because printing of the sign\n  // might be taken care of \"upstream\"\n  // e.g. when printing a base elevated to a negative exponent\n  // prints the inverse of the base powered to the unsigned\n  // exponent.\n  // p is a U\n  print_number = function(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n        accumulator += aAsString;\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n          denominatorString = p.q.b.toString();\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n          accumulator += denominatorString;\n        }\n        break;\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        accumulator += aAsString;\n    }\n    return accumulator;\n  };\n\n  gcd_numbers = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    //  if (!isinteger(p1) || !isinteger(p2))\n    //    stop(\"integer args expected for gcd\")\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n      case DOUBLE:\n        d = p1.d;\n        break;\n      default:\n        d = 0.0;\n    }\n    restore();\n    return d;\n  };\n\n  bignum_float = function() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  //static unsigned int *__factorial(int)\n\n  // n is an int\n  bignum_factorial = function(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  // n is an int\n  __factorial = function(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n    //unsigned int *a, *b, *t\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n    a = bigInt(2);\n    b = bigInt(0);\n    if (3 <= n) {\n      for (i = o = 3, ref = n; (3 <= ref ? o <= ref : o >= ref); i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  // unsigned int *x, unsigned int k\n  mp_set_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  // unsigned int *x, unsigned int k\n  mp_clr_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  // unsigned int *a\n  mshiftright = function(a) {\n    return a = a.shiftRight();\n  };\n\n  //  Binomial coefficient\n\n  //  Input:    tos-2    n\n\n  //      tos-1    k\n\n  //  Output:    Binomial coefficient on stack\n\n  //  binomial(n, k) = n! / k! / (n - k)!\n\n  //  The binomial coefficient vanishes for k < 0 or k > n. (A=B, p. 19)\n  Eval_binomial = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  //define N p1\n  //define K p2\n  ybinomial = function() {\n    p2 = pop();\n    p1 = pop();\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_ceiling = function() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n\n  Eval_choose = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  // Result vanishes for k < 0 or k > n. (A=B, p. 19)\n\n  //define N p1\n  //define K p2\n  choose = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_circexp = function() {\n    push(cadr(p1));\n    Eval();\n    circexp();\n    // normalize\n    return Eval();\n  };\n\n  circexp = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        circexp();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return;\n    }\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        circexp();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n      restore();\n      return;\n    }\n    push(p1);\n    return restore();\n  };\n\n  Eval_clearall = function() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  // clearall from application GUI code\n  clearall = function() {\n    return run(\"clearall\");\n  };\n\n  // this transformation is done in run.coffee, see there\n  // for more info.\n  clearRenamedVariablesToAvoidBindingToExternalScope = function() {\n    var i, o, ref, results;\n    results = [];\n    for (i = o = 0, ref = symtab.length; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        // just clear it\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  Eval_clear = function() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n      //console.log variableToBeCleared + \"\"\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n      //console.log \"getting binding of \" + p.toString()\n      //if p.toString() == \"aaa\"\n      //  debugger\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n    return push(symbol(NIL));\n  };\n\n  /*\n   Convert complex z to clock form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n\n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n  */\n  // P.S. I couldn't find independent definition/aknowledgment\n  // of the naming \"clock form\" anywhere on the web, seems like a\n  // naming specific to eigenmath.\n  // Clock form is another way to express a complex number, and\n  // it has three advantages\n  //   1) it's uniform with how for example\n  //      i is expressed i.e. (-1)^(1/2)\n  //   2) it's very compact\n  //   3) it's a straighforward notation for roots of 1 and -1\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function() {\n    save();\n    //if 1\n    p1 = pop();\n    push(p1);\n    abs();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    // pushing the expression (-1)^... but note\n    // that we can't use \"power\", as \"power\" evaluates\n    // clock forms into rectangular form (see \"-1 ^ rational\"\n    // section in power)\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n    divide();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n    list(3);\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n    multiply();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    //else\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n    */\n    //endif\n    return restore();\n  };\n\n  /* coeff =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x,n\n\n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n\n  */\n  //define P p1\n  //define X p2\n  //define N p3\n  Eval_coeff = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (p3 === symbol(NIL)) { // p3 is N  # only 2 args?\n      p3 = p2;\n      p2 = symbol(SYMBOL_X); // p2 is X\n    }\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Put polynomial coefficients on the stack\n\n  //  Input:  as per params\n\n  //  Output:    Returns number of coefficients on stack\n\n  //      tos-n    Coefficient of x^0\n\n  //      tos-1    Coefficient of x^(n-1)\n\n  //-----------------------------------------------------------------------------\n  coeff = function(variable, polynomial) {\n    var coeffsCount, constant, polynomialWithoutConstant, prev_expanding;\n    if (DEBUG) {\n      console.log(\"coeff: \" + variable + \" \" + polynomial);\n    }\n    // works like this:\n    //   1) find the constant (by just evaluating the pol setting the variable to zero)\n    //   2) set aside the found constant: it's one of the coefficients to return\n    //   3) take the polynomial and remove the constant\n    //   4) divide that by variable, lowering the degree by one\n    //   5) go back to 1) until degree is zero\n    coeffsCount = 0;\n    while (true) {\n      push(polynomial);\n      push(variable);\n      push(zero);\n      subst();\n      Eval();\n      constant = pop();\n      \n      // this will be a coefficient that will be returned\n      push(constant);\n      coeffsCount++;\n      push(polynomial);\n      push(constant);\n      subtract();\n      polynomialWithoutConstant = pop();\n      if (equal(polynomialWithoutConstant, zero)) {\n        if (DEBUG) {\n          console.log(\"coeff: result: \" + coeffsCount);\n        }\n        return coeffsCount;\n      }\n      push(polynomialWithoutConstant);\n      push(variable);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      //console.log(\"just divided: \" + stack[tos-1].toString())\n      // this is now the new polynomial with degree decreased by 1\n      polynomial = pop();\n    }\n  };\n\n  Eval_cofactor = function() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n    determinant(n - 1);\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  // Condense an expression by factoring common terms.\n  Eval_condense = function() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function() {\n    //expanding = 0\n    p1 = pop();\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"calculating gcd between: \" + stack[tos - 1] + \" and \" + stack[tos - 2]);\n      }\n      gcd();\n      if (DEBUG) {\n        console.log(\"partial gcd: \" + stack[tos - 1]);\n      }\n      p3 = cdr(p3);\n    }\n    if (DEBUG) {\n      console.log(\"condense: this is the gcd of all the terms: \" + stack[tos - 1]);\n    }\n    // divide each term by gcd\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      //multiply()\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n    // We multiplied above w/o expanding so some factors cancelled.\n\n    // Now we expand which normalizes the result and, in some cases,\n    // simplifies it too (see test case H).\n    yyexpand();\n    // multiply result by gcd\n    push(p2);\n    return divide();\n  };\n\n  Eval_conj = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n    if (!Find(p1, imaginaryunit)) { // example: (-1)^(1/3)\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  // careful is you pass this one an expression with\n  // i (instead of (-1)^(1/2)) then this doesn't work!\n  conjugate = function() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n    subst();\n    return Eval();\n  };\n\n  // Cons two things on the stack.\n  consCount = 0;\n\n  cons = function() {\n    var p;\n    consCount++;\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n    //if consCount == 444\n    //  debugger\n    // auto var ok, no opportunity for garbage collection after p = alloc()\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n    */\n    return push(p);\n  };\n\n  Eval_contract = function() {\n    push(cadr(p1));\n    Eval();\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return contract();\n  };\n\n  contract = function() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    // nelem is the number of elements in \"b\"\n    nelem = 1;\n    for (i = o = 0, ref = ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n    //console.log \"nelem:\" + nelem\n    p2 = alloc_tensor(nelem);\n    //console.log \"p2:\" + p2\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n    for (i = i1 = 0, ref1 = ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n//console.log \"a: \" + a\n//console.log \"b: \" + b\n    for (i = j1 = 0, ref2 = ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref3 = nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n      for (j = m1 = 0, ref4 = n; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n        for (k = n1 = 0, ref5 = ndim; (0 <= ref5 ? n1 < ref5 : n1 > ref5); k = 0 <= ref5 ? ++n1 : --n1) {\n          h = (h * an[k]) + ai[k];\n        }\n        push(a[h]);\n        //console.log \"a[h]: \" + a[h]\n        add();\n      }\n      //console.log \"tos: \" + stack[tos-1]\n      b[i] = pop();\n//console.log \"b[i]: \" + b[i]\n      for (j = o1 = ref6 = ndim - 1; (ref6 <= 0 ? o1 <= 0 : o1 >= 0); j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n\n  //console.log \"returning: \" + stack[tos-1]\n  /* cos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the cosine of x.\n\n  */\n  Eval_cos = function() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function() {\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n    return restore();\n  };\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n  cosine_of_angle_sum = function() {\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n      p2 = cdr(p2);\n    }\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // cosine function is symmetric, cos(-x) = cos(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // cos(arctan(x)) = 1 / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 0:\n        return push_integer(1);\n      case 180:\n        return push_integer(-1);\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_cosh = function() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  // this function extract parts subtrees from a tree.\n  // It is used in two\n  // places that have to do with pattern matching.\n  // One is for integrals, where an expression or its\n  // subparts are matched against cases in an\n  // integrals table.\n  // Another one is for applyging tranformation patterns\n  // defined via PATTERN, again patterns are applied to\n  // either the whole expression or any of its parts.\n\n  // unclear to me at the moment\n  // why this is exposed as something that can\n  // be evalled. Never called.\n  Eval_decomp = function() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    decomp(false);\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n        return;\n      }\n    }\n    return push(toBePushed);\n  };\n\n  // returns constant expressions on the stack\n  decomp = function(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n    // is the entire expression constant?\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n        pushTryNotToDuplicate(p1);\n        //push(p1);  # may need later for pushing both +a, -a\n        //negate()\n        restore();\n        return;\n      }\n    }\n    // sum?\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n    // product?\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n    // naive decomp if not sum or product\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n    p3 = cdr(p1);\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n    while (iscons(p3)) {\n      // for a general transformations,\n      // we want to match any part of the tree so\n      // we need to push the subtree as well\n      // as recurse to its parts\n      if (generalTransform) {\n        push(car(p3));\n      }\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n      push(p2);\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n      decomp(generalTransform);\n      p3 = cdr(p3);\n    }\n    return restore();\n  };\n\n  decomp_sum = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n    h = 0;\n    // decomp terms involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // add together all constant terms\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate(); // need both +a, -a for some integrals\n    }\n  };\n\n  decomp_product = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n    h = 0;\n    // decomp factors involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // multiply together all constant factors\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  //p3 = pop();  # may need later for pushing both +a, -a\n  //push(p3)\n  //push(p3)\n  //negate()\n  // Store a function definition\n\n  // Example:\n\n  //      f(x,y)=x^y\n\n  // For this definition, p1 points to the following structure.\n\n  //     p1\n  //      |\n  //   ___v__    ______                        ______ \n  //  |CONS  |->|CONS  |--------------------->|CONS  |\n  //  |______|  |______|                      |______|\n  //      |         |                             |\n  //   ___v__    ___v__    ______    ______    ___v__    ______    ______\n  //  |SETQ  |  |CONS  |->|CONS  |->|CONS  |  |CONS  |->|CONS  |->|CONS  |\n  //  |______|  |______|  |______|  |______|  |______|  |______|  |______|\n  //                |         |         |         |         |         |\n  //             ___v__    ___v__    ___v__    ___v__    ___v__    ___v__\n  //            |SYM f |  |SYM x |  |SYM y |  |POWER |  |SYM x |  |SYM y |\n  //            |______|  |______|  |______|  |______|  |______|  |______|\n\n  // the result (in f) is a FUNCTION node\n  // that contains both the body and the argument list.\n\n  // We have\n\n  //  caadr(p1) points to the function name i.e. f\n  //  cdadr(p1) points to the arguments i.e. the list (x y)\n  //  caddr(p1) points to the function body i.e. (power x y)\n\n  //define F p3 # F points to the function name\n  //define A p4 # A points to the argument list\n  //define B p5 # B points to the function body\n  define_user_function = function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n    if (!issymbol(p3)) { // p3 is F\n      stop(\"function name?\");\n    }\n    // evaluate function body (maybe)\n    if (car(p5) === symbol(EVAL)) { // p5 is B\n      push(cadr(p5));\n      Eval();\n      p5 = pop(); // p5 is B\n    }\n    \n    // note how, unless explicitly forced by an eval,\n    // (handled by the if just above)\n    // we don't eval/simplify\n    // the body.\n    // Why? because it's the easiest way\n    // to solve scope problems i.e.\n    //   x = 0\n    //   f(x) = x + 1\n    //   f(4) # would reply 1\n    // which would need to otherwise\n    // be solved by some scope device\n    // somehow\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function() {\n    return push(p1);\n  };\n\n  /* defint =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n\n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n\n  */\n  //define F p2\n  //define X p3\n  //define A p4\n  //define B p5\n  Eval_defint = function() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop(); // p2 is F\n    p1 = cddr(p1);\n    // defint can handle multiple\n    // integrals, so we loop over the\n    // multiple integrals here\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop(); // p3 is X\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop(); // p4 is A\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop(); // p5 is B\n      \n      // obtain the primitive of F against the\n      // specified variable X\n      // note that the primitive changes over\n      // the calculation of the multiple\n      // integrals.\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop(); // contains the antiderivative of F\n      \n      // evaluate the integral in A\n      push(p2);\n      push(p3);\n      push(p5);\n      subst();\n      Eval();\n      // evaluate the integral in B\n      push(p2);\n      push(p3);\n      push(p4);\n      subst();\n      Eval();\n      // integral between B and A is the\n      // subtraction. Note that this could\n      // be a number but also a function.\n      // and we might have to integrate this\n      // number/function again doing the while\n      // loop again if this is a multiple\n      // integral.\n      subtract();\n      p2 = pop();\n    }\n    return push(p2);\n  };\n\n  Eval_degree = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return degree();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Find the degree of a polynomial\n\n  //  Input:    tos-2    p(x)\n\n  //      tos-1    x\n\n  //  Output:    Result on stack\n\n  //  Note: Finds the largest numerical power of x. Does not check for\n  //  weirdness in p(x).\n\n  //-----------------------------------------------------------------------------\n\n  //define POLY p1\n  //define X p2\n  //define DEGREE p3\n  degree = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n    yydegree(p1);\n    push(p3);\n    return restore();\n  };\n\n  yydegree = function(p) {\n    var results;\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        yydegree(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    }\n  };\n\n  Eval_denominator = function() {\n    push(cadr(p1));\n    Eval();\n    return denominator();\n  };\n\n  denominator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    //console.trace \"denominator of: \" + theArgument\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        denominator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  // derivative\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_derivative = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    // evaluate 1st arg to get function F\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example  result of 2nd arg  what to do\n\n    // d(f)    nil      guess X, N = nil\n    // d(f,2)  2      guess X, N = 2\n    // d(f,x)  x      X = x, N = nil\n    // d(f,x,2)  x      X = x, N = 2\n    // d(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // p5 (N) might be a symbol instead of a number\n      if (isNumericAtom(p5)) { // p5 is N\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n      p3 = pop();\n      if (p5 === symbol(NIL)) { // p5 is N\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) { // p5 is N\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) { // p5 is N\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) { // p5 is N\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // p5 is N  # N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // p5 is N  # N = arg1\n      }\n    }\n    return push(p3); // p3 is F # final result\n  };\n\n  derivative = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n    return restore();\n  };\n\n  d_scalar_scalar = function() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      // Example: d(sin(cos(x)),cos(x))\n      // Replace cos(x) <- X, find derivative, then do X <- cos(x)\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n      subst();\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return subst(); // cos(X) -> cos(cos(x))\n    }\n  };\n\n  d_scalar_scalar_1 = function() {\n    // d(x,x)?\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n    return dfunction();\n  };\n\n  dsum = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n    return add_all(tos - h);\n  };\n\n  dproduct = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n        p3 = cdr(p3);\n      }\n      multiply_all(n);\n    }\n    return add_all(n);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //       v\n  //  y = u\n\n  //  log y = v log u\n\n  //  1 dy   v du           dv\n  //  - -- = - -- + (log u) --\n  //  y dx   u dx           dx\n\n  //  dy    v  v du           dv\n  //  -- = u  (- -- + (log u) --)\n  //  dx       u dx           dx\n\n  //-----------------------------------------------------------------------------\n  dpower = function() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  //  derivative of derivative\n\n  //  example: d(d(f(x,y),y),x)\n\n  //  p1 = d(f(x,y),y)\n\n  //  p2 = x\n\n  //  cadr(p1) = f(x,y)\n\n  //  caddr(p1) = y\n  dd = function() {\n    // d(f(x,y),x)\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n    if (car(p3) === symbol(DERIVATIVE)) {\n      // sort dx terms\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  // derivative of a generic function\n  dfunction = function() {\n    p3 = cdr(p1);\n    if (p3 === symbol(NIL) || Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  //        Without simplify  With simplify\n\n  //  d(arctan(y/x),x)  -y/(x^2*(y^2/x^2+1))  -y/(x^2+y^2)\n\n  //  d(arctan(y/x),y)  1/(x*(y^2/x^2+1))  x/(x^2+y^2)\n  darctan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function() {\n    return push(cadr(p1));\n  };\n\n  DET_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n      determinant(p1.tensor.dim[0]);\n    }\n    return restore();\n  };\n\n  // determinant of n * n matrix elements on the stack\n  determinant = function(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    //int *a, *c, *d\n    h = tos - n * n;\n//a = (int *) malloc(3 * n * sizeof (int))\n\n    //if (a == NULL)\n//  out_of_memory()\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n    sign_ = 1;\n    push(zero);\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n      for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply(); // FIXME -- problem here\n      }\n      add();\n      // next permutation (Knuth's algorithm P)\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        break;\n      }\n      if (breakFromOutherWhile) {\n        break;\n      }\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack\n\n  //  Output:    Determinant on stack\n\n  //  Note:\n\n  //  Uses Gaussian elimination which is faster for numerical matrices.\n\n  //  Gaussian Elimination works by walking down the diagonal and clearing\n  //  out the columns below it.\n\n  //-----------------------------------------------------------------------------\n  detg = function() {\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    for (i = o = 0, ref = n * n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n matrix elements on stack\n\n  //  Output:    p1  determinant\n\n  //      p2  mangled\n\n  //      upper diagonal matrix on stack\n\n  //-----------------------------------------------------------------------------\n  M = function(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n    for (d = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(M(h, n, d, d), zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n// exchange rows\n        for (j = j1 = ref3 = d, ref4 = n; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n        // negate det\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n      // update det\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n// update lower diagonal matrix\n      for (i = l1 = ref5 = d + 1, ref6 = n; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n        // multiplier\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        // update one row\n        setM(h, n, i, d, zero);\n        for (j = m1 = ref7 = d + 1, ref8 = n; (ref7 <= ref8 ? m1 < ref8 : m1 > ref8); j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n    // last diagonal element\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Dirac function dirac(x)\n  //  dirac(-x)=dirac(x)\n  //  dirac(b-a)=dirac(a-b)\n  //-----------------------------------------------------------------------------\n  Eval_dirac = function() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  //define p1 p1\n  ydirac = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate all divisors of a term\n\n  //  Input:    Term on stack (factor * factor * ...)\n\n  //  Output:    Divisors on stack\n\n  //-----------------------------------------------------------------------------\n  divisors = function() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    //qsort(stack + h, n, sizeof (U *), __cmp)\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n    // push all of the term's factors\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n      __factor_add();\n    //printf(\">>>\\n\")\n    //for (i = h; i < tos; i++)\n    //print(stdout, stack[i])\n    //printf(\"<<<\\n\")\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n    k = tos;\n    // contruct divisors by recursive descent\n    push(one);\n    gen(h, k);\n    // move\n    n = tos - k;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n    moveTos(h + n);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate divisors\n\n  //  Input:    Base-exponent pairs on stack\n\n  //      h  first pair\n\n  //      k  just past last pair\n\n  //  Output:    Divisors on stack\n\n  //  For example, factor list 2 2 3 1 results in 6 divisors,\n\n  //    1\n  //    3\n  //    2\n  //    6\n  //    4\n  //    12\n\n  //-----------------------------------------------------------------------------\n\n  //define ACCUM p1\n  //define BASE p2\n  //define EXPO p3\n  gen = function(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n        gen(h + 2, k);\n      }\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor ADD expression\n\n  //  Input:    Expression on stack\n\n  //  Output:    Factors on stack\n\n  //  Each factor consists of two expressions, the factor itself followed\n  //  by the exponent.\n\n  //-----------------------------------------------------------------------------\n  __factor_add = function() {\n    save();\n    p1 = pop();\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    // check gcd\n    p2 = pop();\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n    // push factored gcd\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n      p3 = cdr(p3);\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n    // divide each term by gcd\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n    push(one);\n    return restore();\n  };\n\n  // power function for double precision floating point\n  dpow = function() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n    // divide by zero?\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n    // nonnegative base or integer power?\n    if (base >= 0.0 || (expo % 1.0) === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n    // this ensures the real part is 0.0 instead of a tiny fraction\n    if ((expo % 0.5) === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n\n  /* eigen =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n\n  Input:    stack[tos - 1]    symmetric matrix\n\n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n\n  D and Q have the property that\n\n    A == dot(transpose(Q),D,Q)\n\n  where A is the original matrix.\n\n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n\n  The eigenvalue relation:\n\n    A X = lambda X\n\n  can be checked as follows:\n\n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n\n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n\n  Enter:\n\n       A = hilbert(3)\n\n       eigen(A)\n\n       lambda = D[1,1]\n\n       X = Q[1]\n\n       dot(A,X) - lambda X\n\n  Result:\n\n       -1.16435e-14\n\n       -6.46705e-15\n\n       -4.55191e-15\n\n  Example 2: Check the relation A = QTDQ.\n\n  Enter:\n\n    A - dot(transpose(Q),D,Q)\n\n  Result: \n\n    6.27365e-12    -1.58236e-11   1.81902e-11\n\n    -1.58236e-11   -1.95365e-11   2.56514e-12\n\n    1.81902e-11    2.56514e-12    1.32627e-11\n\n  */\n  //define D(i, j) yydd[EIG_N * (i) + (j)]\n  //define Q(i, j) yyqq[EIG_N * (i) + (j)]\n  EIG_N = 0;\n\n  EIG_yydd = [];\n\n  EIG_yyqq = [];\n\n  Eval_eigen = function() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_eigenval = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n\n  Eval_eigenvec = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    p1 = pop();\n    if (!istensor(p1)) {\n      return 0;\n    }\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    EIG_N = p1.tensor.dim[0];\n    for (i = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = EIG_N - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n    return 1;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    p1    matrix\n\n  //  Output:    p2    eigenvalues\n\n  //      p3    eigenvectors\n\n  //-----------------------------------------------------------------------------\n  eigen = function(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n// malloc working vars\n\n    //EIG_yydd = (double *) malloc(n * n * sizeof (double))\n    for (i = o = 0, ref = EIG_N * EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n//if (EIG_yydd == NULL)\n//  stop(\"malloc failure\")\n\n    //EIG_yyqq = (double *) malloc(n * n * sizeof (double))\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n//if (EIG_yyqq == NULL)\n//  stop(\"malloc failure\")\n\n    // initialize D\n    for (i = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n// initialize Q\n    for (i = m1 = 0, ref5 = EIG_N; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; (ref6 <= ref7 ? n1 < ref7 : n1 > ref7); j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n// step up to 100 times\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n    // p2 = D\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n      for (i = q1 = 0, ref8 = EIG_N; (0 <= ref8 ? q1 < ref8 : q1 > ref8); i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; (0 <= ref9 ? r1 < ref9 : r1 > ref9); j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n    // p3 = Q\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n      for (i = s1 = 0, ref10 = EIG_N; (0 <= ref10 ? s1 < ref10 : s1 > ref10); i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push((function() {\n          var ref11, results1, t1;\n          results1 = [];\n          for (j = t1 = 0, ref11 = EIG_N; (0 <= ref11 ? t1 < ref11 : t1 > ref11); j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n          return results1;\n        })());\n      }\n      return results;\n    }\n  };\n\n  // free working vars\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 1, q = 3\n\n  //    c  0  s  0\n\n  //    0  1  0  0\n  //  G =\n  //    -s  0  c  0\n\n  //    0  0  0  1\n\n  //  The effect of multiplying G times A is...\n\n  //  row 1 of A    = c (row 1 of A ) + s (row 3 of A )\n  //            n+1                n                 n\n\n  //  row 3 of A    = c (row 3 of A ) - s (row 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  row 1 = c row 1 + s row 3\n\n  //    A[1,1] = c A[1,1] + s A[3,1]\n\n  //    A[1,2] = c A[1,2] + s A[3,2]\n\n  //    A[1,3] = c A[1,3] + s A[3,3]\n\n  //    A[1,4] = c A[1,4] + s A[3,4]\n\n  //  row 3 = c row 3 - s row 1\n\n  //    A[3,1] = c A[3,1] - s A[1,1]\n\n  //    A[3,2] = c A[3,2] - s A[1,2]\n\n  //    A[3,3] = c A[3,3] - s A[1,3]\n\n  //    A[3,4] = c A[3,4] - s A[1,4]\n\n  //                                     T\n  //  The effect of multiplying A times G  is...\n\n  //  col 1 of A    = c (col 1 of A ) + s (col 3 of A )\n  //            n+1                n                 n\n\n  //  col 3 of A    = c (col 3 of A ) - s (col 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  col 1 = c col 1 + s col 3\n\n  //    A[1,1] = c A[1,1] + s A[1,3]\n\n  //    A[2,1] = c A[2,1] + s A[2,3]\n\n  //    A[3,1] = c A[3,1] + s A[3,3]\n\n  //    A[4,1] = c A[4,1] + s A[4,3]\n\n  //  col 3 = c col 3 - s col 1\n\n  //    A[1,3] = c A[1,3] - s A[1,1]\n\n  //    A[2,3] = c A[2,3] - s A[2,1]\n\n  //    A[3,3] = c A[3,3] - s A[3,1]\n\n  //    A[4,3] = c A[4,3] - s A[4,1]\n\n  //  What we want to do is just compute the upper triangle of A since we\n  //  know the lower triangle is identical.\n\n  //  In other words, we just want to update components A[i,j] where i < j.\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 2, q = 5\n\n  //        p      q\n\n  //      j=1  j=2  j=3  j=4  j=5  j=6\n\n  //    i=1  .  A[1,2]  .  .  A[1,5]  .\n\n  //  p  i=2  A[2,1]  A[2,2]  A[2,3]  A[2,4]  A[2,5]  A[2,6]\n\n  //    i=3  .  A[3,2]  .  .  A[3,5]  .\n\n  //    i=4  .  A[4,2]  .  .  A[4,5]  .\n\n  //  q  i=5  A[5,1]  A[5,2]  A[5,3]  A[5,4]  A[5,5]  A[5,6]\n\n  //    i=6  .  A[6,2]  .  .  A[6,5]  .\n\n  //-----------------------------------------------------------------------------\n\n  //  This is what B = GA does:\n\n  //  row 2 = c row 2 + s row 5\n\n  //    B[2,1] = c * A[2,1] + s * A[5,1]\n  //    B[2,2] = c * A[2,2] + s * A[5,2]\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,5] = c * A[2,5] + s * A[5,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //  row 5 = c row 5 - s row 2\n\n  //    B[5,1] = c * A[5,1] + s * A[2,1]\n  //    B[5,2] = c * A[5,2] + s * A[2,2]\n  //    B[5,3] = c * A[5,3] + s * A[2,3]\n  //    B[5,4] = c * A[5,4] + s * A[2,4]\n  //    B[5,5] = c * A[5,5] + s * A[2,5]\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //                 T\n  //  This is what BG  does:\n\n  //  col 2 = c col 2 + s col 5\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n  //    B[2,2] = c * A[2,2] + s * A[2,5]\n  //    B[3,2] = c * A[3,2] + s * A[3,5]\n  //    B[4,2] = c * A[4,2] + s * A[4,5]\n  //    B[5,2] = c * A[5,2] + s * A[5,5]\n  //    B[6,2] = c * A[6,2] + s * A[6,5]\n\n  //  col 5 = c col 5 - s col 2\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[2,5] = c * A[2,5] - s * A[2,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n  //    B[5,5] = c * A[5,5] - s * A[5,2]\n  //    B[6,5] = c * A[6,5] - s * A[6,2]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 1: Just do upper triangle (i < j), B[2,5] = 0\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 2: Transpose where i > j since A[i,j] == A[j,i]\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[3,5]\n  //    B[2,4] = c * A[2,4] + s * A[4,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[2,3]\n  //    B[4,5] = c * A[4,5] - s * A[2,4]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 3: Same as above except reorder\n\n  //  k < p    (k = 1)\n\n  //    A[1,2] = c * A[1,2] + s * A[1,5]\n  //    A[1,5] = c * A[1,5] - s * A[1,2]\n\n  //  p < k < q  (k = 3..4)\n\n  //    A[2,3] = c * A[2,3] + s * A[3,5]\n  //    A[3,5] = c * A[3,5] - s * A[2,3]\n\n  //    A[2,4] = c * A[2,4] + s * A[4,5]\n  //    A[4,5] = c * A[4,5] - s * A[2,4]\n\n  //  q < k    (k = 6)\n\n  //    A[2,6] = c * A[2,6] + s * A[5,6]\n  //    A[5,6] = c * A[5,6] - s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n  step = function() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n// for each upper triangle \"off-diagonal\" component do step2\n    for (i = o = 0, ref = EIG_N - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  step2 = function(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    // compute c and s\n\n    // from Numerical Recipes (except they have a_qq - a_pp)\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n    if (theta < 0.0) {\n      t = -t;\n    }\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n// D = GD\n\n    // which means \"add rows\"\n    for (k = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n// D = D transpose(G)\n\n    // which means \"add columns\"\n    for (k = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n// Q = GQ\n\n    // which means \"add rows\"\n    for (k = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n\n  Eval_erf = function() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  erfc(x)\n\n  //  GW  Added erfc() from Numerical Recipes in C\n\n  //-----------------------------------------------------------------------------\n  Eval_erfc = function() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  // from Numerical Recipes in C\n  erfc = function(x) {\n    var ans, t, z;\n    if (x === 0) {\n      return 1.0;\n    }\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  // Evaluate an expression, for example...\n\n  //  push(p1)\n  //  Eval()\n  //  p2 = pop()\n  Eval = function() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n    if (p1 == null) {\n      debugger;\n    }\n    if (!evaluatingAsFloats && isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n        break;\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n      case TENSOR:\n        Eval_tensor();\n        break;\n      case SYM:\n        Eval_sym();\n        break;\n      default:\n        stop(\"atom?\");\n    }\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n    return restore();\n  };\n\n  Eval_sym = function() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n    // note that function calls are not processed here\n    // because, since they have an argument (at least an empty one)\n    // they are actually CONs, which is a branch of the\n    // switch before the one that calls this function\n\n    // bare keyword?\n    // If it's a keyword, then we don't look\n    // at the binding array, because keywords\n    // are not redefinable. \n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n    // Evaluate symbol's binding\n    p2 = get_binding(p1);\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n    push(p2);\n    // differently from standard Lisp,\n    // here the evaluation is not\n    // one-step only, rather it keeps evaluating\n    // \"all the way\" until a symbol is\n    // defined as itself.\n    // Uncomment these two lines to get Lisp\n    // behaviour (and break most tests)\n    if (p1 !== p2) {\n      // detect recursive lookup of symbols, which would otherwise\n      // cause a stack overflow.\n      // Note that recursive functions will still work because\n      // as mentioned at the top, this method doesn't look\n      // up and evaluate function calls.\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function() {\n    var cons_head;\n    cons_head = car(p1);\n    // normally the cons_head is a symbol,\n    // but sometimes in the case of\n    // functions we don't have a symbol,\n    // we have to evaluate something to get to the\n    // symbol. For example if a function is inside\n    // a tensor, then we need to evaluate an index\n    // access first to get to the function.\n    // In those cases, we find an EVAL here,\n    // so we proceed to EVAL\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n      case ADD:\n        return Eval_add();\n      case ADJ:\n        return Eval_adj();\n      case AND:\n        return Eval_and();\n      case ARCCOS:\n        return Eval_arccos();\n      case ARCCOSH:\n        return Eval_arccosh();\n      case ARCSIN:\n        return Eval_arcsin();\n      case ARCSINH:\n        return Eval_arcsinh();\n      case ARCTAN:\n        return Eval_arctan();\n      case ARCTANH:\n        return Eval_arctanh();\n      case ARG:\n        return Eval_arg();\n      case ATOMIZE:\n        return Eval_atomize();\n      case BESSELJ:\n        return Eval_besselj();\n      case BESSELY:\n        return Eval_bessely();\n      case BINDING:\n        return Eval_binding();\n      case BINOMIAL:\n        return Eval_binomial();\n      case CEILING:\n        return Eval_ceiling();\n      case CHECK:\n        return Eval_check();\n      case CHOOSE:\n        return Eval_choose();\n      case CIRCEXP:\n        return Eval_circexp();\n      case CLEAR:\n        return Eval_clear();\n      case CLEARALL:\n        return Eval_clearall();\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n      case CLOCK:\n        return Eval_clock();\n      case COEFF:\n        return Eval_coeff();\n      case COFACTOR:\n        return Eval_cofactor();\n      case CONDENSE:\n        return Eval_condense();\n      case CONJ:\n        return Eval_conj();\n      case CONTRACT:\n        return Eval_contract();\n      case COS:\n        return Eval_cos();\n      case COSH:\n        return Eval_cosh();\n      case DECOMP:\n        return Eval_decomp();\n      case DEGREE:\n        return Eval_degree();\n      case DEFINT:\n        return Eval_defint();\n      case DENOMINATOR:\n        return Eval_denominator();\n      case DERIVATIVE:\n        return Eval_derivative();\n      case DET:\n        return Eval_det();\n      case DIM:\n        return Eval_dim();\n      case DIRAC:\n        return Eval_dirac();\n      case DIVISORS:\n        return Eval_divisors();\n      case DO:\n        return Eval_do();\n      case DOT:\n        return Eval_inner();\n      case DRAW:\n        return Eval_draw();\n      case DSOLVE:\n        return Eval_dsolve();\n      case EIGEN:\n        return Eval_eigen();\n      case EIGENVAL:\n        return Eval_eigenval();\n      case EIGENVEC:\n        return Eval_eigenvec();\n      case ERF:\n        return Eval_erf();\n      case ERFC:\n        return Eval_erfc();\n      case EVAL:\n        return Eval_Eval();\n      case EXP:\n        return Eval_exp();\n      case EXPAND:\n        return Eval_expand();\n      case EXPCOS:\n        return Eval_expcos();\n      case EXPSIN:\n        return Eval_expsin();\n      case FACTOR:\n        return Eval_factor();\n      case FACTORIAL:\n        return Eval_factorial();\n      case FACTORPOLY:\n        return Eval_factorpoly();\n      case FILTER:\n        return Eval_filter();\n      case FLOATF:\n        return Eval_float();\n      case APPROXRATIO:\n        return Eval_approxratio();\n      case FLOOR:\n        return Eval_floor();\n      case FOR:\n        return Eval_for();\n      // this is invoked only when we\n      // evaluate a function that is NOT being called\n      // e.g. when f is a function as we do\n      //  g = f\n      case FUNCTION:\n        return Eval_function_reference();\n      case GAMMA:\n        return Eval_gamma();\n      case GCD:\n        return Eval_gcd();\n      case HERMITE:\n        return Eval_hermite();\n      case HILBERT:\n        return Eval_hilbert();\n      case IMAG:\n        return Eval_imag();\n      case INDEX:\n        return Eval_index();\n      case INNER:\n        return Eval_inner();\n      case INTEGRAL:\n        return Eval_integral();\n      case INV:\n        return Eval_inv();\n      case INVG:\n        return Eval_invg();\n      case ISINTEGER:\n        return Eval_isinteger();\n      case ISPRIME:\n        return Eval_isprime();\n      case LAGUERRE:\n        return Eval_laguerre();\n      //  when LAPLACE then Eval_laplace()\n      case LCM:\n        return Eval_lcm();\n      case LEADING:\n        return Eval_leading();\n      case LEGENDRE:\n        return Eval_legendre();\n      case LOG:\n        return Eval_log();\n      case LOOKUP:\n        return Eval_lookup();\n      case MOD:\n        return Eval_mod();\n      case MULTIPLY:\n        return Eval_multiply();\n      case NOT:\n        return Eval_not();\n      case NROOTS:\n        return Eval_nroots();\n      case NUMBER:\n        return Eval_number();\n      case NUMERATOR:\n        return Eval_numerator();\n      case OPERATOR:\n        return Eval_operator();\n      case OR:\n        return Eval_or();\n      case OUTER:\n        return Eval_outer();\n      case PATTERN:\n        return Eval_pattern();\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n      case POLAR:\n        return Eval_polar();\n      case POWER:\n        return Eval_power();\n      case PRIME:\n        return Eval_prime();\n      case PRINT:\n        return Eval_print();\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n      case PRINTFULL:\n        return Eval_printcomputer();\n      case PRINTLATEX:\n        return Eval_printlatex();\n      case PRINTLIST:\n        return Eval_printlist();\n      case PRINTPLAIN:\n        return Eval_printhuman();\n      case PRODUCT:\n        return Eval_product();\n      case QUOTE:\n        return Eval_quote();\n      case QUOTIENT:\n        return Eval_quotient();\n      case RANK:\n        return Eval_rank();\n      case RATIONALIZE:\n        return Eval_rationalize();\n      case REAL:\n        return Eval_real();\n      case ROUND:\n        return Eval_round();\n      case YYRECT:\n        return Eval_rect();\n      case ROOTS:\n        return Eval_roots();\n      case SETQ:\n        return Eval_setq();\n      case SGN:\n        return Eval_sgn();\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n      case SIMPLIFY:\n        return Eval_simplify();\n      case SIN:\n        return Eval_sin();\n      case SINH:\n        return Eval_sinh();\n      case SHAPE:\n        return Eval_shape();\n      case SQRT:\n        return Eval_sqrt();\n      case STOP:\n        return Eval_stop();\n      case SUBST:\n        return Eval_subst();\n      case SUM:\n        return Eval_sum();\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n      case TAN:\n        return Eval_tan();\n      case TANH:\n        return Eval_tanh();\n      case TAYLOR:\n        return Eval_taylor();\n      case TEST:\n        return Eval_test();\n      case TESTEQ:\n        return Eval_testeq();\n      case TESTGE:\n        return Eval_testge();\n      case TESTGT:\n        return Eval_testgt();\n      case TESTLE:\n        return Eval_testle();\n      case TESTLT:\n        return Eval_testlt();\n      case TRANSPOSE:\n        return Eval_transpose();\n      case UNIT:\n        return Eval_unit();\n      case ZERO:\n        return Eval_zero();\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function() {\n    return push(get_binding(cadr(p1)));\n  };\n\n  Eval_check = function() {\n    var checkResult;\n    // check the argument\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // returned null: unknown result\n      // leave the whole check unevalled\n      return push(p1);\n    } else {\n      // returned 1 or 0\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n\n  Eval_dim = function() {\n    var n;\n    //int n\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n    if (!istensor(p2)) {\n      return push_integer(1); // dim of scalar is 1\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n\n  Eval_do = function() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_dsolve = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  // for example, Eval(f,x,2)\n  Eval_Eval = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n      subst();\n      p1 = cddr(p1);\n    }\n    return Eval();\n  };\n\n  // exp evaluation: it replaces itself with\n  // a POWER(E,something) node and evals that one\n  Eval_exp = function() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_hermite = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    \n    // look into the head of the list,\n    // when evaluated it should be a tensor\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n    if (!istensor(theTensor)) {\n      // the tensor is not allocated yet, so\n      // leaving the expression unevalled\n      moveTos(h);\n      push(orig);\n      return;\n    }\n    // we examined the head of the list which\n    // was the tensor, now look into\n    // the indexes\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        // index with something other than\n        // an integer\n        moveTos(h);\n        push(orig);\n        return;\n      }\n      p1 = cdr(p1);\n    }\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function() {\n    push(cadr(p1));\n    Eval();\n    return inv();\n  };\n\n  Eval_invg = function() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n    return list(tos - h);\n  };\n\n  // quote definition\n  Eval_quote = function() {\n    return push(cadr(p1));\n  };\n\n  // rank definition\n  Eval_rank = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  // Evaluates the right side and assigns the\n  // result of the evaluation to the left side.\n  // It's called setq because it stands for \"set quoted\" from Lisp,\n  // see:\n  //   http://stackoverflow.com/questions/869529/difference-between-set-setq-and-setf-in-common-lisp\n  // Note that this also takes case of assigning to a tensor\n  // element, which is something that setq wouldn't do\n  // in list, see comments further down below.\n\n  // Example:\n  //   f = x\n  //   // f evaluates to x, so x is assigned to g really\n  //   // rather than actually f being assigned to g\n  //   g = f\n  //   f = y\n  //   g\n  //   > x\n  Eval_setq = function() {\n    // case of tensor\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n    // case of function definition\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    // An assignment returns nothing.\n    // This is unlike most programming languages\n    // where an assignment does return the\n    // assigned value.\n    // TODO Could be changed.\n    return push(symbol(NIL));\n  };\n\n  // Here \"setq\" is a misnomer because\n  // setq wouldn't work in Lisp to set array elements\n  // since setq stands for \"set quoted\" and you wouldn't\n  // quote an array element access.\n  // You'd rather use setf, which is a macro that can\n  // assign a value to anything.\n  //   (setf (aref YourArray 2) \"blue\")\n  // see\n  //   http://stackoverflow.com/questions/18062016/common-lisp-how-to-set-an-element-in-a-2d-array\n  //-----------------------------------------------------------------------------\n\n  //  Example: a[1] = b\n\n  //  p1  *-------*-----------------------*\n  //    |  |      |\n  //    setq  *-------*-------*  b\n  //      |  |  |\n  //      index  a  1\n\n  //  cadadr(p1) -> a\n\n  //-----------------------------------------------------------------------------\n  setq_indexed = function() {\n    var h;\n    p4 = cadadr(p1);\n    if (!issymbol(p4)) {\n      // this is likely to happen when one tries to\n      // do assignments like these\n      //   1[2] = 3\n      // or\n      //   f(x)[1] = 2\n      // or\n      //   [[1,2],[3,4]][5] = 6\n\n      // In other words, one can only do\n      // a straight assignment like\n      //   existingMatrix[index] = something\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n    subst();\n    return Eval(); // normalize\n  };\n\n  \n  // always returns a matrix with rank 2\n  // i.e. two dimensions,\n  // the passed parameter is the size\n  Eval_unit = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  // like Eval() except \"=\" (assignment) is treated\n  // as \"==\" (equality test)\n  // This is because\n  //  * this allows users to be lazy and just\n  //    use \"=\" instead of \"==\" as per more common\n  //    mathematical notation\n  //  * in many places we don't expect an assignment\n  //    e.g. we don't expect to test the zero-ness\n  //    of an assignment or the truth value of\n  //    an assignment\n  // Note that these are questionable assumptions\n  // as for example in most programming languages one\n  // can indeed test the value of an assignment (the\n  // value is just the evaluation of the right side)\n  Eval_predicate = function() {\n    save();\n    p1 = top();\n    if (car(p1) === symbol(SETQ)) {\n      // replace the assignment in the\n      // head with an equality test\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n    Eval();\n    return restore();\n  };\n\n  // Partial fraction expansion\n\n  // Example\n\n  //      expand(1/(x^3+x^2),x)\n\n  //        1      1       1\n  //      ---- - --- + -------\n  //        2     x     x + 1\n  //       x\n  Eval_expand = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    return expand();\n  };\n\n  //define A p2\n  //define B p3\n  //define C p4\n  //define F p5\n  //define P p6\n  //define Q p7\n  //define T p8\n  //define X p9\n  expand = function() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n    // if sum of terms then sum over the expansion of each term\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n        expand();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // B = numerator\n    push(p5);\n    numerator();\n    p3 = pop();\n    // A = denominator\n    push(p5);\n    denominator();\n    p2 = pop();\n    remove_negative_exponents();\n    // Q = quotient\n    push(p3);\n    push(p2);\n    push(p9);\n    // if the denominator is one then always bail out\n    // also bail out if the denominator is not one but\n    // it's not anything recognizable as a polynomial.\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        // p5 is the original input, leave unchanged\n        restore();\n        return;\n      }\n    }\n    divpoly();\n    p7 = pop();\n    // remainder B = B - A * Q\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n    // if the remainder is zero then we're done\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n    // A = factor(A)\n\n    //console.log(\"expand - to be factored: \" + p2)\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    //console.log(\"expand - factored to: \" + p2)\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      inv();\n      expanding = prev_expanding;\n      push(p3);\n      inner();\n      push(p2);\n      inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n    for (i = o = 0, ref = p5.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n      expand();\n      p5.tensor.elem[i] = pop();\n    }\n    return push(p5);\n  };\n\n  remove_negative_exponents = function() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    // find the smallest exponent\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n      push(caddr(p1));\n      k = pop_integer();\n      if (isNaN(k)) {\n        continue;\n      }\n      if (k < j) {\n        j = k;\n      }\n    }\n    moveTos(h);\n    if (j === 0) {\n      return;\n    }\n    // A = A / X^j\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    // B = B / X^j\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  // Returns the expansion coefficient matrix C.\n\n  // Example:\n\n  //       B         1\n  //      --- = -----------\n  //       A      2 \n  //             x (x + 1)\n\n  // We have\n\n  //       B     Y1     Y2      Y3\n  //      --- = ---- + ---- + -------\n  //       A      2     x      x + 1\n  //             x\n\n  // Our task is to solve for the unknowns Y1, Y2, and Y3.\n\n  // Multiplying both sides by A yields\n\n  //           AY1     AY2      AY3\n  //      B = ----- + ----- + -------\n  //            2      x       x + 1\n  //           x\n\n  // Let\n\n  //            A               A                 A\n  //      W1 = ----       W2 = ---        W3 = -------\n  //             2              x               x + 1\n  //            x\n\n  // Then the coefficient matrix C is\n\n  //              coeff(W1,x,0)   coeff(W2,x,0)   coeff(W3,x,0)\n\n  //       C =    coeff(W1,x,1)   coeff(W2,x,1)   coeff(W3,x,1)\n\n  //              coeff(W1,x,2)   coeff(W2,x,2)   coeff(W3,x,2)\n\n  // It follows that\n\n  //       coeff(B,x,0)     Y1\n\n  //       coeff(B,x,1) = C Y2\n\n  //       coeff(B,x,2) =   Y3\n\n  // Hence\n\n  //       Y1       coeff(B,x,0)\n  //             -1\n  //       Y2 = C   coeff(B,x,1)\n\n  //       Y3       coeff(B,x,2)\n  expand_get_C = function() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    //U **a\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n    n = tos - h;\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n    return moveTos(tos - n);\n  };\n\n  // The following table shows the push order for simple roots, repeated roots,\n  // and inrreducible factors.\n\n  //  Factor F        Push 1st        Push 2nd         Push 3rd      Push 4th\n\n  //                   A\n  //  x               ---\n  //                   x\n\n  //   2               A               A\n  //  x               ----            ---\n  //                    2              x\n  //                   x\n\n  //                     A\n  //  x + 1           -------\n  //                   x + 1\n\n  //         2            A              A\n  //  (x + 1)         ----------      -------\n  //                          2        x + 1\n  //                   (x + 1)\n\n  //   2                   A               Ax\n  //  x  + x + 1      ------------    ------------\n  //                    2               2\n  //                   x  + x + 1      x  + x + 1\n\n  //    2         2          A              Ax              A             Ax\n  //  (x  + x + 1)    --------------- ---------------  ------------  ------------\n  //                     2         2     2         2     2             2\n  //                   (x  + x + 1)    (x  + x + 1)     x  + x + 1    x  + x + 1\n\n  // For T = A/F and F = P^N we have\n\n  //      Factor F          Push 1st    Push 2nd    Push 3rd    Push 4th\n\n  //      x                 T\n\n  //       2\n  //      x                 T           TP\n\n  //      x + 1             T\n\n  //             2\n  //      (x + 1)           T           TP\n\n  //       2\n  //      x  + x + 1        T           TX\n\n  //        2         2\n  //      (x  + x + 1)      T           TX          TP          TPX\n\n  // Hence we want to push in the order\n\n  //      T * (P ^ i) * (X ^ j)\n\n  // for all i, j such that\n\n  //      i = 0, 1, ..., N - 1\n\n  //      j = 0, 1, ..., deg(P) - 1\n\n  // where index j runs first.\n  expand_get_CF = function() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Returns T = A/F where F is a factor of A.\n  trivial_divide = function() {\n    var h;\n    h = 0;\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval(); // force expansion of (x+1)^2, f.e.\n        }\n        p0 = cdr(p0);\n      }\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n    return p8 = pop();\n  };\n\n  // Returns the expansion coefficient vector B.\n  expand_get_B = function() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      return;\n    }\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n    return p3 = p8;\n  };\n\n  // Returns the expansion fractions in A.\n  expand_get_A = function() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = ref = n; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Do the exponential cosine function.\n  Eval_expcos = function() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  // Do the exponential sine function.\n  Eval_expsin = function() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  // factor a polynomial or integer\n  Eval_factor = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    factor();\n    // more factoring?\n    p1 = cdddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  factor_again = function() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n    n = tos - h;\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n    return restore();\n  };\n\n  factor_term = function() {\n    save();\n    factorpoly();\n    p1 = pop();\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  factor = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number(); // see pollard.cpp\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n    return restore();\n  };\n\n  // for factoring small integers (2^32 or less)\n  factor_small_number = function() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n    if (n < 0) {\n      n = -n;\n    }\n    for (i = o = 0, ref = MAXPRIMETAB; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n      if (d > n / d) {\n        break;\n      }\n      expo = 0;\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n    return restore();\n  };\n\n  factorial = function() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    bignum_factorial(n);\n    return restore();\n  };\n\n  // simplification rules for factorials (m < n)\n\n  //  (e + 1) * factorial(e)  ->  factorial(e + 1)\n\n  //  factorial(e) / e  ->  factorial(e - 1)\n\n  //  e / factorial(e)  ->  1 / factorial(e - 1)\n\n  //  factorial(e + n)\n  //  ----------------  ->  (e + m + 1)(e + m + 2)...(e + n)\n  //  factorial(e + m)\n\n  //  factorial(e + m)                               1\n  //  ----------------  ->  --------------------------------\n  //  factorial(e + n)    (e + m + 1)(e + m + 2)...(e + n)\n\n  // this function is not actually used, but\n  // all these simplifications\n  // do happen automatically via simplify\n  simplifyfactorials = function() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        simplifyfactorials();\n        add();\n        p1 = cdr(p1);\n      }\n      expanding = x;\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n    for (i = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      for (j = i1 = ref1 = i + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n        sfac_product_f(s, i, j);\n      }\n    }\n    push(one);\n    for (i = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      push(stack[s + i]);\n      multiply();\n    }\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n    if (isfactorial(p1) && isfactorial(p2)) {\n      // Determine if the powers cancel.\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n      if (n !== 0) {\n        return;\n      }\n      // Find the difference between the two factorial args.\n\n      // For example, the difference between (a + 2)! and a! is 2.\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n      push(one);\n      for (i = o = 1, ref = n; (1 <= ref ? o <= ref : o >= ref); i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  // Factor a polynomial\n  factorpoly = function() {\n    var polynomial, variable;\n    if (DEBUG) {\n      console.log(\"factorpoly: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    variable = pop();\n    polynomial = pop();\n    if (!Find(polynomial, variable) || !ispolyexpandedform(polynomial, variable) || !issymbol(variable)) {\n      push(polynomial);\n    } else {\n      yyfactorpoly(variable, polynomial);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    tos-2    true polynomial\n\n  //      tos-1    free variable\n\n  //  Output:    factored polynomial on stack\n\n  //-----------------------------------------------------------------------------\n  yyfactorpoly = function(variable, polynomial) {\n    var A, AxPlusB, B, checkingTheDivision, dividend, factpoly_expo, firstParam, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, partOfPolynomialFactoredSoFar, polycoeff, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, secondDegreePloly, secondParam, whichRootsAreWeFinding;\n    if (DEBUG) {\n      firstParam = variable;\n      secondParam = polynomial;\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam);\n    }\n    save();\n    h = tos;\n    if (isfloating(polynomial)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n    polycoeff = tos;\n    factpoly_expo = coeff(variable, polynomial) - 1;\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo before rationalize_coefficients: \" + factpoly_expo);\n    }\n    partOfPolynomialFactoredSoFar = rationalize_coefficients(h);\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo  after rationalize_coefficients: \" + factpoly_expo);\n    }\n    // for univariate polynomials we could do factpoly_expo > 1\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n    while (factpoly_expo > 0) {\n      if (DEBUG) {\n        console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo inside while loop: \" + factpoly_expo);\n      }\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        if (DEBUG) {\n          console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" isZeroAtomOrTensor\");\n        }\n        A = one;\n        B = zero;\n      } else {\n        //console.log(\"trying to find a \" + whichRootsAreWeFinding + \" root\")\n        if (whichRootsAreWeFinding === \"real\") {\n          [foundRealRoot, A, B] = get_factor_from_real_root(variable, factpoly_expo, polycoeff);\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          [foundComplexRoot, A] = get_factor_from_complex_root(remainingPoly, factpoly_expo, polycoeff);\n        }\n      }\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          // build the 1-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          multiply();\n          push(B); // B\n          add();\n          AxPlusB = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + AxPlusB);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(AxPlusB)\n            negate()\n            AxPlusB = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          push(AxPlusB);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          // ok now on stack we have the coefficients of the\n          // remaining part of the polynomial still to factor.\n          // Divide it by the newly-found factor so that\n          // the stack then contains the coefficients of the\n          // polynomial part still left to factor.\n          yydivpoly(factpoly_expo, polycoeff, A, B);\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n          push(zero);\n          for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(variable); // the free variable\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n          remainingPoly = pop();\n        }\n      //console.log(\"real branch remainingPoly: \" + remainingPoly)\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          // build the 2-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          subtract();\n          //console.log(\"first factor: \" + stack[tos-1].toString())\n          push(A); // A\n          conjugate();\n          push(variable); // x\n          subtract();\n          //console.log(\"second factor: \" + stack[tos-1].toString())\n          multiply();\n          //if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff+factpoly_expo]))\n          //  negate()\n          //  negate_noexpand()\n          secondDegreePloly = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + secondDegreePloly);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(secondDegreePloly)\n            negate()\n            secondDegreePloly = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          previousFactorisation = pop();\n          //console.log(\"previousFactorisation: \" + previousFactorisation)\n          push(partOfPolynomialFactoredSoFar);\n          push(secondDegreePloly);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          if (remainingPoly == null) {\n            push(zero);\n            for (i = i1 = 0, ref1 = factpoly_expo; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(variable); // the free variable\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n            remainingPoly = pop();\n          }\n          //console.log(\"original polynomial (dividend): \" + remainingPoly)\n          dividend = remainingPoly;\n          //push(dividend)\n          //degree()\n          //startingDegree = pop()\n          push(dividend);\n          //console.log(\"dividing \" + stack[tos-1].toString() + \" by \" + secondDegreePloly)\n          push(secondDegreePloly); // divisor\n          push(variable); // X\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(secondDegreePloly); // divisor\n          multiply();\n          checkingTheDivision = pop();\n          if (!equal(checkingTheDivision, dividend)) {\n            //push(dividend)\n            //gcd_sum()\n            //console.log(\"gcd top of stack: \" + stack[tos-1].toString())\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            partOfPolynomialFactoredSoFar = pop();\n            stack[h] = partOfPolynomialFactoredSoFar;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n//console.log(\"result: (still to be factored) \" + remainingPoly)\n\n          //push(remainingPoly)\n//degree()\n//remainingDegree = pop()\n/*\nif compare_numbers(startingDegree, remainingDegree)\n * ok even if we found a complex root that\n * together with the conjugate generates a poly in Z,\n * that doesn't mean that the division would end up in Z.\n * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n * so a factor is 1+x^2 ( = (x+i)*(x-i))\n * BUT \n */\n          for (i = j1 = 0, ref2 = factpoly_expo; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n          coeff(variable, remainingPoly);\n          factpoly_expo -= 2;\n        }\n      }\n    }\n    //console.log(\"factpoly_expo: \" + factpoly_expo)\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" building the remaining unfactored part of the polynomial\");\n    }\n    push(zero);\n    for (i = l1 = 0, ref3 = factpoly_expo; (0 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(variable); // the free variable\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" remaining unfactored part of the polynomial: \" + polynomial.toString());\n    }\n    push(polynomial);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" new poly with extracted common factor: \" + polynomial.toString());\n    }\n    //debugger\n\n    // factor out negative sign\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(polynomial);\n      //prev_expanding = expanding\n      //expanding = 1\n      negate();\n      //expanding = prev_expanding\n      polynomial = pop();\n      push(partOfPolynomialFactoredSoFar);\n      negate_noexpand();\n      partOfPolynomialFactoredSoFar = pop();\n    }\n    push(partOfPolynomialFactoredSoFar);\n    push(polynomial);\n    multiply_noexpand();\n    partOfPolynomialFactoredSoFar = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" result: \" + partOfPolynomialFactoredSoFar);\n    }\n    stack[h] = partOfPolynomialFactoredSoFar;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function(h) {\n    var i, i1, o, ratio, ratioInverse, ref, ref1, ref2, ref3;\n    // LCM of all polynomial coefficients\n    ratio = one;\n    for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n      denominator();\n      push(ratio);\n      lcm();\n      ratio = pop();\n    }\n// multiply each coefficient by RESULT\n    for (i = i1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(ratio);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n    // reciprocate RESULT\n    push(ratio);\n    reciprocate();\n    ratioInverse = pop();\n    if (DEBUG) {\n      console.log(\"rationalize_coefficients result: \" + ratioInverse.toString());\n    }\n    return ratioInverse;\n  };\n\n  get_factor_from_real_root = function(variable, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, j1, l1, m1, na0, nan, o, polynomial, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j, testDenominator, testNumerator, testValue;\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root\");\n    }\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (DEBUG) {\n      push(zero);\n      for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(variable);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n      polynomial = pop();\n      console.log(\"POLY=\" + polynomial);\n    }\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n      for (i = i1 = 0, ref1 = na0; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n      console.log(\"divisors of leading term\");\n      for (i = j1 = 0, ref2 = nan; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n// try roots\n    for (rootsTries_i = l1 = 0, ref3 = nan; (0 <= ref3 ? l1 < ref3 : l1 > ref3); rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; (0 <= ref4 ? m1 < ref4 : m1 > ref4); rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        //if DEBUG then console.log \"nan: \" + nan + \" na0: \" + na0 + \" i: \" + rootsTries_i + \" j: \" + rootsTries_j\n        testNumerator = stack[an + rootsTries_i];\n        testDenominator = stack[a0 + rootsTries_j];\n        push(testDenominator);\n        push(testNumerator);\n        divide();\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n        push(testDenominator);\n        negate();\n        testDenominator = pop();\n        push(testValue);\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning\");\n    }\n    return [0, null, null];\n  };\n\n  get_factor_from_complex_root = function(remainingPoly, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j, testValue;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n      return [0, null];\n    }\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + remainingPoly);\n    }\n    h = tos;\n    an = tos;\n    // trying -1^(2/3) which generates a polynomial in Z\n    // generates x^2 + 2x + 1\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n    // trying 1^(2/3) which generates a polynomial in Z\n    // http://www.wolframalpha.com/input/?i=(1)%5E(2%2F3)\n    // generates x^2 - 2x + 1\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n// trying some simple complex numbers. All of these\n// generate polynomials in Z\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n        rect();\n        testValue = pop();\n        if (DEBUG) {\n          console.log(\"complex root finding: trying simple complex combination \" + testValue);\n        }\n        push(testValue);\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        //console.log(\"complex root finding result: \" + evalPolyResult)\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"found complex root: \" + evalPolyResult);\n          }\n          return [1, testValue];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n    return [0, null];\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide a polynomial by Ax+B\n\n  //  Input:  on stack:  polycoeff  Dividend coefficients\n\n  //      factpoly_expo   as parameter\n\n  //      A    as parameter\n\n  //      B    as parameter\n\n  //  Output:   on stack: polycoeff  Contains quotient coefficients\n\n  //-----------------------------------------------------------------------------\n  yydivpoly = function(factpoly_expo, polycoeff, A, B) {\n    var Q, i, o, ref;\n    Q = zero;\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = Q;\n      push(A);\n      divide();\n      Q = pop();\n      push(stack[polycoeff + i - 1]);\n      push(Q);\n      push(B);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n    stack[polycoeff + 0] = Q;\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q: \" + Q.toString());\n    }\n  };\n\n  Evalpoly = function(factpoly_expo, polycoeff, evaluateAt) {\n    var i, o, ref;\n    push(zero);\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o <= 0 : o >= 0); i = ref <= 0 ? ++o : --o) {\n      push(evaluateAt);\n      multiply();\n      push(stack[polycoeff + i]);\n      //if DEBUG\n      //  console.log(\"Evalpoly top of stack:\")\n      //  console.log stack[tos-i].toString()\n      add();\n    }\n    return pop();\n  };\n\n  // Push expression factors onto the stack. For example...\n\n  // Input\n\n  //       2\n  //     3x  + 2x + 1\n\n  // Output on stack\n\n  //     [  3  ]\n  //     [ x^2 ]\n  //     [  2  ]\n  //     [  x  ]\n  //     [  1  ]\n\n  // but not necessarily in that order. Returns the number of factors.\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  factors = function(p) {\n    var h;\n    h = tos;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n    return tos - h;\n  };\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  push_term_factors = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n\n  Eval_filter = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter_tensor = function() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n    return push(p3);\n  };\n\n  Eval_float = function() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function() {\n    save();\n    evaluatingAsFloats++;\n    //p1 = pop()\n    //push(cadr(p1))\n    //push(p1)\n    Eval();\n    yyfloat();\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  // zzfloat doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, this line comes handy to highlight\n  // when that doesn't happen for those tests.\n  //checkFloatHasWorkedOutCompletely(stack[tos-1])\n  yyfloat = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        yyfloat();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        yyfloat();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n\n  // 'for' function\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n\n  X: k\n  B: 1...9\n\n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n\n  */\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n  Eval_for = function() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(loopingVariable);\n    for (i = o = ref = j, ref1 = k; (ref <= ref1 ? o <= ref1 : o >= ref1); i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n    // put back the index variable to original content\n    set_binding(loopingVariable, p4);\n    // return value\n    return push_symbol(NIL);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Gamma function gamma(x)\n\n  //-----------------------------------------------------------------------------\n  Eval_gamma = function() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function() {\n    //  double d\n    p1 = pop();\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      return;\n    }\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n    \n    //  if (p1->k == DOUBLE) {\n    //    d = exp(lgamma(p1.d))\n    //    push_double(d)\n    //    return\n    //  }\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_integer(-1);\n      multiply();\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function() {\n    p3 = cdr(p1);\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  // Greatest common denominator\n  // can also be run on polynomials, however\n  // it works only on the integers and it works\n  // by factoring the polynomials (not Euclidean algorithm)\n  Eval_gcd = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  gcd = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"gcd_main: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n    if ((polyVar = areunivarpolysfactoredorexpandedform(p1, p2))) {\n      gcd_polys(polyVar);\n      return;\n    }\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function(p1, p2) {\n    var polyVar;\n    if (DEBUG) {\n      console.log(\"areunivarpolysfactoredorexpandedform: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n    return false;\n  };\n\n  gcd_polys = function(polyVar) {\n    if (DEBUG) {\n      console.log(\"gcd_polys: p1: \" + p1 + \" polyVar: \" + polyVar);\n    }\n    // gcd of factors\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n    if (DEBUG) {\n      console.log(\"GCD: factored polys:\");\n    }\n    if (DEBUG) {\n      console.log(\"  p1:\" + p1.toString());\n    }\n    if (DEBUG) {\n      console.log(\"  p2:\" + p2.toString());\n    }\n    // In case one of two polynomials can be factored,\n    // (and only in that case), then\n    // we'll need to run gcd_factors on the two polynomials.\n    // (In case neither of them can be factored there is no gcd).\n    // However, gcd_factors expects two _products_ , and\n    // in case _one_ of the polynomials can't be factored it will look\n    // like a sum instead of a product.\n    // So, we'll have to make that sum to look like a factor:\n    // let's just turn it into a product with 1.\n\n    // in case one of the two polys has been factored...\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      // then make sure that if one of them is a single\n      // factor, we take the sum and wrap it into a\n      // multiplication by 1\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_powers_with_same_base = function() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1); // exponent\n      p1 = cadr(p1); // base\n    } else {\n      p3 = one;\n    }\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2); // exponent\n      p2 = cadr(p2); // base\n    } else {\n      p4 = one;\n    }\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    // are both exponents numerical?\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    // are the exponents multiples of eah other?\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n    if (isNumericAtom(p5)) {\n      push(p1);\n      // choose the smallest exponent\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n    // can't be equal because of test near beginning\n    push(p1);\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n    return power();\n  };\n\n  // in this case gcd is used as a composite function, i.e. gcd(gcd(gcd...\n  gcd_sum_sum = function() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  gcd_sum_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_product_sum = function() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n    return results;\n  };\n\n  // Guess which symbol to use for derivative, integral, etc.\n  guess = function() {\n    var p;\n    p = pop();\n    push(p);\n    if (Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Hermite polynomial\n\n  //  Input:    tos-2    x  (can be a symbol or expr)\n\n  //      tos-1    n\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  hermite = function() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  // uses the recurrence relation H(x,n+1)=2*x*H(x,n)-2*n*H(x,n-1)\n\n  //define X p1\n  //define N p2\n  //define Y p3\n  //define Y1 p4\n  //define Y0 p5\n  yyhermite = function() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n    return results;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Create a Hilbert matrix\n\n  //  Input:    Dimension on stack\n\n  //  Output:    Hilbert matrix on stack\n\n  //  Example:\n\n  //  > hilbert(5)\n  //  ((1,1/2,1/3,1/4),(1/2,1/3,1/4,1/5),(1/3,1/4,1/5,1/6),(1/4,1/5,1/6,1/7))\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define N p2\n\n  //define AELEM(i, j) A->u.tensor->elem[i * n + j]\n  hilbert = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n    push_zero_matrix(n, n);\n    p1 = pop();\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n    push(p1);\n    return restore();\n  };\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function() {\n    save();\n    rect();\n    p1 = pop();\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n    subtract();\n    push_integer(2);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n    push(imaginaryunit);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // n is the total number of things on the stack. The first thing on the stack\n  // is the object to be indexed, followed by the indices themselves.\n\n  // called by Eval_index\n  index_function = function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    nelem = 1;\n    for (i = j1 = ref3 = m, ref4 = ndim; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n    for (i = l1 = ref5 = m, ref6 = ndim; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref7 = nelem; (0 <= ref7 ? m1 < ref7 : m1 > ref7); i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n    Number of args on stack\n\n  //      tos-n    Right-hand value\n\n  //      tos-n+1    Left-hand value\n\n  //      tos-n+2    First index\n\n  //      .\n  //      .\n  //      .\n\n  //      tos-1    Last index\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define LVALUE p1\n  //define RVALUE p2\n  //define TMP p3\n  set_component = function(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n    if (!istensor(p1)) { // p1 is LVALUE\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    // copy\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; (0 <= ref4 ? l1 < ref4 : l1 > ref4); i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n    if (ndim === m) {\n      if (istensor(p2)) { // p2 is RVALUE\n        stop(\"error in indexed assign\");\n      }\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n    if (!istensor(p2)) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n    if (ndim - m !== p2.tensor.ndim) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n// p2 is RVALUE\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n// p2 is RVALUE\n// copy rvalue\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? n1 < ref6 : n1 > ref6); i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n\n  Eval_inner = function() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    \n    // if there are more than two arguments then\n    // reduce it to a more standard version\n    // of two arguments, which means we need to\n    // transform the arguments into a tree of\n    // inner products e.g.\n    // inner(a,b,c) becomes inner(a,inner(b,c))\n    // this is so we can get to a standard binary-tree\n    // version that is simpler to manipulate.\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    moretheArguments = cdr(cdr(p1));\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n    // make it so e.g. inner(a,b,c) becomes inner(a,inner(b,c))\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n      for (i = o = 2, ref = theArguments.length; (2 <= ref ? o < ref : o > ref); i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n      p1 = pop();\n      Eval_inner();\n      return;\n    }\n    // TODO we have to take a look at the whole\n    // sequence of operands and make simplifications\n    // on that...\n    operands = [];\n    get_innerprod_factors(p1, operands);\n    //console.log \"printing operands --------\"\n    //for i in [0...operands.length]\n    //  console.log \"operand \" + i + \" : \" + operands[i]\n    refinedOperands = [];\n// removing all identity matrices\n    for (i = i1 = 0, ref1 = operands.length; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n    operands = refinedOperands;\n    refinedOperands = [];\n    if (operands.length > 1) {\n      // removing all consecutive pairs of inverses\n      // so we can answer that inv(a)a results in the\n      // identity matrix. We want to catch symbolic inverses\n      // not numeric inverses, those will just take care\n      // of themselves when multiplied\n      shift = 0;\n      for (i = j1 = 0, ref2 = operands.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        //console.log \"comparing if \" + operands[i+shift] + \" and \" + operands[i+shift+1] + \" are inverses of each other\"\n        if ((i + shift + 1) <= (operands.length - 1)) {\n          if (!(isNumericAtomOrTensor(operands[i + shift]) || isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n            inv();\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n            //console.log \"result: \" + difference\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n        //console.log \"i: \" + i + \" shift: \" + shift + \" operands.length: \" + operands.length\n        if (i + shift === operands.length - 2) {\n          //console.log \"adding last operand 2 \"\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n      operands = refinedOperands;\n    }\n    //console.log \"refined operands --------\"\n    //for i in [0...refinedOperands.length]\n    //  console.log \"refined operand \" + i + \" : \" + refinedOperands[i]\n\n    //console.log \"stack[tos-1]: \" + stack[tos-1]\n\n    // now rebuild the arguments, just using the\n    // refined operands\n    push(symbol(INNER));\n    //console.log \"rebuilding the argument ----\"\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        //console.log \"pushing \" + operands[i]\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n    //console.log \"list(operands.length): \" + (operands.length+1)\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      inner();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // inner definition\n  inner = function() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // more in general, when a and b are scalars,\n    // inner(a*M1, b*M2) is equal to\n    // a*b*inner(M1,M2), but of course we can only\n    // \"bring out\" in a and b the scalars, because\n    // it's the only commutative part.\n    // that's going to be trickier to do in general\n    // but let's start with just the signs.\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // since inner is associative,\n    // put it in a canonical form i.e.\n    // inner(inner(a,b),c) ->\n    // inner(a,inner(b,c))\n    // so that we can recognise when they\n    // are equal.\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1)); //a\n      arg2 = car(cdr(cdr(p1))); //b\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n      inner();\n      p2 = pop();\n    }\n    // Check if one of the operands is the identity matrix\n    // we could maybe use Eval_testeq here but\n    // this seems to suffice?\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(isNumericAtomOrTensor(p1) || isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n        inv();\n        subtract();\n        subtractionResult = pop();\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n      // if either operand is a sum then distribute\n      // (if we are in expanding mode)\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n          inner();\n          add();\n          p1 = cdr(p1);\n        }\n        restore();\n        return;\n      }\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n          inner();\n          add();\n          p2 = cdr(p2);\n        }\n        restore();\n        return;\n      }\n      push(p1);\n      push(p2);\n      // there are 8 remaining cases here, since each of the\n      // two arguments can only be a scalar/tensor/unknown\n      // and the tensor - tensor case was caught\n      // upper in the code\n      if (istensor(p1) && isNumericAtom(p2)) {\n        // one case covered by this branch:\n        //   tensor - scalar\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        // one case covered by this branch:\n        //   scalar - tensor\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          // three cases covered by this branch:\n          //   unknown - scalar\n          //   scalar - unknown\n          //   scalar  - scalar\n          // in these cases a normal multiplication\n          // will be OK\n          multiply();\n        } else {\n          // three cases covered by this branch:\n          //   unknown - unknown\n          //   unknown - tensor\n          //   tensor  - unknown\n          // in this case we can't use normal\n          // multiplication.\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n    return restore();\n  };\n\n  // inner product of tensors p1 and p2\n  inner_f = function() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    //---------------------------------------------------------------------\n\n    //  ak is the number of rows in tensor A\n\n    //  bk is the number of columns in tensor B\n\n    //  Example:\n\n    //  A[3][3][4] B[4][4][3]\n\n    //    3  3        ak = 3 * 3 = 9\n\n    //                  4  3    bk = 4 * 3 = 12\n\n    //---------------------------------------------------------------------\n    ak = 1;\n    for (i = o = 0, ref = p1.tensor.ndim - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n    bk = 1;\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; (1 <= ref1 ? i1 < ref1 : i1 > ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n// new method copied from ginac http://www.ginac.de/\n    for (i = j1 = 0, ref2 = ak; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n        for (k = m1 = 0, ref4 = bk; (0 <= ref4 ? m1 < ref4 : m1 > ref4); k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n    //---------------------------------------------------------------------\n\n    //  Note on understanding \"k * bk + j\"\n\n    //  k * bk because each element of a column is bk locations apart\n\n    //  + j because the beginnings of all columns are in the first bk \n    //  locations\n\n    //  Example: n = 2, bk = 6\n\n    //  b111  <- 1st element of 1st column\n    //  b112  <- 1st element of 2nd column\n    //  b113  <- 1st element of 3rd column\n    //  b121  <- 1st element of 4th column\n    //  b122  <- 1st element of 5th column\n    //  b123  <- 1st element of 6th column\n\n    //  b211  <- 2nd element of 1st column\n    //  b212  <- 2nd element of 2nd column\n    //  b213  <- 2nd element of 3rd column\n    //  b221  <- 2nd element of 4th column\n    //  b222  <- 2nd element of 5th column\n    //  b223  <- 2nd element of 6th column\n\n    //---------------------------------------------------------------------\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; (0 <= ref5 ? n1 < ref5 : n1 > ref5); i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      j = p1.tensor.ndim - 1;\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; (0 <= ref6 ? o1 < ref6 : o1 > ref6); i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n      return push(p3);\n    }\n  };\n\n  // Algebrite.run('c(b+a)inv((a+b))d').toString();\n  // Algebrite.run('c*(b+a)inv((a+b))d').toString();\n  // Algebrite.run('(c(b+a))(inv((a+b))d)').toString();\n  get_innerprod_factors = function(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n    if (cdr(tree) === symbol(NIL)) {\n      tree = get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n    if (isinnerordot(tree)) {\n      // console.log \"there is inner at top, recursing on the operands\"\n      get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n      get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n      return;\n    }\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      // console.log \">> adding to factors_accumulator: \" + tree\n      return factors_accumulator.push(tree);\n    }\n  };\n\n  itab = [\n    // 1\n    \"f(a,a*x)\",\n    // 9 (need a caveat for 7 so we can put 9 after 7)\n    \"f(1/x,log(x))\",\n    // 7\n    \"f(x^a,x^(a+1)/(a+1))\",\n    // five specialisations of case 7 for speed.\n    // Covers often-occurring exponents: each of\n    // these case ends up in a dedicated entry, so we\n    // only have to do one sure-shot match.\n    \"f(x^(-2),-x^(-1))\",\n    \"f(x^(-1/2),2*x^(1/2))\",\n    \"f(x^(1/2),2/3*x^(3/2))\",\n    \"f(x,x^2/2)\",\n    \"f(x^2,x^3/3)\",\n    // 12\n    \"f(exp(a*x),1/a*exp(a*x))\",\n    \"f(exp(a*x+b),1/a*exp(a*x+b))\",\n    \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\",\n    \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\",\n    // 14\n    \"f(log(a*x),x*log(a*x)-x)\",\n    // 15\n    \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\",\n    // 16\n    \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\",\n    // 17\n    \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\",\n    // 19\n    \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\",\n    // 20\n    \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\",\n    // 27\n    \"f(1/(a+b*x),1/b*log(a+b*x))\",\n    // 28\n    \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\",\n    // 29\n    \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\",\n    // 30\n    \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\",\n    // 31\n    \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\",\n    // 33\n    \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\",\n    // 34\n    \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\",\n    // 35\n    \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\",\n    // 37\n    \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\",\n    // 38\n    \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\",\n    // 39\n    \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\",\n    // 40\n    \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\",\n    // 41\n    \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\",\n    // 42\n    \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\",\n    // 60\n    \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\",\n    // 61\n    \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\",\n    // 62 is the same as 60\n    // 63\n    \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\",\n    //64\n    \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\",\n    //65\n    \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\",\n    //66 is covered by 61\n    //70\n    \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\",\n    //71\n    \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\",\n    //74\n    \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\",\n    //76\n    \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\",\n    // float(defint(1/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //77\n    //\"f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //78\n    //\"f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //79\n    \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\",\n    //80\n    \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\",\n    // float(defint(X^2/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //81\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //82\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //83\n    \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\",\n    //124\n    \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\",\n    //125\n    \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\",\n    //126\n    \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\",\n    //128\n    \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //129\n    \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\",\n    //131\n    \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\",\n    //132\n    \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\",\n    //133\n    \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\",\n    //135\n    \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\",\n    //136\n    \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\",\n    //137\n    \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //156\n    \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\",\n    //157\n    \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\",\n    //158\n    \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\",\n    //159\n    \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //160\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //161\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\",\n    //162\n    \"f(x/sqrt(x^2+a),sqrt(x^2+a))\",\n    //163\n    \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\",\n    //164 need an unexpanded version?\n    \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\",\n    // match doesn't work for the following\n    \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\",\n    //165\n    \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\",\n    //166\n    \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\",\n    //167\n    \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\",\n    //168\n    \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\",\n    //169\n    \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\",\n    //170\n    \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\",\n    //171\n    \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\",\n    //172\n    \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\",\n    //173\n    \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\",\n    //174\n    \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\",\n    //175\n    \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\",\n    //176+\n    \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\",\n    //176-\n    \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\",\n    //177+\n    \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\",\n    //177-\n    \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\",\n    //196\n    \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\",\n    //197\n    \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\",\n    //200+\n    \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\",\n    //201    (seems to be handled somewhere else)\n    //202\n    \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //203\n    \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //204\n    \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\",\n    //205\n    \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\",\n    //210\n    \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\",\n    //211\n    \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\",\n    //214\n    \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //215\n    \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\",\n    //216\n    \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //217\n    \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\",\n    //218\n    \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\",\n    // 273\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\",\n    // 274\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\",\n    // 290\n    \"f(sin(a*x),-cos(a*x)/a)\",\n    // 291\n    \"f(cos(a*x),sin(a*x)/a)\",\n    // 292\n    \"f(tan(a*x),-log(cos(a*x))/a)\",\n    // 293\n    \"f(1/tan(a*x),log(sin(a*x))/a)\",\n    // 294\n    \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\",\n    // 295\n    \"f(1/sin(a*x),log(tan(a*x/2))/a)\",\n    // 296\n    \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\",\n    // 297\n    \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\",\n    // 298\n    \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 302\n    \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\",\n    // 303\n    \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\",\n    // 304\n    \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 308\n    \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\",\n    // 312\n    \"f(1/cos(a*x)^2,tan(a*x)/a)\",\n    // 318\n    \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\",\n    // 320\n    \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\",\n    // 326\n    \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\",\n    // 327\n    \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\",\n    // 328\n    \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\",\n    // 329\n    \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\",\n    // 330\n    \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\",\n    // 331\n    \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\",\n    // 333\n    \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\",\n    // 335\n    \"f(sin(a+b*x),-cos(a+b*x)/b)\",\n    // 336\n    \"f(cos(a+b*x),sin(a+b*x)/b)\",\n    // 337+ (with the addition of b)\n    \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\",\n    // 337- (with the addition of b)\n    \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\",\n    // 338 (with the addition of b)\n    \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\",\n    // 339 (with the addition of b)\n    \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\",\n    // 340\n    \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 341\n    \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 389\n    \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\",\n    // 390\n    \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\",\n    // 393\n    \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\",\n    // 394\n    \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\",\n    // 441\n    \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\",\n    // 442\n    \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\",\n    // 443\n    \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\",\n    // 485 (with addition of a)\n    // however commenting out since it's a duplicate of 14\n    // \"f(log(a*x),x*log(a*x)-x)\",\n    // 486 (with addition of a)\n    \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\",\n    // 487 (with addition of a)\n    \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\",\n    // 489\n    \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\",\n    // 493 (with addition of a)\n    \"f(1/x*1/(a+log(x)),log(a+log(x)))\",\n    // 499\n    \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\",\n    // 500\n    \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\",\n    // 554\n    \"f(sinh(x),cosh(x))\",\n    // 555\n    \"f(cosh(x),sinh(x))\",\n    // 556\n    \"f(tanh(x),log(cosh(x)))\",\n    // 560\n    \"f(x*sinh(x),x*cosh(x)-sinh(x))\",\n    // 562\n    \"f(x*cosh(x),x*sinh(x)-cosh(x))\",\n    // 566\n    \"f(sinh(x)^2,sinh(2*x)/4-x/2)\",\n    // 569\n    \"f(tanh(x)^2,x-tanh(x))\",\n    // 572\n    \"f(cosh(x)^2,sinh(2*x)/4+x/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\",\n    // ?\n    \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\",\n    // these are needed for the surface integral in the manual\n    \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\",\n    \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\",\n    \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\",\n    \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\",\n    \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\",\n    \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\",\n    \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\",\n    0\n  ];\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_integral = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    // evaluate 1st arg to get function F\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example    result of 2nd arg  what to do\n\n    // integral(f)    nil      guess X, N = nil\n    // integral(f,2)  2      guess X, N = 2\n    // integral(f,x)  x      X = x, N = nil\n    // integral(f,x,2)  x      X = x, N = 2\n    // integral(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // N might be a symbol instead of a number\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n      p3 = pop();\n      // if N is nil then arglist is exhausted\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) {\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) {\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // N = arg1\n      }\n    }\n    return push(p3); // final result\n  };\n\n  integral = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n    p1 = pop();\n    if (Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  integral_of_product = function() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply(); // multiply constant part\n  };\n\n  integral_of_form = function() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n    if (!tab) {\n      // debugger\n      // italu_hashcode(p1, p2)\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p1); // free variable\n    push(p2); // input expression\n    transform(tab, false);\n    p3 = pop();\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  // Implementation of hash codes based on ITALU (An Integral Table Look-Up)\n  // https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680004891.pdf\n  // see Appendix A, page 153\n\n  // The first two values are from the ITALU paper.\n  // The others are just arbitrary constants.\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function(u, x) {\n    var half;\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n        default:\n          return hash_function(u, x);\n      }\n    }\n    return hashcode_values.constant;\n  };\n\n  hash_function = function(u, x) {\n    var arg_hash, base, name;\n    if (!Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n      if (Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        // The original algorithm would skip this,\n        // but recording that it was present helps\n        // prevent collisions.\n        term_hash = hashcode_values.constant;\n      }\n      term_set[term_hash.toFixed(6)] = true;\n    }\n    sum = 0;\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n    return sum;\n  };\n\n  hash_multiplication = function(terms, x) {\n    var product, term;\n    product = 1;\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      if (Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n    return product;\n  };\n\n  hash_power = function(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n    if (Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n    if (Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      // constant to constant = constant\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n      if (!s) {\n        break;\n      }\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n      tab[key].push(s);\n    }\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n\n  // pre-calculated hashed integral table.\n  // in case the integral table is changed, use this\n  //   Algebrite.make_hashed_itab()\n  // and copy the resulting JSON in here.\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack (must have two dimensions but\n  //        it can be non-numerical)\n\n  //  Output:    Inverse on stack\n\n  //  Example:\n\n  //  > inv(((1,2),(3,4))\n  //  ((-2,1),(3/2,-1/2))\n\n  //  > inv(((a,b),(c,d))\n  //  ((d / (a d - b c),-b / (a d - b c)),(-c / (a d - b c),a / (a d - b c)))\n\n  //  Note:\n\n  //  THIS IS DIFFERENT FROM INVERSE OF AN EXPRESSION (inv)\n  //   Uses Gaussian elimination for numerical matrices.\n\n  //-----------------------------------------------------------------------------\n  INV_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  inv = function() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    // an inv just goes away when\n    // applied to another inv\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n    // inverse goes away in case\n    // of identity matrix\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // distribute the inverse of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n      for (eachEntry = o = ref = accumulator.length - 1; (ref <= 0 ? o <= 0 : o >= 0); eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n        inv();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    if (isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n      push(p2);\n      divide();\n    }\n    return restore();\n  };\n\n  invg = function() {\n    save();\n    p1 = pop();\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yyinvg();\n    return restore();\n  };\n\n  // inverse using gaussian elimination\n  yyinvg = function() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = n * n; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = l1 = 0, ref3 = n * n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n unit matrix on stack\n\n  //      n * n operand on stack\n\n  //  Output:    n * n inverse matrix on stack\n\n  //      n * n garbage on stack\n\n  //      p2 mangled\n\n  //-----------------------------------------------------------------------------\n\n  //define A(i, j) stack[a + n * (i) + (j)]\n  //define U(i, j) stack[u + n * (i) + (j)]\n  INV_decomp = function(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n    for (d = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(stack[a + n * d + d], zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n// exchange rows\n        for (j = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n      // multiply the pivot row by 1 / pivot\n      p2 = stack[a + n * d + d];\n      for (j = l1 = 0, ref4 = n; (0 <= ref4 ? l1 < ref4 : l1 > ref4); j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n      results.push((function() {\n        var m1, ref5, results1;\n// clear out the column above and below the pivot\n        results1 = [];\n        for (i = m1 = 0, ref5 = n; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n          // multiplier\n          p2 = stack[a + n * i + d];\n          results1.push((function() {\n            var n1, ref6, results2;\n// add pivot row to i-th row\n            results2 = [];\n            for (j = n1 = 0, ref6 = n; (0 <= ref6 ? n1 < ref6 : n1 > ref6); j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n            return results2;\n          })());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  // jsBoolToToInt = (p) ->\n  //   if p then 1 else 0\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtom = function(p) {\n    switch (p.k) {\n      case NUM:\n        return MZERO(p.q.a);\n      case DOUBLE:\n        return p.d === 0.0;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroTensor = function(p) {\n    var i, o, ref;\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n    for (i = o = 0, ref = p.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtomOrTensor = function(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  // This is a key routine to try to determine whether\n  // the argument looks like zero/false, or non-zero/true,\n  // or undetermined.\n  // This is useful in two instances:\n  //  * to determine if a predicate is true/false\n  //  * to determine if particular quantity is zero\n  // Note that if one wants to check if we have a simple\n  // zero atom or tensor in our hands, then the isZeroAtomOrTensor\n  // routine is sufficient.\n  isZeroLikeOrNonZeroLikeOrUndetermined = function(valueOrPredicate) {\n    var evalledArgument;\n    // push the argument\n    push(valueOrPredicate);\n    // just like Eval but turns assignments into\n    // equality checks\n    Eval_predicate();\n    evalledArgument = pop();\n    // OK first check if we already have\n    // a simple zero (or simple zero tensor)\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    // also check if we have a simple numeric value, or a tensor\n    // full of simple numeric values (i.e. straight doubles or fractions).\n    // In such cases, since we\n    // just excluded they are zero, then we take it as\n    // a \"true\"\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // if we are here we are in the case of value that\n    // is not a zero and not a simple numeric value.\n    // e.g. stuff like\n    // 'sqrt(2)', or 'sin(45)' or '1+i', or 'a'\n    // so in such cases let's try to do a float()\n    // so we might get down to a simple numeric value\n    // in some of those cases\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n    // anything that could be calculated down to a simple\n    // numeric value is now indeed either a \n    // double OR a double with an imaginary component\n    // e.g. 2.0 or 2.4 + i*5.6\n    // (Everything else are things that don't have a numeric\n    // value e.g. 'a+b')\n\n    // So, let's take care of the case where we have\n    // a simple numeric value with NO imaginary component,\n    // things like sqrt(2) or sin(PI)\n    // by doing the simple numeric\n    // values checks again\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // here we still have cases of simple numeric values\n    // WITH an imaginary component e.g. '1+i',\n    // or things that don't have a numeric value e.g. 'a'\n\n    // so now let's take care of the imaginary numbers:\n    // since we JUST have to spot \"zeros\" we can just\n    // calculate the absolute value and re-do all the checks\n    // we just did\n    if (Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n      // re-do the simple-number checks...\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n      if (isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n    // here we have stuff that is not reconducible to any\n    // numeric value (or tensor with numeric values) e.g.\n    // 'a+b', so it just means that we just don't know the\n    // truth value, so we have\n    // to leave the whole thing unevalled\n    return null;\n  };\n\n  // p is a U\n  isnegativenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  ispositivenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplustwo = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isminusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isone = function(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n      return 0;\n    }\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  isunivarpolyfactoredorexpandedform = function(p, x) {\n    if (DEBUG) {\n      console.log(\"isunivarpolyfactoredorexpandedform: p: \" + p + \" x: \" + x);\n    }\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n    if (ispolyfactoredorexpandedform(p, x) && (Find(p, symbol(SYMBOL_X)) + Find(p, symbol(SYMBOL_Y)) + Find(p, symbol(SYMBOL_Z)) === 1)) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  // sometimes we want to check if we have a poly in our\n  // hands, however it's in factored form and we don't\n  // want to expand it.\n  ispolyfactoredorexpandedform = function(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  // --------------------------------------\n  ispolyexpandedform = function(p, x) {\n    if (Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    if (Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  // --------------------------------------\n  isnegativeterm = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p))) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function(p) {\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p))) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iseveninteger = function(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // returns 1 if there's a symbol somewhere.\n  // not used anywhere.\n  // NOTE: PI and POWER are symbols,\n  // so for example 2^3 would be symbolic\n  // while -1^(1/2) i.e. 'i' is not, so this can\n  // be tricky to use.\n  issymbolic = function(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (issymbolic(car(p))) {\n          return 1;\n        }\n        p = cdr(p);\n      }\n      return 0;\n    }\n  };\n\n  // i.e. 2, 2^3, etc.\n  isintegerfactor = function(p) {\n    return isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p));\n  };\n\n  isNumberOneOverSomething = function(p) {\n    return isfraction(p) && MEQUAL(p.q.a.abs(), 1);\n  };\n\n  isoneover = function(p) {\n    return car(p) === symbol(POWER) && isminusone(caddr(p));\n  };\n\n  isfraction = function(p) {\n    return p.k === NUM && !MEQUAL(p.q.b, 1);\n  };\n\n  // p is a U, n an int\n  equaln = function(p, n) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1);\n      case DOUBLE:\n        return p.d === n;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U, a and b ints\n  equalq = function(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b);\n      case DOUBLE:\n        return p.d === a / b;\n      default:\n        return false;\n    }\n  };\n\n  // 1/2 ?\n  isoneovertwo = function(p) {\n    return equalq(p, 1, 2);\n  };\n\n  // -1/2 ?\n  isminusoneovertwo = function(p) {\n    return equalq(p, -1, 2);\n  };\n\n  // 1/sqrt(2) ?\n  isoneoversqrttwo = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2);\n  };\n\n  // -1/sqrt(2) ?\n  isminusoneoversqrttwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3;\n  };\n\n  // sqrt(3)/2 ?\n  issqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // -sqrt(3)/2 ?\n  isminussqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isminusoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // p == sqrt(3) ?\n  issqrtthree = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 3) && isoneovertwo(caddr(p));\n  };\n\n  isfloating = function(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isfloating(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  isimaginaryunit = function(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // n/2 * i * pi ?\n\n  // return value:\n\n  //  0  no\n\n  //  1  1\n\n  //  2  -1\n\n  //  3  i\n\n  //  4  -i\n  isquarterturn = function(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n      if (length(p) !== 3) {\n        return 0;\n      }\n      return 2;\n    }\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n    if (length(p) !== 4) {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n        break;\n      case 2:\n        n = 2;\n        break;\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n    }\n    return n;\n  };\n\n  // special multiple of pi?\n\n  // returns for the following multiples of pi...\n\n  //  -4/2  -3/2  -2/2  -1/2  1/2  2/2  3/2  4/2\n\n  //  4  1  2  3  1  2  3  4\n  isnpi = function(p) {\n    var doNothing, n;\n    n = 0;\n    if (p === symbol(PI)) {\n      return 2;\n    }\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 0) {\n      n = 4 - (-n) % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n\n  $.isnegativenumber = isnegativenumber;\n\n  $.isplusone = isplusone;\n\n  $.isminusone = isminusone;\n\n  $.isinteger = isinteger;\n\n  $.isnonnegativeinteger = isnonnegativeinteger;\n\n  $.isposint = isposint;\n\n  $.isnegativeterm = isnegativeterm;\n\n  $.isimaginarynumber = isimaginarynumber;\n\n  $.iscomplexnumber = iscomplexnumber;\n\n  $.iseveninteger = iseveninteger;\n\n  $.isnegative = isnegative;\n\n  $.issymbolic = issymbolic;\n\n  $.isintegerfactor = isintegerfactor;\n\n  $.isoneover = isoneover;\n\n  $.isfraction = isfraction;\n\n  $.isoneoversqrttwo = isoneoversqrttwo;\n\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n\n  $.isfloating = isfloating;\n\n  $.isimaginaryunit = isimaginaryunit;\n\n  $.isquarterturn = isquarterturn;\n\n  $.isnpi = isnpi;\n\n  Eval_isprime = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_laguerre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return laguerre();\n  };\n\n  //define X p1\n  //define N p2\n  //define K p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  laguerre = function() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return restore();\n  };\n\n  laguerre2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n    return results;\n  };\n\n  // Find the least common multiple of two expressions.\n  Eval_lcm = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  lcm = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n\n  Eval_leading = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return leading();\n  };\n\n  //define P p1\n  //define X p2\n  //define N p3\n  leading = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1); // N = degree of P\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1); // divide through by X ^ N\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2); // remove terms that depend on X\n    filter();\n    return restore();\n  };\n\n  Eval_legendre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg (optional)\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return legendre();\n  };\n\n  //define X p1\n  //define N p2\n  //define M p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  legendre = function() {\n    save();\n    __legendre();\n    return restore();\n  };\n\n  __legendre = function() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      __legendre2(n, m);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return __legendre3(m);\n  };\n\n  __legendre2 = function(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n//  i=1  p5 = 0 \n//    p6 = 1 \n//    ((2*i+1)*x*p6 - i*p5) / i = x\n\n//  i=2  p5 = 1\n//    p6 = x\n//    ((2*i+1)*x*p6 - i*p5) / i = -1/2 + 3/2*x^2\n\n//  i=3  p5 = x\n//    p6 = -1/2 + 3/2*x^2\n//    ((2*i+1)*x*p6 - i*p5) / i = -3/2*x + 5/2*x^3\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n    results = [];\n    for (i = i1 = 0, ref1 = m; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n    return results;\n  };\n\n  // moveTos tos * (-1)^m * (1-x^2)^(m/2)\n  __legendre3 = function(m) {\n    if (m === 0) {\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  // Create a list from n things on the stack.\n\n  // n is an integer\n  list = function(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n    for (listIterator = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n    return results;\n  };\n\n  // Natural logarithm.\n\n  // Note that we use the mathematics / Javascript / Mathematica\n  // convention that \"log\" is indeed the natural logarithm.\n\n  // In engineering, biology, astronomy, \"log\" can stand instead\n  // for the \"common\" logarithm i.e. base 10. Also note that Google\n  // calculations use log for the common logarithm.\n  Eval_log = function() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      multiply();\n      add();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n    // rational number and not an integer?\n    if (isfraction(p1)) {\n      push(p1);\n      numerator();\n      logarithm();\n      push(p1);\n      denominator();\n      logarithm();\n      subtract();\n      return;\n    }\n    // log(a ^ b) --> b log(a)\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n    // log(a * b) --> log(a) + log(b)\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  // now this might be a little confusing, so a\n  // clarification is in order.\n  // First off, at the scripting level most things\n  // as they are handled get evalled.\n  // That means that they are recursively \"calculated\"\n  // as much as possible, i.e. variables are recursively\n  // looked up for their values, operators are applied,\n  // functions are ivoked, etc.\n  // I.e. while scripting, most things are\n  // evalled all the times.\n  // e.g. if I type\n  //   x = 1+1\n  // then x is actually assigned 2, not 1+1\n  // Something that helps a little is \"quote\", e.g.\n  // If I assign\n  //   x = quote(1+1)\n  // then x actually contains 1+1, not 2.\n  // But then x is evaluated as soon as I type\n  //   x // gives \"2\" as x is evaluated\n\n  // Evaluation is great, but sometimes one wants\n  // to look at the actual structure of an expression\n  // or a content of a variable, without those\n  // being evaluated first.\n\n  // for example I might type\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // and from this point on printing the actual\n  // structure of x is impossible, because from\n  // now on any evaluation of x will give \"3\"\n  // You might say \"but you have x defined up there,\n  // what's the point of printing it out?\", to which\n  // the answer is that one might do further\n  // substitutions or transformations of special kind\n  // to x. One might want to look at the structure\n  // and it might be complex or impossible.\n\n  // So this function does that.\n  // If it's passed a variable, then it\n  // DOES NOT eval the variable, RATHER\n  // it prints the content of the variable without\n  // evaluating it.\n  // In the other cases it works like \"quote\" e.g.\n  // it just gives the argument as is, again without\n  // evaluating it.\n\n  // In the following examples, for brevity, I just\n  // use\n  //   x = quote(1+2)\n  // instead of this:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // to put a structure in x that is easy to see whether\n  // it's avaulated or not.\n\n  // So lookup allows this:\n  //   x = quote(1+2)\n  //   print(lookup(x)) # gives 1+2\n\n  // Note that there would be potentially a way\n  // to achieve a similar result, you could do:\n  //   x = quote(quote(1+2))\n  //   print(x)\n  // but you can't always control x to contain\n  // two quotes like that...\n  // note how two \"quotes\" are needed because\n  // if you just put one, then\n  // x would indeed contain 1+2 instead of 3,\n  // but then print would evaluate that to 3:\n  //   x = quote(1+2) # now x contains 1+2, not 3\n  //   print(x) # but x evaluated here to 3\n\n  // Other workarounds would not work:\n  //   x = quote(1+2)\n  //   print(quote(x))\n  // would not work because quote(x) literally means 'x'\n  // so 'x' is printed instead of its content.\n\n  // Note also that lookup allows you to copy\n  // the structure of a variable to another:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // now:\n  //   y = x # y contains the number 3 and prints to 3\n  //   y = lookup(x) # y contains \"a+b\" and prints to 3\n  //   y = quote(x) # y contains \"x\" and prints to 3\n  // note that in the first and second case y is\n  // independent from x, i.e. changing x doesn't change y\n  // while in the last case it is.\n\n  // Another similar simple example is when doing something\n  // like this:\n  //    x = y\n  //    y = z\n  //    x\n  //       => gives z\n  //    lookup(x)\n  //       => gives y\n  //          i.e. lookup allows you to see the immediate\n  //          content of x, rather than the evaluation which\n  //          would end up in x -> y -> z\n  // Note that if you invert the order of the assignments i.e.\n  //    y = z\n  //    x = y\n  // Then at this point x immediately contains z, since the\n  // assignment x = y is not quoted, hence y is evaluated to z\n  // when assigned to x.\n  //    lookup(x)\n  //       => gives z\n  Eval_lookup = function() {\n    p1 = cadr(p1);\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n    return push(p1); // Bignum addition and subtraction\n  };\n\n  \n  //static unsigned int *addf(unsigned int *, unsigned int *)\n  //static unsigned int *subf(unsigned int *, unsigned int *)\n  //static int ucmp(unsigned int *, unsigned int *)\n  madd = function(a, b) {\n    return a.add(b);\n  };\n\n  msub = function(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function(a, b) {\n    return a.add(b);\n  };\n\n  subf = function(a, b) {\n    return a.subtract(b);\n  };\n\n  // unsigned compare\n  ucmp = function(a, b) {\n    return a.compareAbs(b);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum GCD\n\n  //  Uses the binary GCD algorithm.\n\n  //  See \"The Art of Computer Programming\" p. 338.\n\n  //  mgcd always returns a positive value\n\n  //  mgcd(0, 0) = 0\n\n  //  mgcd(u, 0) = |u|\n\n  //  mgcd(0, v) = |v|\n\n  //-----------------------------------------------------------------------------\n  mgcd = function(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  //if SELFTEST\n\n  // s is a string\n  new_string = function(s) {\n    var theNewString;\n    theNewString = new U();\n    theNewString.k = STR;\n    theNewString.str = s;\n    return theNewString;\n  };\n\n  out_of_memory = function() {\n    return stop(\"out of memory\");\n  };\n\n  // both ints\n  push_zero_matrix = function(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function(p) {\n    var results;\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  // see cmp_expr definition, this\n  // function alone just does simple structure comparison\n  // or compares numbers (either rationals or integers or doubles)\n  // but can't be used alone to test\n  // more complex mathematical equalities...\n  equal = function(p1, p2) {\n    if (cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function(p1, p2) {\n    if (cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // compares whether two expressions\n  // have the same structure.\n  // For example this method alone\n  // would compare \"1+1\" and \"2\"\n  // as different.\n  // It just so happens though that one oftens\n  // evaluates the two sides before passing them\n  // to this function, so chances are that the two\n  // sides have the same normal form.\n  // Even a simple evaluation might not cut it\n  // though... a simplification of both sides\n  // would then help. And even that might not\n  // cut it in some cases...\n  cmp_expr = function(p1, p2) {\n    var n;\n    n = 0;\n    if (p1 === p2) {\n      return 0;\n    }\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n    if (isstr(p1)) {\n      return -1;\n    }\n    if (isstr(p2)) {\n      return 1;\n    }\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n    if (issymbol(p1)) {\n      return -1;\n    }\n    if (issymbol(p2)) {\n      return 1;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n    if (istensor(p1)) {\n      return -1;\n    }\n    if (istensor(p2)) {\n      return 1;\n    }\n    // recursion here\n    while (iscons(p1) && iscons(p2)) {\n      n = cmp_expr(car(p1), car(p2));\n      if (n !== 0) {\n        return n;\n      }\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    if (iscons(p2)) {\n      return -1;\n    }\n    if (iscons(p1)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  length = function(p) {\n    var n;\n    n = 0;\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n    return n;\n  };\n\n  unique = function(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    unique_f(p);\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n    p = p1;\n    restore();\n    return p;\n  };\n\n  unique_f = function(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n      return;\n    }\n    while (iscons(p)) {\n      unique_f(car(p));\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function() {\n    push_integer(2);\n    return power();\n  };\n\n  //__cmp = (p1, p2) ->\n  //  return cmp_expr(p1, p2)\n\n  // n an integer\n  sort_stack = function(n) {\n    var h, subsetOfStack;\n    //qsort(stack + tos - n, n, sizeof (U *), __cmp)\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n\n  $.length = length;\n\n  // Bignum multiplication and division\n  mmul = function(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function(a, b) {\n    return a.divide(b);\n  };\n\n  // a = a + b\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = a - b\n\n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = b * c\n\n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n\n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n  */\n  mmod = function(a, b) {\n    return a.mod(b);\n  };\n\n  // return both quotient and remainder of a/b\n  // we'd have this method as divmod(number)\n  // but obviously doesn't change the passed parameters\n  mdivrem = function(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  //if SELFTEST\n\n  // small integer tests\n  Eval_mod = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p1 = pop();\n    }\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p2 = pop();\n    }\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  // Bignum power\n\n  // a is a bigint, n is a small normal int\n  mpow = function(a, n) {\n    return a.pow(n);\n  };\n\n  //if SELFTEST\n\n  // Bignum prime test (returns 1 if prime, 0 if not)\n\n  // Uses Algorithm P (probabilistic primality test) from p. 395 of\n  // \"The Art of Computer Programming, Volume 2\" by Donald E. Knuth.\n  mprime = function(n) {\n    return n.isProbablePrime();\n  };\n\n  //if SELFTEST\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum root\n\n  //  Returns null pointer if not perfect root.\n\n  //  The sign of the radicand is ignored.\n\n  //-----------------------------------------------------------------------------\n  mroot = function(n, index) {\n    var i, j, k, o, ref, x, y;\n    // this doesn't quite work\n    //return n.pow(1/index +  0.0000000000000001)\n\n    // sign of radicand ignored\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n    // count number of bits\n    k = 0;\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n    if (k === 0) {\n      return mint(0);\n    }\n    // initial guess\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n    for (i = o = 0, ref = j; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      // zero-out the ith bit\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n    while (k >= 0) {\n      // set the kth bit\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n        case 1:\n          //mp_clr_bit(x, k)\n          // clear the kth bit\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n      k--;\n    }\n    return 0;\n  };\n\n  //if SELFTEST\n\n  // Symbolic multiplication\n\n  // multiplication is commutative, so it can't be used\n  // e.g. on two matrices.\n  // But it can be used, say, on a scalar and a matrix.,\n  // so the output of a multiplication is not\n  // always a scalar.\n\n  //extern void append(void)\n  //static void parse_p1(void)\n  //static void parse_p2(void)\n  //static void __normalize_radical_factors(int)\n  DEBUG_MULTIPLY = false;\n\n  Eval_multiply = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // this one doesn't eval the factors,\n  // so you pass i*(-1)^(1/2), it wouldnt't\n  // give -1, because i is not evalled\n  multiply = function() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    // pop operands\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    // is either operand zero?\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    // is either operand a sum?\n\n    //console.log(\"yymultiply: expanding: \" + expanding)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n      return;\n    }\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n    // tensor times scalar?\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n    // adjust operands\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n    // handle numerical coefficients\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n    parse_p1();\n    parse_p2();\n    while (iscons(p1) && iscons(p2)) {\n      //    if (car(p1)->gamma && car(p2)->gamma) {\n      //      combine_gammas(h)\n      //      p1 = cdr(p1)\n      //      p2 = cdr(p2)\n      //      parse_p1()\n      //      parse_p2()\n      //      continue\n      //    }\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n      switch (cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n    // push remaining factors, if any\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n    // normalize radical factors\n\n    // example: 2*2(-1/2) -> 2^(1/2)\n\n    // must be done after merge because merge may produce radical\n\n    // example: 2^(1/2-a)*2^a -> 2^(1/2)\n    __normalize_radical_factors(h);\n    // this hack should not be necessary, unless power returns a multiply\n\n    //for (i = h; i < tos; i++) {\n    //  if (car(stack[i]) == symbol(MULTIPLY)) {\n    //    multiply_all(tos - h)\n    //    return\n    //  }\n    //}\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n    // n is the number of result factors on the stack\n    n = tos - h;\n    if (n === 1) {\n      return;\n    }\n    // discard integer 1\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n      return;\n    }\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p1)    factor\n\n  // output:  p3    factor's base\n\n  //    p5    factor's power (possibly 1)\n  parse_p1 = function() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p2)    factor\n\n  // output:  p4    factor's base\n\n  //    p6    factor's power (possibly 1)\n  parse_p2 = function() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  // h an integer\n  combine_factors = function(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      // power can return number * factor (i.e. -1 * i)\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  //if 0\n\n  // h an int\n  combine_gammas = function(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  // this is useful for example when you are just adding/removing\n  // factors from an already factored quantity.\n  // e.g. if you factored x^2 + 3x + 2 into (x+1)(x+2)\n  // and you want to divide by (x+1) , i.e. you multiply by (x-1)^-1,\n  // then there is no need to expand.\n  multiply_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  // multiply n factors on stack\n\n  // n an integer\n  multiply_all = function(n) {\n    var h, i, o, ref;\n    i = 0;\n    if (n === 1) {\n      return;\n    }\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n    h = tos - n;\n    push(stack[h]);\n    for (i = o = 1, ref = n; (1 <= ref ? o < ref : o > ref); i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  // n an integer\n  multiply_all_noexpand = function(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Symbolic division, or numeric division if doubles are found.\n\n  //  Input:    Dividend and divisor on stack\n\n  //  Output:    Quotient on stack\n\n  //-----------------------------------------------------------------------------\n  divide = function() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  // this is different from inverse of a matrix (inv)!\n  inverse = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function() {\n    return inverse();\n  };\n\n  negate = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n      return multiply();\n    }\n  };\n\n  negate_expand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize radical factors\n\n  //  Input:    stack[h]  Coefficient factor, possibly 1\n\n  //      stack[h + 1]  Second factor\n\n  //      stack[tos - 1]  Last factor\n\n  //  Output:    Reduced coefficent and normalized radicals (maybe)\n\n  //  Example:  2*2^(-1/2) -> 2^(1/2)\n\n  //  (power number number) is guaranteed to have the following properties:\n\n  //  1. Base is an integer\n\n  //  2. Absolute value of exponent < 1\n\n  //  These properties are assured by the power function.\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define B p2\n\n  //define BASE p3\n  //define EXPO p4\n\n  //define TMP p5\n\n  // h is an int\n  __normalize_radical_factors = function(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n    // if coeff is 1 or floating then don't bother\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n// if no radicals then don't bother\n    for (i = o = ref = h + 1, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n    if (i === tos) {\n      return;\n    }\n    // ok, try to simplify\n    save();\n    // numerator\n    push(stack[h]);\n    mp_numerator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors numerator: \" + stack[tos - 1]);\n    }\n    p1 = pop();\n    for (i = i1 = ref2 = h + 1, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) { // p1 is A\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (!isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // numerator divisible by p3 (base)?\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      // reduce numerator\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n    // denominator\n    push(stack[h]);\n    mp_denominator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors denominator: \" + stack[tos - 1]);\n    }\n    p2 = pop();\n    for (i = j1 = ref4 = h + 1, ref5 = tos; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) { // p2 is B\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // denominator divisible by p3? #p3 is BASE\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p5: \" + p5.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical top stack: \" + stack[tos - 1]);\n      }\n      // reduce denominator\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p3: \" + p3.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p4: \" + p4.toString());\n      }\n      push(one);\n      subtract();\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          // bail out,\n          // we want to avoid going ahead with the subtraction of\n          // the exponents, because that would turn a perfectly good\n          // integer exponent in the denominator into a fractional one\n          // i.e. a radical.\n          // Note that this only prevents new radicals ending up\n          // in the denominator, it doesn't fix existing ones.\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical exponent: \" + stack[tos - 1]);\n      }\n      list(3);\n      stack[i] = pop();\n    }\n    // reconstitute the coefficient\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  // don't include i\n  // p is a U\n  // TODO should this be in is.coffee ?\n  __is_radical_number = function(p) {\n    // don't use i\n    return car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isfraction(caddr(p)) && !isminusone(cadr(p));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  > a*hilbert(2)\n  //  ((a,1/2*a),(1/2*a,1/3*a))\n\n  //  Note that \"a\" is presumed to be a scalar. Is this correct?\n\n  //  Yes, because \"*\" has no meaning if \"a\" is a tensor.\n  //  To multiply tensors, \"dot\" or \"outer\" should be used.\n\n  //  > dot(a,hilbert(2))\n  //  dot(a,((1,1/2),(1/2,1/3)))\n\n  //  In this case \"a\" could be a scalar or tensor so the result is not\n  //  expanded.\n\n  //-----------------------------------------------------------------------------\n\n  // find the roots of a polynomial numerically\n  NROOTS_YMAX = 101;\n\n  NROOTS_DELTA = 1.0e-6;\n\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  // random between -2 and 2\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function() {\n    //theRandom += 0.2\n    //return theRandom\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = (function() {\n    class numericRootOfPolynomial {};\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n\n    numericRootOfPolynomial.prototype.i = 0.0;\n\n    return numericRootOfPolynomial;\n\n  }).call(this);\n\n  nroots_a = new numericRootOfPolynomial();\n\n  nroots_b = new numericRootOfPolynomial();\n\n  nroots_x = new numericRootOfPolynomial();\n\n  nroots_y = new numericRootOfPolynomial();\n\n  nroots_fa = new numericRootOfPolynomial();\n\n  nroots_fb = new numericRootOfPolynomial();\n\n  nroots_dx = new numericRootOfPolynomial();\n\n  nroots_df = new numericRootOfPolynomial();\n\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; (0 <= ref ? o < ref : o > ref); initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n    // mark the stack\n    h = tos;\n    // get the coefficients\n    n = coeff(p2, p1);\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n// convert the coefficients to real and imaginary doubles\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n      yyfloat();\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n      yyfloat();\n      Eval();\n      p2 = pop();\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n    // pop the coefficients\n    moveTos(h);\n    // n is the number of coefficients, n = deg(p) + 1\n    monic(n);\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n    // now make n equal to the number of roots\n    n = tos - h;\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n      for (i = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  // divide the polynomial by its leading coefficient\n  monic = function(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n    for (k = i1 = 0, ref1 = n - 1; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  // uses the secant method\n  findroot = function(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n        // dx = nroots_b - nroots_a\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        // df = fb - fa\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        // y = dx / df\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n        if (t === 0.0) {\n          break;\n        }\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        // a = b - y * fb\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    // x = a\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    // fa = c0 + c1 * x\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n    for (k = i1 = 2, ref1 = n; (2 <= ref1 ? i1 < ref1 : i1 > ref1); k = 2 <= ref1 ? ++i1 : --i1) {\n      // x = a * x\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      // fa += c[k] * x\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n    return results;\n  };\n\n  // divide the polynomial by x - a\n  NROOTS_divpoly = function(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n    for (k = i1 = ref1 = n - 1; (ref1 <= 0 ? i1 < 0 : i1 > 0); k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n    results = [];\n    for (k = j1 = 0, ref2 = n - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n    return results;\n  };\n\n  Eval_numerator = function() {\n    push(cadr(p1));\n    Eval();\n    return numerator();\n  };\n\n  numerator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      //console.trace \"rationalising \"\n      rationalize();\n      theArgument = pop();\n    }\n    //console.log \"rationalised: \" + theArgument\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      //console.log \"theArgument inside multiply: \" + theArgument\n      //console.log \"first term: \" + car(theArgument)\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        numerator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  // Outer product of tensors\n  Eval_outer = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  outer = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n    return restore();\n  };\n\n  yyouter = function() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    j = i;\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n    k = 0;\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  partition = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      if (Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push(p3);\n    push(p4);\n    return restore();\n  };\n\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n  */\n  // same as Eval_pattern but only leaves\n  // NIL on stack at return, hence gives no\n  // printout\n  Eval_silentpattern = function() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n    // console.log \"Eval_pattern of \" + cdr(p1)\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    stringKey = \"template: \" + print_list(firstArgument);\n    stringKey += \" tests: \" + print_list(thirdArgument);\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n    // if pattern is not there yet, add it, otherwise replace it\n    if (patternPosition === -1) {\n      //console.log \"adding pattern because it doesn't exist: \" + cdr(p1)\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n    // return the pattern node itself so we can\n    // give some printout feedback\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n\n  do_clearPatterns = function() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function() {\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    do_clearPatterns();\n    \n    // return nothing\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n    if (patternsinfoToBePrinted !== \"\") {\n      return push(new_string(patternsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n    return patternsinfoToBePrinted;\n  };\n\n  Eval_polar = function() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function() {\n    // there are points where we turn polar\n    // representations into rect, we set a \"stack flag\"\n    // here to avoid that, so we don't undo the\n    // work that we are trying to do.\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  // Factor using the Pollard rho method\n  n_factor_number = 0;\n\n  factor_number = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    // 0 or 1?\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n    return restore();\n  };\n\n  // factor using table look-up, then switch to rho method if necessary\n\n  // From TAOCP Vol. 2 by Knuth, p. 380 (Algorithm A)\n  factor_a = function() {\n    var i1, k;\n    k = 0;\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n    return factor_b();\n  };\n\n  try_kth_prime = function(k) {\n    var count, d, q, r;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n    while (1) {\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n        return;\n      }\n      [q, r] = mdivrem(n_factor_number, d);\n      // continue looping while remainder is zero\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n    if (count) {\n      push_factor(d, count);\n    }\n    // q = n_factor_number/d, hence if q < d then\n    // n_factor_number < d^2 so n_factor_number is prime\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  // From TAOCP Vol. 2 by Knuth, p. 385 (Algorithm B)\n  factor_b = function() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n        // g = gcd(x' - x, n_factor_number)\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n          // x = (x ^ 2 + 1) mod n_factor_number\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n        push_factor(g, 1);\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n        // n_factor_number = n_factor_number / g\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        // x = x mod n_factor_number\n        t = mmod(x, n_factor_number);\n        x = t;\n        // xprime = xprime mod n_factor_number\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n\n  DEBUG_POWER = false;\n\n  Eval_power = function() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    n = 0;\n    p2 = pop(); // exponent\n    p1 = pop(); // base\n    inputExp = p2;\n    inputBase = p1;\n    //debugger\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n    // first, some very basic simplifications right away\n\n    //  1 ^ a    ->  1\n    //  a ^ 0    ->  1\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  a ^ 1    ->  a\n    if (equal(p2, one)) {\n      push(p1);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1    ->  -1\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ 1/2  ->  i\n    if (isminusone(p1) && (isoneovertwo(p2))) {\n      push(imaginaryunit);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1/2  ->  -i\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ rational\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n      // evaluates clock form into\n      // rectangular form. This seems to give\n      // slightly better form to some test results.\n      rect();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are rational numbers?\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n      push(p1);\n      push(p2);\n      qpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are either rational or double?\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n      push(p1);\n      push(p2);\n      dpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n      power_tensor();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // if we only assume variables to be real, then |a|^2 = a^2\n    // (if x is complex this doesn't hold e.g. i, which makes 1 and -1\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n      push(cadr(p1));\n      push(p2);\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^log(...)\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^some_float\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n      push_double(Math.exp(p2.d));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number in exponential form, get it to rectangular\n    // but only if we are not in the process of calculating a polar form,\n    // otherwise we'd just undo the work we want to do\n    if (p1 === symbol(E) && Find(p2, imaginaryunit) !== 0 && Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n      rect();\n      hopefullySimplified = pop();\n      if (Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n        push(hopefullySimplified);\n        return;\n      }\n    }\n    //  (a * b) ^ c  ->  (a ^ c) * (b ^ c)\n    // note that we can't in general do this, for example\n    // sqrt(x*y) != x^(1/2) y^(1/2) (counterexample\" x = -1 and y = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // (a ^ b) ^ c  ->  a ^ (b * c)\n    // note that we can't in general do this, for example\n    // sqrt(x^y) !=  x^(1/2 y) (counterexample x = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n\n    // simple numeric check to see if a is a number > 0\n    is_a_moreThanZero = false;\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) { // when a is >= 0\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    b_isEven_and_c_isItsInverse = false;\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n      push(cadr(p1));\n      abs();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  when expanding,\n    //  (a + b) ^ n  ->  (a + b) * (a + b) ...\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n        power_sum(n);\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    //  sin(x) ^ 2n -> (1 - cos(x) ^ 2) ^ n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  cos(x) ^ 2n -> (1 - sin(x) ^ 2) ^ n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number? (just number, not expression)\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n      // integer power?\n\n      // n will be negative here, positive n already handled\n      if (isinteger(p2)) {\n        //               /        \\  n\n        //         -n   |  a - ib  |\n        // (a + ib)   = | -------- |\n        //              |   2   2  |\n        //               \\ a + b  /\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        // gets the denominator\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n      // noninteger or floating power?\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n        if (evaluatingAsFloats || (iscomplexnumberdouble(p1) && isdouble(p2))) {\n          // remember that the \"double\" type is\n          // toxic, i.e. it propagates, so we do\n          // need to evaluate PI to its actual double\n          // value\n          push_double(Math.PI);\n        } else {\n          //console.log(\"power pushing PI when p1 is: \" + p1 + \" and p2 is:\" + p2)\n          push(symbol(PI));\n        }\n        divide();\n        power();\n        multiply();\n        // if we calculate the power making use of arctan:\n        //  * it prevents nested radicals from being simplified\n        //  * results become really hard to manipulate afterwards\n        //  * we can't go back to other forms.\n        // so leave the power as it is.\n        if (avoidCalculatingPowersIntoArctans) {\n          if (Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    \n    //push(p1)\n    //abs()\n    //push(p2)\n    //power()\n    //push(symbol(E))\n    //push(p1)\n    //arg()\n    //push(p2)\n    //multiply()\n    //push(imaginaryunit)\n    //multiply()\n    //power()\n    //multiply()\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n      return;\n    }\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute the power of a sum\n\n  //  Input:    p1  sum\n\n  //      n  exponent\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses the multinomial series (see Math World)\n\n  //                          n              n!          n1   n2       nk\n  //  (a1 + a2 + ... + ak)  = sum (--------------- a1   a2   ... ak  )\n  //                               n1! n2! ... nk!\n\n  //  The sum is over all n1 ... nk such that n1 + n2 + ... + nk = n.\n\n  //-----------------------------------------------------------------------------\n\n  // first index is the term number 0..k-1, second index is the exponent 0..n\n\n  //define A(i, j) frame[(i) * (n + 1) + (j)]\n  power_sum = function(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    // number of terms in the sum\n    k = length(p1) - 1;\n    // local frame\n    push_frame(k * (n + 1));\n    // array of powers\n    p1 = cdr(p1);\n    for (i = i1 = 0, ref1 = k; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push_integer(n);\n    factorial();\n    p1 = pop();\n    for (i = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n    push(zero);\n    multinomial_sum(k, n, a, 0, n);\n    return pop_frame(k * (n + 1));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute multinomial sum\n\n  //  Input:    k  number of factors\n\n  //      n  overall exponent\n\n  //      a  partition array\n\n  //      i  partition array index\n\n  //      m  partition remainder\n\n  //      p1  n!\n\n  //      A  factor array\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses recursive descent to fill the partition array.\n\n  //-----------------------------------------------------------------------------\n\n  //int k, int n, int *a, int i, int m\n  multinomial_sum = function(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n        multinomial_sum(k, n, a, i + 1, m - j);\n      }\n      return;\n    }\n    a[i] = m;\n    // coefficient\n    push(p1);\n    for (j = j1 = 0, ref2 = k; (0 <= ref2 ? j1 < ref2 : j1 > ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n// factors\n    for (j = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n    return add();\n  };\n\n  // exp(n/2 i pi) ?\n\n  // p2 is the exponent expression\n\n  // clobbers p3\n  simplify_polar = function() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n      case 1:\n        push_integer(1);\n        return 1;\n      case 2:\n        push_integer(-1);\n        return 1;\n      case 3:\n        push(imaginaryunit);\n        return 1;\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n        if (n) {\n          break;\n        }\n        p3 = cdr(p3);\n      }\n      switch (n) {\n        case 0:\n          return 0;\n        case 1:\n          push_integer(1);\n          break;\n        case 2:\n          push_integer(-1);\n          break;\n        case 3:\n          push(imaginaryunit);\n          break;\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Look up the nth prime\n\n  //  Input:    n on stack (0 < n < 10001)\n\n  //  Output:    nth prime on stack\n\n  //-----------------------------------------------------------------------------\n  Eval_prime = function() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function() {\n    var n;\n    n = 0;\n    n = pop_integer();\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n\n  codeGen = false;\n\n  // this is only invoked when user invokes\n  // \"print\" explicitly\n  Eval_print = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"print2dascii\" explicitly\n  Eval_print2dascii = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printcomputer\" explicitly\n  Eval_printcomputer = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlatex\" explicitly\n  Eval_printlatex = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printhuman\" explicitly\n  Eval_printhuman = function() {\n    var original_test_flag;\n    // test flag needs to be suspended\n    // because otherwise \"printcomputer\" mode\n    // will happen.\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlist\" explicitly\n  Eval_printlist = function() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      origPrintMode = printMode;\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n    return accumulator;\n  };\n\n  rememberPrint = function(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n    return s;\n  };\n\n  print_char = function(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    // some variables might contain underscores, escape those\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n    return returnedString;\n  };\n\n  printline = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function(p1) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) { // p1 is BASE\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1); // p1 is BASE\n    }\n    return accumulator;\n  };\n\n  print_expo_of_denom = function(p2) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) { // p2 is EXPO\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2); // p2 is EXPO\n    }\n    return accumulator;\n  };\n\n  // prints stuff after the divide symbol \"/\"\n\n  // d is the number of denominators\n\n  //define BASE p1\n  //define EXPO p2\n  print_denom = function(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n    if (isminusone(p2)) { // p2 is EXPO\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n    if (d === 1) { // p2 is EXPO\n      accumulator += print_char('(');\n    }\n    // prepare the exponent\n    // (needs to be negated)\n    // before printing it out\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += print_power(p1, p2);\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n    restore();\n    return accumulator;\n  };\n\n  //define A p3\n  //define B p4\n  print_a_over_b = function(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    // count numerators and denominators\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n      if (!isplusone(p3)) { // p3 is A\n        n++;\n      }\n      if (!isplusone(p4)) { // p4 is B\n        d++;\n      }\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one; // p4 is B\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    //debugger\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n      if (!isplusone(p3)) { // p3 is A\n        accumulator += print_factor(p3);\n        flag = 1;\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n          accumulator += print_factor(p2);\n          flag = 1;\n        }\n        p1 = cdr(p1);\n      }\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n    flag = 0;\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    if (!isplusone(p4)) { // p4 is B\n      accumulator += print_factor(p4);\n      flag = 1;\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n      p1 = cdr(p1);\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(p)) {\n      p = cdr(p);\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(p);\n    }\n    return accumulator;\n  };\n\n  sign_of_term = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n    return accumulator;\n  };\n\n  print_term = function(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      // coeff -1?\n      if (isminusone(car(p))) {\n        //      print_char('-')\n        p = cdr(p);\n      }\n      previousFactorWasANumber = false;\n      // print the first factor ------------\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n      // this numberOneOverSomething thing is so that\n      // we show things of the form\n      //   numericFractionOfForm1/something * somethingElse\n      // as\n      //   somethingElse / something\n      // so for example 1/2 * sqrt(2) is rendered as\n      //   sqrt(2)/2\n      // rather than the first form, which looks confusing.\n      // NOTE that you might want to avoid this\n      // when printing polynomials, as it could be nicer\n      // to show the numeric coefficients well separated from\n      // the variable, but we'll see when we'll\n      // come to it if it's an issue.\n      numberOneOverSomething = false;\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += print_factor(car(p));\n      }\n      p = cdr(p);\n      // print all the other factors -------\n      while (iscons(p)) {\n        // check if we end up having a case where two numbers\n        // are next to each other. In those cases, latex needs\n        // to insert a \\cdot otherwise they end up\n        // right next to each other and read like one big number\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            // if what comes next is a power and the base\n            // is a number, then we are in the case\n            // of consecutive numbers.\n            // Note that sqrt() i.e when exponent is 1/2\n            // doesn't count because the radical gives\n            // a nice graphical separation already.\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n        accumulator += print_multiply_sign();\n        accumulator += print_factor(car(p), false, true);\n        previousFactorWasANumber = false;\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n        p = cdr(p);\n      }\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += print_factor(p);\n    }\n    return accumulator;\n  };\n\n  print_subexpr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n    for (i = i1 = 1, ref1 = numberOfIntegrals; (1 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n      p = cdr(cdr(theVariable));\n    }\n    return accumulator;\n  };\n\n  print_tensor = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner = function(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner(p, j + 1, k);\n        accumulator += retString;\n        // add separator between elements dimensions\n        // \"above\" the inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // add separator between elements in the\n        // inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n        k++;\n      }\n    }\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (p.tensor.ndim <= 2) {\n      accumulator += print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n    return accumulator;\n  };\n\n  // firstLevel is needed because printing a matrix\n  // is not exactly an elegant recursive procedure:\n  // the vector on the first level prints the latex\n  // \"wrap\", while the vectors that make up the\n  // rows don't. so it's a bit asymmetric and this\n  // flag helps.\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner_latex = function(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    // open the outer latex wrap\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner_latex(0, p, j + 1, k);\n        accumulator += retString;\n        if (i !== p.tensor.dim[j] - 1) {\n          // add separator between rows\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // separator between elements in each row\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n        k++;\n      }\n    }\n    // close the outer latex wrap\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      p = cddr(p);\n    }\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      howManyIfs++;\n      p = cddr(p);\n    }\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(cadr(p));\n    }\n    return accumulator;\n  };\n\n  print_exponent = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isNumericAtom(caddr(p)) && lessp(caddr(p), zero))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(caddr(p));\n    }\n    return accumulator;\n  };\n\n  print_power = function(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n    //debugger\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n    // quick check is this is actually a square root.\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1)) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0)) || base.printname !== \"x\") {\n      // if the exponent is negative then\n      // we invert the base BUT we don't do\n      // that if the base is \"e\", because for\n      // example when trigonometric functions are\n      // expressed in terms of exponential functions\n      // that would be really confusing, one wants to\n      // keep \"e\" as the base and the negative exponent\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_power(base, newExponent);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n      }\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n        denominator();\n        denomExponent = pop();\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n        accumulator += print_str(\"{\");\n        push(exponent);\n        numerator();\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      // if we are in latex mode we turn many\n      // radicals into a radix sign with a power\n      // underneath, and the power is often one\n      // (e.g. square root turns into a radical\n      // with a power one underneath) so handle\n      // this case simply here, just print the base\n      accumulator += print_expr(base);\n    } else {\n      // print the base,\n      // determining if it needs to be\n      // wrapped in parentheses or not\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n        accumulator += print_factor(base, true);\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(base);\n      }\n      // print the power symbol\n      //debugger\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        //print_str(\" ^ \")\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n      // print the exponent\n      if (printMode === PRINTMODE_LATEX) {\n        // in latex mode, one can omit the curly braces\n        // wrapping the exponent if the exponent is only\n        // one character long\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || (isNumericAtom(exponent) && lessp(exponent, zero))) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(exponent);\n      }\n    }\n    return accumulator;\n  };\n\n  print_index_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n    accumulator += print_str('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  print_factor = function(p, omitParens, pastFirstFactor) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    // debugger\n    accumulator = \"\";\n    if (isNumericAtom(p)) {\n      // in an evaluated term, all the numeric parts\n      // are at the beginning of the term.\n      // When printing the EXPRESSION,\n      // we peek into the first factor of the term and we\n      // look at whether it's a number less then zero.\n      // if it is, we print the \"-\" as the \"leading\" part of the\n      // print of the EXPRESSION, and then we proceed printint the factors\n      // of the term. This means that when we come here, we must\n      // skip printing the minus if the number is negative,\n      // because it's already been printed.\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += '(';\n      }\n      accumulator += print_number(p, pastFirstFactor);\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += ')';\n      }\n      return accumulator;\n    }\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += print_power(base, exponent);\n      return accumulator;\n    }\n    //  if (car(p) == _list) {\n    //    print_str(\"{\")\n    //    p = cdr(p)\n    //    if (iscons(p)) {\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    while (iscons(p)) {\n    //      print_str(\",\")\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    print_str(\"}\")\n    //    return\n    //  }\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n        returned = print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      //debugger\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    //else if car(p) == symbol(QUOTE)\n    //  if printMode == PRINTMODE_LATEX\n    //    print_expr(cadr(p))\n    //    return accumulator\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p)->k == SYM) {\n      //  print_str(((struct symbol *) cadr(p))->name)\n      //  return\n      //}\n      accumulator += print_factor(car(p));\n      p = cdr(p);\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n    return accumulator;\n  };\n\n  print_list = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += print_list(car(p));\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += print_list(car(p));\n          p = cdr(p);\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += print_list(p);\n        }\n        accumulator += ')';\n        break;\n      case STR:\n        //print_str(\"\\\"\")\n        accumulator += p.str;\n        break;\n      //print_str(\"\\\"\")\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n      default:\n        accumulator += \"<tensor>\";\n    }\n    return accumulator;\n  };\n\n  print_multiply_sign = function() {\n    var accumulator;\n    accumulator = \"\";\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n    return accumulator;\n  };\n\n  is_denominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // don't consider the leading fraction\n  // we want 2/3*a*b*c instead of 2*a*b*c/3\n  any_denominators = function(p) {\n    var q;\n    p = cdr(p);\n    //  if (isfraction(car(p)))\n    //    return 1\n    while (iscons(p)) {\n      q = car(p);\n      if (is_denominator(q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  /*\n\n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n\n        1\n   ----------\n           2\n    (1 + x)\n\n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n\n     1\n   ----\n     2\n   x\n\n  is 1/x^2 but it also looks a little like x^(1/2)\n\n  */\n  //-----------------------------------------------------------------------------\n\n  //  Examples:\n\n  //     012345678\n  //  -2 .........\n  //  -1 .........\n  //   0 ..hello..  x=2, y=0, h=1, w=5\n  //   1 .........\n  //   2 .........\n\n  //     012345678\n  //  -2 .........\n  //  -1 ..355....\n  //   0 ..---....  x=2, y=-1, h=3, w=3\n  //   1 ..113....\n  //   2 .........\n\n  //-----------------------------------------------------------------------------\n  YMAX = 10000;\n\n  glyph = (function() {\n    class glyph {};\n\n    glyph.prototype.c = 0;\n\n    glyph.prototype.x = 0;\n\n    glyph.prototype.y = 0;\n\n    return glyph;\n\n  }).call(this);\n\n  // will contain glyphs\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; (0 <= ref1 ? i1 < ref1 : i1 > ref1); charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n\n  level = 0;\n\n  emit_x = 0;\n\n  expr_level = 0;\n\n  display_flag = 0;\n\n  // this is not really the translated version,\n  // the original is in window.cpp and is\n  // rather more complex\n  printchar_nowrap = function(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function(p) {\n    var beenPrinted, h, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    // if too wide then print flat\n    [h, w, y] = get_size(0, yindex);\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n      __emit_str(\" = \");\n      emit_expr(caddr(p));\n      return;\n    }\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function(p) {\n    if (level > 0) {\n      return 0;\n    }\n    if (isfraction(p)) {\n      return 1;\n    }\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  emit_expr = function(p) {\n    //  if (level > 0) {\n    //    printexpr(p)\n    //    return\n    //  }\n    expr_level++;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(p);\n    }\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      //    if (__is_negative(car(p)))\n      //      __emit_char('-')\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      //    if (__is_negative(p))\n      //      __emit_char('-')\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_term = function(p) {\n    var n;\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n    //  if (isfraction(car(p))) {\n    //    count++\n    //    p = cdr(p)\n    //  }\n    while (iscons(p)) {\n      q = car(p);\n      if (isdenominator(q)) {\n        count++;\n      }\n      p = cdr(p);\n    }\n    return count;\n  };\n\n  // n is the number of denominators, not counting a fraction like 1/2\n  emit_multiply = function(p, n) {\n    var results;\n    if (n === 0) {\n      p = cdr(p);\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        __emit_char(' ');\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      emit_numerators(p);\n      __emit_char('/');\n      // need grouping if more than one denominator\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  //define A p3\n  //define B p4\n\n  // sign of term has already been emitted\n  emit_fraction = function(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop(); // p4 is B\n    }\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n      absval();\n      p3 = pop(); // p3 is A\n    }\n    \n    // count numerators\n    if (isplusone(p3)) { // p3 is A\n      n = 0;\n    } else {\n      n = 1;\n    }\n    p1 = cdr(p);\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    // emit numerators\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n    if (!isplusone(p3)) { // p3 is A\n      emit_number(p3, 0);\n      count++;\n    }\n    // skip over \"multiply\"\n    p1 = cdr(p);\n    // skip over numerical coefficient, already handled\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    if (count === 0) {\n      __emit_char('1');\n    }\n    // emit denominators\n    k2 = yindex;\n    count = 0;\n    if (!isplusone(p4)) { // p4 is B\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(p2, d);\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_numerators = function(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    }\n    n = 0;\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_factor(car(p));\n        n++;\n      }\n      p = cdr(p);\n    }\n    if (n === 0) {\n      __emit_char('1');\n    }\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_denominators = function(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(car(p), 0);\n        n++;\n      }\n      p = cdr(p);\n    }\n    return restore();\n  };\n\n  emit_factor = function(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        //emit_tensor(p)\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n      return;\n    }\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p).k == SYM)\n      //  emit_symbol(cadr(p))\n      //else\n      emit_function(p);\n      return;\n    }\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n      return;\n    }\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n    absval();\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n    if (isplusone(p4)) { // p4 is B\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0); // p4 is B\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // if it's a factor then it doesn't need parens around it, i.e. 1/sin(theta)^2\n  isfactor = function(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n    if (issymbol(p)) {\n      return 1;\n    }\n    if (isfraction(p)) {\n      return 0;\n    }\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_power = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n      emit_expr(caddr(p));\n      __emit_char(')');\n      return;\n    }\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n        __emit_char('/');\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n        __emit_char('^');\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n      return;\n    }\n    // special case: 1 over something\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n      __emit_char('1');\n      k2 = yindex;\n      //level++\n      emit_denominator(p, 1);\n      //level--\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n    k1 = yindex;\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  // if n == 1 then emit as expr (no parens)\n\n  // p is a power\n  emit_denominator = function(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n    // special case: 1 over something\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n      return;\n    }\n    k1 = yindex;\n    // emit base\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    // emit exponent, don't emit minus sign\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n    __emit_char('(');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        //__emit_char(' ')\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(')');\n  };\n\n  emit_index_function = function(p) {\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n    __emit_char('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function(p) {\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function(p) {\n    __emit_char('(');\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n      return;\n    }\n    pPrintName = get_printname(p);\n    results = [];\n    for (i = j1 = 0, ref2 = pPrintName.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n    return results;\n  };\n\n  emit_string = function(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n    __emit_char('\"');\n    for (i = j1 = 0, ref2 = pString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2; // shift numerator right\n    } else {\n      dx = 0;\n    }\n    dx++;\n    // this is how much is below the baseline\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n    w += 2;\n    emit_x = x;\n    results = [];\n    for (i = j1 = 0, ref2 = w; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n    return results;\n  };\n\n  fixup_power = function(k1, k2) {\n    var dy, h1, h2, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    // move superscript to baseline\n    dy = -y2 - h2 + 1;\n    // now move above base\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n    for (i = j1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n    return results;\n  };\n\n  // finds the bounding rectangle and vertical position\n  get_size = function(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n    for (i = j1 = ref2 = j + 1, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n    for (i = j1 = 0, ref2 = s.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n    return results;\n  };\n\n  emit_number = function(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        for (i = j1 = 0, ref2 = tmpString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n        tmpString = p.q.b.toString();\n        if (tmpString === \"1\") {\n          break;\n        }\n        __emit_char('/');\n        results = [];\n        for (i = l1 = 0, ref3 = tmpString.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n        return results;\n        break;\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        results1 = [];\n        for (i = m1 = 0, ref4 = tmpString.length; (0 <= ref4 ? m1 < ref4 : m1 > ref4); i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n        return results1;\n    }\n  };\n\n  // a and b are glyphs\n  cmpGlyphs = function(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n    if (a.y > b.y) {\n      return 1;\n    }\n    if (a.x < b.x) {\n      return -1;\n    }\n    if (a.x > b.x) {\n      return 1;\n    }\n    return 0;\n  };\n\n  print_glyphs = function() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    \n    // now sort the glyphs by their vertical positions,\n    // since we are going to build a string where obviously the\n    // \"upper\" line has to printed out first, followed by\n    // a new line, followed by the other lines.\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = (function() {\n    class oneElement {};\n\n    oneElement.prototype.x = 0;\n\n    oneElement.prototype.y = 0;\n\n    oneElement.prototype.h = 0;\n\n    oneElement.prototype.w = 0;\n\n    oneElement.prototype.index = 0;\n\n    oneElement.prototype.count = 0;\n\n    return oneElement;\n\n  }).call(this);\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n    nrow = p.tensor.dim[0];\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n    n = nrow * ncol;\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n    // horizontal coordinate of the matrix\n\n    //if 0\n    //emit_x += 2; # make space for left paren\n    //endif\n    x = emit_x;\n// emit each element\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      [elem[i].h, elem[i].w, elem[i].y] = get_size(elem[i].index, yindex);\n    }\n    // find element height and width\n    eh = 0;\n    ew = 0;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n    // this is the overall height of the matrix\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    // this is the overall width of the matrix\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    // this is the vertical coordinate of the matrix\n    y = -(h / 2);\n// move elements around\n    for (row = n1 = 0, ref4 = nrow; (0 <= ref4 ? n1 < ref4 : n1 > ref4); row = 0 <= ref4 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref5 = ncol; (0 <= ref5 ? o1 < ref5 : o1 > ref5); col = 0 <= ref5 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        // first move to upper left corner of matrix\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        // now move to official position\n        dx = 0;\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n        dy = 0;\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n        // small correction for horizontal centering\n        dx += (ew - elem[i].w) / 2;\n        // small correction for vertical centering\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n    return emit_x = x + w;\n  };\n\n  emit_flat_tensor = function(p) {\n    return emit_tensor_inner(p, 0, 0);\n  };\n\n  emit_tensor_inner = function(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n    __emit_char('(');\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = emit_tensor_inner(p, j + 1, k);\n      }\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n    __emit_char(')');\n    return k;\n  };\n\n  // 'product' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the product at the top of the stack\n  Eval_product = function() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n      multiply();\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  //  Add rational numbers\n\n  //  Input:    tos-2    addend\n\n  //      tos-1    addend\n\n  //  Output:    sum on stack\n  qadd = function() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    // a, qadd_ab, b, qadd_ba, c are all bigNum\n    // we are adding the fractions qadd_frac1 + qadd_frac2 i.e.\n    // qadd_frac1.q.a/qadd_frac1.q.b + qadd_frac2.q.a/qadd_frac2.q.b\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n    //mfree(qadd_ab)\n    //mfree(qadd_ba)\n\n    // zero?\n    if (MZERO(qadd_numerator)) {\n      //console.log \"qadd IS ZERO\"\n      //mfree(qadd_numerator)\n      push(zero);\n      return;\n    }\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    //console.log \"gcd(\"+qadd_numerator+\",\"+qadd_denominator+\"): \" + gcdBetweenNumeratorAndDenominator\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    //console.log \"qadd qadd_denominator: \" + qadd_denominator\n    //console.log \"qadd gcdBetweenNumeratorAndDenominator: \" + gcdBetweenNumeratorAndDenominator\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    //console.log \"qadd resultSum.q.a: \" + resultSum.q.a\n    //console.log \"qadd resultSum.q.b: \" + resultSum.q.b\n\n    //mfree(qadd_numerator)\n    //mfree(qadd_denominator)\n    //mfree(gcdBetweenNumeratorAndDenominator)\n    return push(resultSum);\n  };\n\n  //console.log \"qadd result: \" + resultSum\n\n  //  Divide rational numbers\n\n  //  Input:    tos-2    dividend\n\n  //      tos-1    divisor\n\n  //  Output:    quotient on stack\n  qdiv = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  //  Multiply rational numbers\n\n  //  Input:    tos-2    multiplicand\n\n  //      tos-1    multiplier\n\n  //  Output:    product on stack\n  qmul = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    //mfree(aa)\n    //mfree(bb)\n    push(p1);\n    return restore();\n  };\n\n  // Rational power function\n  qpow = function() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  //define BASE p1\n  //define EXPO p2\n  qpowf = function() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    //unsigned int a, b, *t, *x, *y\n    p2 = pop();\n    p1 = pop();\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) { // p1 is BASE  # p2 is EXPO\n      push_integer(1);\n      return;\n    }\n    // if (-1)^(1/2) -> leave it as is\n    if (isminusone(p1) && isoneovertwo(p2)) { // p1 is BASE  # p2 is EXPO\n      push(imaginaryunit);\n      return;\n    }\n    // if base is zero then return 0\n    if (isZeroAtomOrTensor(p1)) { // p1 is BASE\n      if (isnegativenumber(p2)) { // p2 is EXPO\n        stop(\"divide by zero\");\n      }\n      push(zero);\n      return;\n    }\n    // if exponent is 1 then return base\n    if (isplusone(p2)) { // p2 is EXPO\n      push(p1);\n      return;\n    }\n    // if exponent is integer then power\n    if (isinteger(p2)) { // p2 is EXPO\n      push(p2);\n      expo = pop_integer();\n      if (isNaN(expo)) {\n        // expo greater than 32 bits\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n    // from here on out the exponent is NOT an integer\n\n    // if base is -1 then normalize polar angle\n    if (isminusone(p1)) { // p1 is BASE\n      push(p2);\n      normalize_angle();\n      return;\n    }\n    // if base is negative then (-N)^M -> N^M * (-1)^M\n    if (isnegativenumber(p1)) { // p1 is BASE\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n    if (!isinteger(p1)) { // p1 is BASE\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n    // At this point p1 (BASE) is a positive integer.\n\n    // If p1 (BASE) is small then factor it.\n    if (is_small_integer(p1)) { // p1 is BASE\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) { // p2 is EXPO\n      push_symbol(POWER);\n      push(p1); // p1 is BASE\n      push(p2);\n      list(3);\n      return;\n    }\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    y = mpow(x, a);\n    //mfree(x)\n    p3 = new U();\n    p3.k = NUM;\n    if (p2.q.a.isNegative()) { // p2 is EXPO\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize the angle of unit imaginary, i.e. (-1) ^ N\n\n  //  Input:    N on stack (must be rational, not float)\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  n = q * d + r\n\n  //  Example:\n  //            n  d  q  r\n\n  //  (-1)^(8/3)  ->   (-1)^(2/3)  8  3  2  2\n  //  (-1)^(7/3)  ->   (-1)^(1/3)  7  3  2  1\n  //  (-1)^(5/3)  ->  -(-1)^(2/3)  5  3  1  2\n  //  (-1)^(4/3)  ->  -(-1)^(1/3)  4  3  1  1\n  //  (-1)^(2/3)  ->   (-1)^(2/3)  2  3  0  2\n  //  (-1)^(1/3)  ->   (-1)^(1/3)  1  3  0  1\n\n  //  (-1)^(-1/3)  ->  -(-1)^(2/3)  -1  3  -1  2\n  //  (-1)^(-2/3)  ->  -(-1)^(1/3)  -2  3  -1  1\n  //  (-1)^(-4/3)  ->   (-1)^(2/3)  -4  3  -2  2\n  //  (-1)^(-5/3)  ->   (-1)^(1/3)  -5  3  -2  1\n  //  (-1)^(-7/3)  ->  -(-1)^(2/3)  -7  3  -3  2\n  //  (-1)^(-8/3)  ->  -(-1)^(1/3)  -8  3  -3  1\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define Q p2\n  //define R p3\n  normalize_angle = function() {\n    save();\n    p1 = pop();\n    if (isinteger(p1)) { // p1 is A\n      if (p1.q.a.isOdd()) { // p1 is A\n        push_integer(-1); // odd exponent\n      } else {\n        push_integer(1); // even exponent\n      }\n      restore();\n      return;\n    }\n    // floor\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n    if (isnegativenumber(p1)) { // p1 is A\n      push(p2); // p2 is Q\n      push_integer(-1);\n      add();\n      p2 = pop(); // p2 is Q\n    }\n    \n    // remainder (always positive)\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3); // p3 is R\n    list(3);\n    // negate if quotient is odd\n    if (p2.q.a.isOdd()) { // p2 is Q\n      negate();\n    }\n    return restore();\n  };\n\n  is_small_integer = function(p) {\n    return isSmall(p.q.a);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor small numerical powers\n\n  //  Input:    tos-2    Base (positive integer < 2^31 - 1)\n\n  //      tos-1    Exponent\n\n  //  Output:    Expr on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define BASE p1\n  //define EXPO p2\n  quickfactor = function() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n    // stack has n results from factor_number_raw()\n\n    // on top of that are all the expressions from quickpower()\n\n    // multiply the quickpower() results\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  // p1 (BASE) is a prime number so power is simpler\n  quickpower = function() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n    push(p3);\n    expo = pop_integer();\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n    if (expo === 0) {\n      restore();\n      return;\n    }\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  //if SELFTEST\n\n  // Divide polynomials\n  Eval_quotient = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n    push(p1);\n    return divpoly();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide polynomials\n\n  //  Input:    tos-3    Dividend\n\n  //      tos-2    Divisor\n\n  //      tos-1    x\n\n  //  Output:    tos-1    Quotient\n\n  //-----------------------------------------------------------------------------\n\n  //define DIVIDEND p1\n  //define DIVISOR p2\n  //define X p3\n  //define Q p4\n  //define QUOTIENT p5\n  divpoly = function() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    //U **dividend, **divisor\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    m = coeff(p3, p1) - 1;\n    divisor = tos;\n    n = coeff(p3, p2) - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  DEBUG_RATIONALIZE = false;\n\n  Eval_rationalize = function() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n      return;\n    }\n    expanding = 0;\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the input expr: \" + theArgument);\n    }\n    // get new denominator\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the new denominator: \" + commonDenominator);\n    }\n    // multiply each term by new denominator\n    push(zero);\n    eachTerm = cdr(theArgument);\n    while (iscons(eachTerm)) {\n      if (DEBUG_RATIONALIZE) {\n        console.log(\"term: \" + car(eachTerm));\n      }\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: original terms times new denominator: \" + stack[tos - 1]);\n    }\n    // collect common factors\n    Condense();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: after factoring: \" + stack[tos - 1]);\n    }\n    // divide by common denominator\n    push(commonDenominator);\n    divide();\n    if (DEBUG_RATIONALIZE) {\n      return console.log(\"rationalize: after dividing by new denom. (and we're done): \" + stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n    push(p);\n    p = caddr(p);\n    // like x^(-2) ?\n    if (isnegativenumber(p)) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // like x^(-a) ?\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // no match\n    return pop();\n  };\n\n  __rationalize_tensor = function(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n    if (!istensor(theTensor)) { // might be zero\n      push(theTensor);\n      return;\n    }\n    n = theTensor.tensor.nelem;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n\n  Eval_real = function() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function() {\n    save();\n    rect();\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function() {\n    push(cadr(p1));\n    Eval();\n    return rect();\n  };\n\n  rect = function() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + findPossibleClockForm(input));\n    }\n    // if we assume real variables, then the\n    // rect of any symbol is the symbol itself\n    // (note that 'i' is not a symbol, it's made of (-1)^(1/2))\n    // otherwise we have to leave unevalled\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !findPossibleExponentialForm(p1) && !findPossibleClockForm(p1) && !(Find(p1, symbol(SIN)) && Find(p1, symbol(COS)) && Find(p1, imaginaryunit))) { // no polar form?\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      push(p1);\n    // ib\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    // sum\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        rect();\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      // try to get to the rectangular form by doing\n      // abs(p1) * (cos (theta) + i * sin(theta))\n      // where theta is arg(p1)\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n      push(p1);\n      abs();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n      push(p1);\n      arg();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n      p1 = pop();\n      push(p1);\n      cosine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n      push(imaginaryunit);\n      push(p1);\n      sine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n      add();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n    }\n    restore();\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  //define POLY p1\n  //define X p2\n  //define A p3\n  //define B p4\n  //define C p5\n  //define Y p6\n  show_power_debug = false;\n\n  performing_roots = false;\n\n  Eval_roots = function() {\n    // this transforms simple \"equation\" forms into\n    // something that can be processed. E.g., say, y = 3x - 2\n    // A == B -> A - B\n    // A = B -> A - B\n    p2 = cadr(p1);\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n    // 2nd arg, x\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial in the variable \" + p2);\n    }\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    //polycoeff = tos\n    imaginaryCoefficients = false;\n    h = tos;\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      //console.log \"hasImaginaryCoeff - coeff.:\" + stack[tos-i].toString()\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n    //polycoeff = tos\n\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function(variable, polynomial) {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff(variable, polynomial);\n    //console.log(\"->\" + tos)\n    divideBy = stack[tos - 1];\n    miniStack = [];\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n//console.log(tos)\n    for (i = m1 = ref3 = k - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n    //console.log(tos)\n    return k;\n  };\n\n  // takes the polynomial and the\n  // variable on the stack\n  roots = function() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (DEBUG) {\n      console.log(\"roots: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    // the simplification of nested radicals uses\n    // \"roots\", which in turn uses simplification\n    // of nested radicals. Usually there is no problem,\n    // one level of recursion does the job. Beyond that,\n    // we probably got stuck in a strange case of infinite\n    // recursion, so bail out and return NIL.\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    performing_roots = true;\n    h = tos - 2;\n    if (DEBUG) {\n      console.log(\"roots checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n    n = tos - h;\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  // ok to generate these roots take a look at their form\n  // in the case of even and odd exponents here:\n  // http://www.wolframalpha.com/input/?i=roots+x%5E14+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+ax%5E14+%2B+b\n  // http://www.wolframalpha.com/input/?i=roots+x%5E15+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+a*x%5E15+%2B+b\n  getSimpleRoots = function(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n    save();\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; (1 <= ref3 ? m1 <= ref3 : m1 >= ref3); rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n    return restore();\n  };\n\n  roots2 = function() {\n    var k;\n    save();\n    if (DEBUG) {\n      console.log(\"roots2: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    p2 = pop(); // the polynomial variable\n    p1 = pop(); // the polynomial\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      // scan through all the factors\n      // and find the roots of each of them\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n    return restore();\n  };\n\n  roots3 = function() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      n = normalisedCoeff(p2, cadr(p1));\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      n = normalisedCoeff(p2, p1);\n      mini_solve(n);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    stack[tos - 2]    polynomial\n\n  //      stack[tos - 1]    dependent symbol\n\n  //  Output:    stack      roots on stack\n\n  //            (input args are popped first)\n\n  //-----------------------------------------------------------------------------\n\n  // note that for many quadratic, cubic and quartic polynomials we don't\n  // actually end up using the quadratic/cubic/quartic formulas in here,\n  // since there is a chance we factored the polynomial and in so\n  // doing we found some solutions and lowered the degree.\n  mini_solve = function(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    //console.log \"mini_solve >>>>>>>>>>>>>>>>>>>>>>>> tos:\" + tos\n    save();\n    // AX + B, X = -B/A\n    if (n === 2) {\n      //console.log \"mini_solve >>>>>>>>> 1st degree\"\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n    // AX^2 + BX + C, X = (-B +/- (B^2 - 4AC)^(1/2)) / (2A)\n    if (n === 3) {\n      //console.log \"mini_solve >>>>>>>>> 2nd degree\"\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      \n      // B^2\n      push(p4);\n      push_integer(2);\n      power();\n      // 4AC\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      // B^2 - 4AC\n      subtract();\n      //(B^2 - 4AC)^(1/2)\n      push_rational(1, 2);\n      power();\n      //p6 is (B^2 - 4AC)^(1/2)\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract(); // -B + (B^2 - 4AC)^(1/2)\n      \n      // 1/2A\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      //simplify()\n      //rationalize()\n      // tos - 1 now is 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      push(p6);\n      push(p4);\n      add();\n      // tos - 1 now is  B + (B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      negate();\n      // tos - 1 now is  -B -(B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n\n      // 1/2A again\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      //simplify()\n      //rationalize()\n      // tos - 1: 2nd root: (-B - (B^2 - 4AC)^(1/2)) / (2A)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      restore();\n      return;\n    }\n    //if (n == 4)\n    if (n === 4 || n === 5) {\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      p6 = pop(); // D\n      \n      // C - only related calculations\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      // B - only related calculations\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      // A - only related calculations\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      // mixed calculations\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n        //console.log \">>>> A:\" + p3.toString()\n        //console.log \">>>> B:\" + p4.toString()\n        //console.log \">>>> C:\" + p5.toString()\n        //console.log \">>>> D:\" + p6.toString()\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n        //if isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)\n        //  console.log \" *********************************** D0 IS ZERO\"\n\n        // DETERMINANT\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n        // R_DELTA1\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n        // R_Q\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n            push(R_m_b_over_3a); // just same solution three times\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide(); // first solution\n            root_solution = pop();\n            push(root_solution); // pushing two of them on the stack\n            push(root_solution);\n            // second solution here\n            // 4abc\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            // -9a*a*d\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            // -9*b^3\n            push(R_b3);\n            negate();\n            // sum the three terms\n            add();\n            add();\n            // denominator is a*delta0\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            // build the fraction\n            divide();\n            restore();\n            return;\n          }\n        }\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          // R_C\n          push(R_Q);\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        // imaginary parts calculations\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        // first solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        negate(); // second term\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // second solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // third solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n      // See http://www.sscc.edu/home/jdavidso/Math/Catalog/Polynomials/Fourth/Fourth.html\n      // for a description of general shapes and properties of fourth degree polynomials\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n        p7 = pop(); // E\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n          restore();\n          return;\n        }\n        // D - only related calculations\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        // E - only related calculations\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        // DETERMINANT\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply(); // first term 256 a^3 e^3\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply(); // second term -192 a^3 b d e^2\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // third term -128 a^2 c^2 e^2\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fourth term 144 a^2 c d^2 e\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply(); // fifth term -27 a^2 d^4\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // sixth term 144 a b^2 c e^2\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply(); // seventh term -6 a b^2 d^2 e\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // eigth term -80 a b c^2 d e\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply(); // ninth term 18 a b c d^3\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // tenth term 16 a c^4 e\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply(); // eleventh term -4 a c^3 d^2\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // twelveth term -27 b^4 e^2\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // thirteenth term 18 b^3 c d e\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply(); // fourteenth term -4 b^3 d^3\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fifteenth term -4 b^2 c^3 e\n        push(R_b2_c2);\n        push(R_d2);\n        multiply(); // sixteenth term b^2 c^2 d^2\n        \n        // add together the sixteen terms by doing\n        // fifteen adds\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n        // DELTA0\n        push(R_c2); // term one of DELTA0\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply(); // term two of DELTA0\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply(); // term three of DELTA0\n        \n        // add the three terms together\n        add();\n        add();\n        R_DELTA0 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n        // DELTA1\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        // add the five terms together\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n        // p\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n        // q\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n          // convert to depressed quartic\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n          push(R_r);\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n          add();\n          add();\n          add();\n          simplify();\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n          ref3 = depressedSolutions.tensor.elem;\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n\n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n\n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n\n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n\n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n\n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(coeff4)\n\n          add()\n          add()\n          add()\n\n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n\n          roots()\n\n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n\n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n\n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n\n          console.log(\"chosen solution: \" +  R_u)\n\n          push(R_u)\n          negate()\n          R_s = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n\n           * factoring the quartic into two quadratics:\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_t)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_v)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n\n          restore()\n          return\n           */\n          // Ferrari's solution\n          // https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n          // finding the \"m\" in the depressed equation\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n          //R_m = resolventCubicSolutions.tensor.elem[1]\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          // solution1\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution2\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          // solution3\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution4\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n        // Q ---------------------------\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            // D1 under the outer radical\n            push(R_DELTA1);\n            // D1^2 under the inner radical\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            // 4*D0^3 under the inner radical\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            // addition under the inner radical\n            add();\n            // the second radical\n            push_rational(1, 2);\n            power();\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n            // the addition under the outer radical\n            add();\n            // content of outer radical divided by two\n            push_integer(2);\n            divide();\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n            // outer radical calculation: cubic root\n            // now we actually have to find all the roots\n            // because we have to pick the one that makes S != 0\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n            simplify();\n            R_Q = pop();\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && (!isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero))) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n          // S\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          //rationalize()\n          //console.log(\"rationalised: \" + stack[tos-1].toString())\n          //simplify()\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n          // now check if S is zero\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n        // ----------------------------\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n        // first solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // second solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        // third solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // fourth solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    push(p1);\n    yyfloat();\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  // This scanner uses the recursive descent method.\n\n  // The char pointers token_str and scan_str are pointers to the input string as\n  // in the following example.\n\n  //  | g | a | m | m | a |   | a | l | p | h | a |\n  //    ^                   ^\n  //    token_str           scan_str\n\n  // The char pointer token_buf points to a malloc buffer.\n\n  //  | g | a | m | m | a | \\0 |\n  //    ^\n  //    token_buf\n\n  // In the sequence of method invocations for scanning,\n  // first we do the calls for scanning the operands\n  // of the operators of least precedence.\n  // So, since precedence in maths goes something like\n  // (form high to low) exponents, mult/div, plus/minus\n  // so we scan first for terms, then factors, then powers.\n  // That's the general idea, but of course we also have to deal\n  // with things like parens, non-commutative\n  // dot (or inner) product, assignments and tests,\n  // function calls etc.\n  // Note that a^1/2 is, correctly, a/2, not, incorrectly, sqrt(a),\n  // see comment in related test in power.coffee for more about this.\n\n  //  Notes:\n\n  //  Formerly add() and multiply() were used to construct expressions but\n  //  this preevaluation caused problems.\n\n  //  For example, suppose A has the floating point value inf.\n\n  //  Before, the expression A/A resulted in 1 because the scanner would\n  //  divide the symbols.\n\n  //  After removing add() and multiply(), A/A results in nan which is the\n  //  correct result.\n\n  //  The functions negate() and inverse() are used but they do not cause\n  //  problems with preevaluation of symbols.\n  T_INTEGER = 1001;\n\n  T_DOUBLE = 1002;\n\n  T_SYMBOL = 1003;\n\n  T_FUNCTION = 1004;\n\n  T_NEWLINE = 1006;\n\n  T_STRING = 1007;\n\n  T_GTEQ = 1008;\n\n  T_LTEQ = 1009;\n\n  T_EQ = 1010;\n\n  T_NEQ = 1011;\n\n  T_QUOTASSIGN = 1012;\n\n  token = \"\";\n\n  newline_flag = 0;\n\n  meta_mode = 0;\n\n  input_str = 0;\n\n  scan_str = 0;\n\n  token_str = 0;\n\n  token_buf = 0;\n\n  lastFoundSymbol = null;\n\n  symbolsRightOfAssignment = null;\n\n  symbolsLeftOfAssignment = null;\n\n  isSymbolLeftOfAssignment = null;\n\n  scanningParameters = null;\n\n  functionInvokationsScanningStack = null;\n\n  skipRootVariableToBeSolved = false;\n\n  assignmentFound = null;\n\n  // Returns number of chars scanned and expr on stack.\n\n  // Returns zero when nothing left to scan.\n\n  // takes a string\n  scanned = \"\";\n\n  scan = function(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n    //if s==\"y=x\"\n    //  debugger\n    //if s==\"y\"\n    //  debugger\n    //if s==\"i=sqrt(-1)\"\n    //  debugger\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n    return token_str - input_str;\n  };\n\n  // takes a string\n  scan_meta = function(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n      // if it's a := then add a quote\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n      scan_relation();\n      // if it's a := then you have to list\n      // together the quote and its argument\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n      list(3);\n      isSymbolLeftOfAssignment = true;\n      if (codeGen) {\n        // in case of re-assignment, the symbol on the\n        // left will also be in the set of the symbols\n        // on the right. In that case just remove it from\n        // the symbols on the right.\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n        \n        // print out the immediate dependencies\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n        // ok add the local dependencies to the existing\n        // dependencies of this left-value symbol\n\n        // create the exiting dependencies list if it doesn't exist\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n// copy over the new dependencies to the existing\n// dependencies avoiding repetitions\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function() {\n    scan_expression();\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function() {\n    var h;\n    h = tos;\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n      default:\n        scan_term();\n    }\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) { // implicit mul can't cross line\n          scan_str = token_str; // better error display\n          return 0;\n        } else {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  simplify_1_in_products = function(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  // calculate away consecutive constants\n  multiply_consecutive_constants = function(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function() {\n    var h;\n    h = tos;\n    scan_factor();\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        // in case of 1/... then\n        // we scanned the 1, we get rid\n        // of it because otherwise it becomes\n        // an extra factor that wasn't there and\n        // things like\n        // 1/(2*a) become 1*(1/(2*a))\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function(h) {\n    //console.log \"[ as index\"\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    //console.log \"scan_factor token: \" + token\n    firstFactorIsNumber = false;\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      //console.log \"[ as tensor\"\n      //debugger\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n    // after the main initial part of the factor that\n    // we just scanned above,\n    // we can get an arbitrary about of appendages\n    // of the form ...[...](...)...\n    // If the main part is not a number, then these are all, respectively,\n    //  - index references (as opposed to tensor definition) and\n    //  - function calls without an explicit function name\n    //    (instead of subexpressions or parameters of function\n    //    definitions or function calls with an explicit function\n    //    name), respectively\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        //console.log \"( as function call without function name \"\n        scan_function_call_without_function_name();\n      }\n    }\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n        case 'b':\n          push(symbol(METAB));\n          break;\n        case 'x':\n          push(symbol(METAX));\n          break;\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n    //console.log \"found symbol: \" + token_buf\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n      lastFoundSymbol = token_buf;\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    return get_next_token();\n  };\n\n  scan_string = function() {\n    push(new_string(token_buf));\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function() {\n    var functionName, i, l1, n, p, ref2;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n    n = 1; // the parameter number as we scan parameters\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n    lastFoundSymbol = token_buf;\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    get_next_token(); // open parens\n    get_next_token(); // 1st parameter\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        // roots' disappearing variable, if there, is the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // sums' disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // product's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // for's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // defint's disappearing variables can be in positions 2,5,8...\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || (n > 2 && ((n - 2) % 3 === 0)))) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n      // todo refactor this, there are two copies\n      // this catches the case where the \"roots\" variable is not specified\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n          return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\")).test(x);\n        });\n      }\n    }\n    scanningParameters.pop();\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function() {\n    var n;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n    // the function will have to be looked up\n    // at runtime (i.e. we need to evaulate something to find it\n    // e.g. it might be inside a tensor, so we'd need to evaluate\n    // a tensor element access in that case)\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1; // the parameter number as we scan parameters\n    get_next_token(); // left paren\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n    scanningParameters.pop();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  // scan subexpression\n  scan_subexpr = function() {\n    var n;\n    n = 0;\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n    get_next_token();\n    scan_stmt();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_tensor = function() {\n    var n;\n    n = 0;\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n    get_next_token();\n    //console.log \"scanning the next statement\"\n    scan_stmt();\n    n = 1;\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n    //console.log \"building tensor with elements number: \" + n\n    build_tensor(n);\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_error = function(errmsg) {\n    errorMessage = \"\";\n    // try not to put question mark on orphan line\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += \" ? \";\n    while (scanned[input_str] && (scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r')) {\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  // There are n expressions on the stack, possibly tensors.\n\n  // This function assembles the stack expressions into a single tensor.\n\n  // For example, at the top level of the expression ((a,b),(c,d)), the vectors\n  // (a,b) and (c,d) would be on the stack.\n\n  // takes an integer\n  build_tensor = function(n) {\n    var i, l1, ref2;\n    // int i, j, k, ndim, nelem\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function() {\n    newline_flag = 0;\n    while (1) {\n      get_token();\n      if (token !== T_NEWLINE) {\n        break;\n      }\n      newline_flag = 1;\n    }\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  //if token == ')'\n  //  debugger\n  get_token = function() {\n    // skip spaces\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n      scan_str++;\n    }\n    token_str = scan_str;\n    // end of string?\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n    // number?\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // symbol?\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // string ?\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n      while (scanned[scan_str] !== '\"') {\n        //if (scan_str == scanned.length || scanned[scan_str] == '\\n' || scanned[scan_str] == '\\r')\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n        scan_str++;\n      }\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n    // comment?\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n      token = T_NEWLINE;\n      return;\n    }\n    // quote-assignment\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n    // relational operator?\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n    // != operator. It's a little odd because\n    // \"!\" is not a \"not\", which would make things consistent.\n    // (it's used for factorial).\n    // An alternative would be to use \"<>\" but it's not used\n    // a lot in other languages...\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n    // single char token\n    return token = scanned[scan_str++];\n  };\n\n  // both strings\n  update_token_buf = function(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  sgn sign function\n\n  //-----------------------------------------------------------------------------\n  Eval_sgn = function() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  //define X p1\n  yysgn = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n      absval();\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n    */\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  // shape of tensor\n  Eval_shape = function() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n    push(p2);\n    return restore();\n  };\n\n  /*\n   Simplify factorials\n\n  The following script\n\n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n\n  generates\n\n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n\n  Simplify each term to get\n\n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n\n  Then simplify the sum to get\n\n      n\n   -------\n    1 + n\n\n  */\n  // simplify factorials term-by-term\n  Eval_simfac = function() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  //if 1\n  simfac = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n    return restore();\n  };\n\n  //else\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n\n  #endif\n   */\n  simfac_term = function() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n    // if not a product of factors then done\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // push all factors\n    h = tos;\n    p1 = cdr(p1);\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    // keep trying until no more to do\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  // try all pairs of factors\n  yysimfac = function(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n    for (i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n      for (j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n        p2 = stack[j];\n        //  n! / n    ->  (n - 1)!\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  n / n!    ->  1 / (n - 1)!\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  (n + 1) n!  ->  (n + 1)!\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  1 / ((n + 1) n!)  ->  1 / (n + 1)!\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  (n + 1)! / n!  ->  n + 1\n\n        //  n! / (n + 1)!  ->  1 / (n + 1)\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n    return 0;\n  };\n\n  DEBUG_SIMPLIFY = false;\n\n  Eval_simplify = function() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n    // -----------------------\n    // unfortunately for the time being user\n    // specified simplifications are only\n    // run in things which don't contain\n    // integrals.\n    // Doesn't work yet, could be because of\n    // some clobbering as \"transform\" is called\n    // recursively?\n    if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n      Eval();\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"patterns to be checked: \");\n      }\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n            push_symbol(NIL);\n            success = transform(eachSimplification, true);\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n            p1 = stack[tos - 1];\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  // ------------------------\n  simplifyForCodeGeneration = function() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    // in \"codeGen\" mode we completely\n    // eval and simplify the function bodies\n    // because we really want to resolve all\n    // the variables indirections and apply\n    // all the simplifications we can.\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function() {\n    var args, fbody;\n    p1 = pop();\n    // when we do code generation, we proceed to\n    // fully evaluate and simplify the body of\n    // a function, so we resolve all variables\n    // indirections and we simplify everything\n    // we can given the current assignments.\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      // let's simplify the body so we give it a\n      // compact form\n      eval();\n      simplify();\n      p3 = pop();\n      // replace the evaled body\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n    if (Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n      if (count(p2) < count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n    f10();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f10: \" + p1.toString());\n    }\n    f1();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f1: \" + p1.toString());\n    }\n    f2();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f2: \" + p1.toString());\n    }\n    f3();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f3: \" + p1.toString());\n    }\n    f4();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f4: \" + p1.toString());\n    }\n    f5();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f5: \" + p1.toString());\n    }\n    f9();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f9: \" + p1.toString());\n    }\n    simplify_polarRect();\n    if (do_simplify_nested_radicals) {\n      // if there is some de-nesting then\n      // re-run a simplification because\n      // the shape of the expression might\n      // have changed significantly.\n      // e.g. simplify(14^(1/2) - (16 - 4*7^(1/2))^(1/2))\n      // needs some more semplification after the de-nesting.\n      if (simplify_nested_radicals()) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p2);\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero; // null tensor becomes scalar zero\n    }\n    return push(p2);\n  };\n\n  // try rationalizing\n  f1 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // try condensing\n  f2 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    Condense();\n    p2 = pop();\n    if (count(p2) <= count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // this simplifies forms like (A-B) / (B-A)\n  f3 = function() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      // both operands a transpose?\n      if ((car(car(cdr(p1))) === symbol(TRANSPOSE)) && (car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE))) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n          inner();\n        }\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n        transpose();\n        expanding = originalexpanding;\n        p2 = pop();\n        if (count(p2) < count(p1)) {\n          p1 = p2;\n        }\n        if (DEBUG_SIMPLIFY) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  // try expanding denominators\n  f4 = function() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // simplifies trig forms\n  simplify_trig = function() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function() {\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  // if it's a sum then try to simplify each term\n  f9 = function() {\n    var oldp1, oldp2;\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push_integer(0);\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n    denominator();\n    denom = pop();\n    if (isone(denom)) {\n      return;\n    }\n    push(p1);\n    numerator();\n    num = pop();\n    if (isone(num)) {\n      return;\n    }\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n    // if there are no common factors then\n    // bail\n    if (isone(theGCD)) {\n      return;\n    }\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    //simplify()\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // things like 6*(cos(2/9*pi)+i*sin(2/9*pi))\n  // where we have sin and cos, those might start to\n  // look better in clock form i.e.  6*(-1)^(2/9) \n  simplify_rectToClock = function() {\n    //debugger\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function() {\n    push(p1);\n    polarRectAMinusOneBase();\n    Eval();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  polarRectAMinusOneBase = function() {\n    var h;\n    save();\n    p1 = pop();\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      // base we just said is minus 1\n      push(one);\n      negate();\n      // exponent\n      push(caddr(p1));\n      polarRectAMinusOneBase();\n      power();\n      // try to simplify it using polar and rect\n      polar();\n      rect();\n    } else if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        polarRectAMinusOneBase();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n  };\n\n  nterms = function(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    push(p1);\n    somethingSimplified = take_care_of_nested_radicals();\n    // in this paragraph we check whether we can collect\n    // common factors without complicating the expression\n    // in particular we want to avoid \n    // collecting radicals like in this case where\n    // we collect sqrt(2):\n    //   2-2^(1/2) into 2^(1/2)*(-1+2^(1/2))\n    // but we do like to collect other non-radicals e.g.\n    //   17/2+3/2*5^(1/2) into 1/2*(17+3*5^(1/2))\n    // so what we do is we count the powers and we check\n    // which version has the least number of them.\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n    //console.log(\"occurrences of powers in \" + simplificationWithoutCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithoutCondense))\n    //console.log(\"occurrences of powers in \" + simplificationWithCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithCondense))\n    if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n    // we got out result, wrap up\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  take_care_of_nested_radicals = function() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    save();\n    p1 = pop();\n    //console.log(\"take_care_of_nested_radicals p1: \" + p1.toString())\n    if (equal(car(p1), symbol(POWER))) {\n      //console.log(\"ok it's a power \")\n      base = cadr(p1);\n      exponent = caddr(p1);\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        //console.log(\"ok there is a radix with a term inside\")\n        firstTerm = cadr(base);\n        push(firstTerm);\n        take_care_of_nested_radicals();\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n        take_care_of_nested_radicals();\n        pop();\n        //console.log(\"possible double radical term1: \" + firstTerm)\n        //console.log(\"possible double radical term2: \" + secondTerm)\n        numberOfTerms = 0;\n        countingTerms = base;\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n        //console.log(\"number of terms: \" + numberOfTerms)\n        if (numberOfTerms > 2) {\n          //console.log(\"too many terms under outer radix \")\n          push(p1);\n          restore();\n          return false;\n        }\n        // list here all the factors\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          // product of factors\n          secondTermFactor = cdr(secondTerm);\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              //console.log(\"second term factor BIS: \" + car(secondTermFactor).toString())\n              potentialPower = car(secondTermFactor);\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      //console.log(\"common base: \" + innerbase.toString())\n                      commonBases.push(innerbase);\n                    } else {\n\n                    }\n                  }\n                }\n              } else {\n                //console.log(\"no common bases here \")\n                //console.log(\"this one is a power base: \" + innerbase + \" , exponent: \" + innerexponent)\n                termsThatAreNotPowers.push(potentialPower);\n              }\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n          if ((commonInnerExponent == null) && equalq(innerexponent, 1, 2)) {\n            //console.log(\"tackling double radical 2: \" + p1.toString())\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        A = firstTerm;\n        //console.log(\"A: \" + A.toString())\n        push_integer(1);\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"basis with common exponent: \" + i.toString())\n        C = pop();\n        //console.log(\"C: \" + C.toString())\n        push_integer(1);\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"terms that are not powers: \" + i.toString())\n        B = pop();\n        //console.log(\"B: \" + B.toString())\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide(); // 4th coeff\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply(); // 3rd coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C); // 3th coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n        //console.log(\"whole polynomial: \" + stack[tos-1].toString())\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        //console.log(\"invoking roots at recursion level: \" + recursionLevelNestedRadicalsRemoval)\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG_SIMPLIFY) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n        //console.log(\"all solutions: \" + stack[tos-1].toString())\n\n        // exclude the solutions with radicals\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n          if (!Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n        pop(); // popping the tensor with the solutions\n        \n        //console.log(\"possible solutions: \" + possibleSolutions.toString())\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n//console.log(\"checking the one with maximum real part \")\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n          yyfloat();\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        //console.log(\"picked solution: \" + SOLUTION)\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n\n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n\n          lowercase_b = pop()\n\n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 2);\n          power();\n        }\n        //console.log(\"b is: \" + stack[tos-1].toString())\n        lowercase_b = pop();\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n        if (equalq(exponent, 1, 3)) {\n          //console.log(\"a is: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          //console.log(\"a could be: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          //console.log(\"verifying if  \" + possibleNewExpression + \" is positive\")\n          push(possibleNewExpression);\n          real();\n          yyfloat();\n          possibleNewExpressionValue = pop();\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            //console.log(\"... it is positive\")\n            push(possibleNewExpression);\n          } else {\n            //console.log(\"... it is NOT positive\")\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n        // possibleNewExpression is now at top of stack\n\n        //console.log(\"potential new expression: \" + stack[tos-1].toString())\n        p1 = pop();\n        //newExpression = pop()\n        //debugger\n        //push(newExpression)\n        //real()\n        //yyfloat()\n        //possibleNewExpressions.push(newExpression)\n        //realOfPossibleNewExpressions.push(pop().d)\n\n        //whichExpression = realOfPossibleNewExpressions.indexOf(Math.max.apply(Math, realOfPossibleNewExpressions))\n        //p1 = possibleNewExpressions[whichExpression]\n        //console.log(\"final new expression: \" + p1.toString())\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  // Sine function of numerical and symbolic arguments\n  Eval_sin = function() {\n    //console.log \"sin ---- \"\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  //console.log \"sin end ---- \"\n  sine = function() {\n    //console.log \"sine ---- \"\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      // sin of a sum can be further decomposed into\n      //sin(alpha+beta) = sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n    return restore();\n  };\n\n  //console.log \"sine end ---- \"\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n\n  // decompose sum sin(alpha+beta) into\n  // sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n  sine_of_angle_sum = function() {\n    //console.log \"sin of angle sum ---- \"\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n      //console.log \"sin of angle sum end ---- \"\n      p2 = cdr(p2);\n    }\n    return sine_of_angle();\n  };\n\n  //console.log \"sin of angle sum end ---- \"\n  sine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // sine function is antisymmetric, sin(-x) = -sin(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n    // sin(arctan(x)) = x / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n    // values of some famous angles. Many more here:\n    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 90:\n        return push_integer(1);\n      case 270:\n        return push_integer(-1);\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //            exp(x) - exp(-x)\n  //  sinh(x) = ----------------\n  //                   2\n  Eval_sinh = function() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n\n  subst = function() {\n    var expr, i, l1, m1, newExpr, newTensor, oldExpr, ref2, ref3;\n    save();\n    newExpr = pop();\n    oldExpr = pop();\n    if (oldExpr === symbol(NIL) || newExpr === symbol(NIL)) {\n      restore();\n      return;\n    }\n    expr = pop();\n    if (istensor(expr)) {\n      newTensor = alloc_tensor(expr.tensor.nelem);\n      newTensor.tensor.ndim = expr.tensor.ndim;\n      for (i = l1 = 0, ref2 = expr.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        newTensor.tensor.dim[i] = expr.tensor.dim[i];\n      }\n      for (i = m1 = 0, ref3 = expr.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n        push(expr.tensor.elem[i]);\n        push(oldExpr);\n        push(newExpr);\n        subst();\n        newTensor.tensor.elem[i] = pop();\n        check_tensor_dimensions(newTensor);\n      }\n      push(newTensor);\n    } else if (equal(expr, oldExpr)) {\n      push(newExpr);\n    } else if (iscons(expr)) {\n      push(car(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      push(cdr(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      cons();\n    } else {\n      push(expr);\n    }\n    return restore();\n  };\n\n  // 'sum' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the sum at the top of the stack\n  Eval_sum = function() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, p4);\n  };\n\n  // Tangent function of numerical and symbolic arguments\n  Eval_tan = function() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // tan function is antisymmetric, tan(-x) = -tan(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 45:\n      case 225:\n        return push_integer(1);\n      case 135:\n      case 315:\n        return push_integer(-1);\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //             exp(2 x) - 1\n  //  tanh(x) = --------------\n  //             exp(2 x) + 1\n  Eval_tanh = function() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_taylor = function() {\n    // 1st arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // 2nd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    // 3rd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(24); // default number of terms\n    } else {\n      push(p2);\n    }\n    // 4th arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0); // default expansion point\n    } else {\n      push(p2);\n    }\n    return taylor();\n  };\n\n  //define F p1\n  //define X p2\n  //define N p3\n  //define A p4\n  //define C p5\n  taylor = function() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n    push(p1);\n    push(p2);\n    push(p4);\n    subst();\n    Eval();\n    push_integer(1);\n    p5 = pop();\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n      subst();\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n    return restore();\n  };\n\n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* tensor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n\n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n\n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n\n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n\n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n\n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n\n  Limitations\n  -----------\n  n.a.\n\n  Implementation info\n  -------------------\n  Tensors are implemented...\n\n  */\n  // Called from the \"eval\" module to evaluate tensor elements.\n  // p1 points to the tensor operand.\n  Eval_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n\n    //---------------------------------------------------------------------\n\n    //  create a new tensor for the result\n\n    //---------------------------------------------------------------------\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    //---------------------------------------------------------------------\n\n    //  b = Eval(a)\n\n    //---------------------------------------------------------------------\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      //console.log \"push/pop: pushing element a of \" + i\n      push(a[i]);\n      Eval();\n      //console.log \"push/pop: popping into element b of \" + i\n      b[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    //---------------------------------------------------------------------\n\n    //  push the result\n\n    //---------------------------------------------------------------------\n    push(p2);\n    return promote_tensor();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Add tensors\n\n  //  Input:    Operands on stack\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  tensor_plus_tensor = function() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    save();\n    p2 = pop();\n    p1 = pop();\n    // are the dimension lists equal?\n    ndim = p1.tensor.ndim;\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n    // create a new tensor for the result\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    // c = a + b\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = n1 = 0, ref4 = nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n    // push the result\n    push(p3);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  careful not to reorder factors\n\n  //-----------------------------------------------------------------------------\n  tensor_times_scalar = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_tensor = function() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of scalar\n\n  //-----------------------------------------------------------------------------\n  d_scalar_tensor = function() {\n    var a, b, i, l1, ref2;\n    //U **a, **b\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Derivative of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_scalar = function() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    //U **a, **b\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  compare_tensors = function(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Raise a tensor to a power\n\n  //  Input:    p1  tensor\n\n  //      p2  exponent\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  power_tensor = function() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    // first and last dims must be equal\n    k = p1.tensor.ndim - 1;\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p2);\n    n = pop_integer();\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n    if (n < 0) {\n      n = -n;\n      push(p1);\n      inv();\n      p1 = pop();\n    }\n    push(p1);\n    results = [];\n    for (i = m1 = 1, ref3 = n; (1 <= ref3 ? m1 < ref3 : m1 > ref3); i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      inner();\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  copy_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  // Tensors with elements that are also tensors get promoted to a higher rank.\n  promote_tensor = function() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = p1.tensor.elem[0];\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n    k = 0;\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function(p, q) {\n    var i, l1, ref2;\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n    for (i = l1 = 0, ref2 = p.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // If the number of args is odd then the last arg is the default result.\n  // Works like a switch statement. Could also be used for piecewise\n  // functions? TODO should probably be called \"switch\"?\n  Eval_test = function() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n      if (checkResult == null) {\n        // we couldn't determine the result\n        // of a test. This means we can't conclude\n        // anything about the result of the\n        // overall test, so we must bail\n        // with the unevalled test\n        push(orig);\n        return;\n      } else if (checkResult) {\n        // test succesful, we found out output\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        // test unsuccessful, continue to the\n        // next pair of test,value\n        p1 = cddr(p1);\n      }\n    }\n    // no test matched and there was no\n    // catch-all case, so we return zero.\n    return push_integer(0);\n  };\n\n  // we test A==B by first subtracting and checking if we symbolically\n  // get zero. If not, we evaluate to float and check if we get a zero.\n  // If we get another NUMBER then we know they are different.\n  // If we get something else, then we don't know and we return the\n  // unaveluated test, which is the same as saying \"maybe\".\n  Eval_testeq = function() {\n    var checkResult, orig, subtractionResult;\n    // first try without simplifyng both sides\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    // OK so we are doing something tricky here\n    // we are using isZeroLikeOrNonZeroLikeOrUndetermined to check if the result\n    // is zero or not zero or unknown.\n    // isZeroLikeOrNonZeroLikeOrUndetermined has some routines\n    // to determine the zero-ness/non-zero-ness or\n    // undeterminate-ness of things so we use\n    // that here and down below.\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // we didn't get a simple numeric result but\n    // let's try again after doing\n    // a simplification on both sides\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // if we didn't get to a number then we\n    // don't know whether the quantities are\n    // different so do nothing\n    return push(orig);\n  };\n\n  // Relational operators expect a numeric result for operand difference.\n  Eval_testge = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // not definition\n  Eval_not = function() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // inconclusive test on predicate\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      // true -> false\n      return push_integer(0);\n    } else {\n      // false -> true\n      return push_integer(1);\n    }\n  };\n\n  /* and =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Logical-and of predicate expressions.\n\n  */\n  // and definition\n  Eval_and = function() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n    while (iscons(andPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        // found a true, move on to the next predicate\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        // found a false, enough to falsify everything and return\n        push_integer(0);\n        return;\n      }\n    }\n    // We checked all the predicates and none of them\n    // was false. So they were all either true or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns true.\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  // or definition\n  Eval_or = function() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n    while (iscons(orPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        // found a true, enough to return true\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        // found a false, move on to the next predicate\n        orPredicates = cdr(orPredicates);\n      }\n    }\n    // We checked all the predicates and none of them\n    // was true. So they were all either false or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns false.\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // use subtract for cases like A < A + 1\n\n  // TODO you could be smarter here and\n  // simplify both sides only in the case\n  // of \"relational operator: cannot determine...\"\n  // a bit like we do in Eval_testeq\n  cmp_args = function() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n    // try floating point if necessary\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n      yyfloat();\n      Eval();\n      p1 = pop();\n    }\n    //console.log \"comparison: \" + p1.toString()\n    if (isZeroAtomOrTensor(p1)) {\n      //console.log \"comparison isZero \"\n      return 0;\n    }\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      case DOUBLE:\n        //console.log \"comparison p1.d: \" + p1.d\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      default:\n        //console.log \"comparison is null\"\n        t = null;\n    }\n    return t;\n  };\n\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n\n  The expression and free variable are on the stack.\n\n  The argument s is a null terminated list of transform rules.\n\n  For example, see the itab (integrals table)\n\n  Internally, the following symbols are used:\n\n    F  input expression\n\n    X  free variable, i.e. F of X\n\n    A  template expression\n\n    B  result expression\n\n    C  list of conditional expressions\n\n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n\n  */\n  // p1 and p2 are tmps\n\n  //define F p3\n  //define X p4\n  //define A p5\n  //define B p6\n  //define C p7\n  transform = function(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop(); // X i.e. free variable\n    p3 = pop(); // F i.e. input expression\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    // put constants in F(X) on the stack\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n    polyform();\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n    decomp(generalTransform);\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n      for (i = l1 = 0, ref2 = numberOfDecomps; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n    transformationSuccessful = false;\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n        push(theTransform);\n        // replacements of meta variables. Note that we don't\n        // use scan_meta because the pattern is not a string\n        // that we have to parse, it's a tree already.\n        // replace a_ with METAA in the passed transformation\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n        subst();\n        // replace b_ with METAB in the passed transformation\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n        subst();\n        // replace x_ with METAX in the passed transformation\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n        subst();\n        p1 = pop();\n        p5 = car(p1);\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n        */\n        if (f_equals_a(transform_h, generalTransform)) {\n          // successful transformation,\n          // transformed result is in p6\n          transformationSuccessful = true;\n        } else {\n          // the match failed but perhaps we can match\n          // something lower down in the tree, so\n          // let's recurse the tree\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n          transformedTerms = [];\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n          restTerm = p3;\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n            push(secondTerm);\n            push_symbol(NIL);\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n            //if (secondTerm+\"\") == \"eig(A x,transpose(A x))()\"\n            //  debugger\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n            success = transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n          // recreate the tree we were passed,\n          // but with all the terms being transformed\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n            list(transformedTerms.length);\n            p6 = pop(); // \"integrals\" mode\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n          */\n          if (f_equals_a(transform_h, generalTransform)) {\n            // there is a successful transformation,\n            // transformed result is in p6\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n    moveTos(transform_h);\n    if (transformationSuccessful) {\n      //console.log \"transformation successful\"\n      // a transformation was successful\n      push(p6);\n      Eval();\n      p1 = pop();\n      //console.log \"...into: \" + p1\n      transformationSuccessful = true;\n    } else {\n      // transformations failed\n      if (generalTransform) {\n        // result = original expression\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  // search for a METAA and METAB such that F = A\n  f_equals_a = function(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n    for (fea_i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n      for (fea_j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n        // now test all the conditions (it's an and between them)\n        p1 = p7;\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n          p1 = cdr(p1);\n        }\n        if (iscons(p1)) {\n          // conditions are not met,\n          // skip to the next binding of metas\n          continue;\n        }\n        push(p3);\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n        push(p5);\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n        Eval();\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n        subtract();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n          return 1; // yes\n        }\n      }\n    }\n    return 0; // no\n  };\n\n  // Transpose tensor indices\n  Eval_transpose = function() {\n    push(cadr(p1));\n    Eval();\n    // add default params if they\n    // have not been passed\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return transpose();\n  };\n\n  transpose = function() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    // by default p3 is 2 and p2 is 1\n    p3 = pop(); // index to be transposed\n    p2 = pop(); // other index to be transposed\n    p1 = pop(); // what needs to be transposed\n    \n    // a transposition just goes away when\n    // applied to a scalar\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // transposition goes away for identity matrix\n    if ((isplusone(p2) && isplustwo(p3)) || (isplusone(p3) && isplustwo(p2))) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n    // a transposition just goes away when\n    // applied to another transposition with\n    // the same columns to be switched\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n      if ((equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2)) || (equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2)) || ((equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL))) && ((isplusone(p3) && isplustwo(p2)) || (isplusone(p2) && isplustwo(p3))))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n    // if operand is a sum then distribute\n    // (if we are in expanding mode)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // if operand is a multiplication then distribute\n    // (if we are in expanding mode)\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        multiply();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // distribute the transpose of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse as per tranpose rules.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n        transpose();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        //stop(\"transpose: tensor expected, 1st arg is not a tensor\")\n        push_symbol(TRANSPOSE);\n        push(p1);\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n        restore();\n        return;\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    // is it a vector?\n    // so here it's something curious - note how vectors are\n    // not really special two-dimensional matrices, but rather\n    // 1-dimension objects (like tensors can be). So since\n    // they have one dimension, transposition has no effect.\n    // (as opposed as if they were special two-dimensional\n    // matrices)\n    // see also Ran Pan, Tensor Transpose and Its Properties. CoRR abs/1411.1503 (2014)\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = n1 = 0, ref4 = ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n// init tensor index\n    for (i = o1 = 0, ref5 = ndim; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n// copy components from a to b\n    for (i = q1 = 0, ref6 = nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); i = 0 <= ref6 ? ++q1 : --q1) {\n      // swap indices l and m\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n      for (j = r1 = 0, ref7 = ndim; (0 <= ref7 ? r1 < ref7 : r1 > ref7); j = 0 <= ref7 ? ++r1 : --r1) {\n        k = (k * an[j]) + ai[j];\n      }\n      // swap indices back\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n// increment tensor index\n\n      // Suppose the tensor dimensions are 2 and 3.\n// Then the tensor index ai increments as follows:\n// 00 -> 01\n// 01 -> 02\n// 02 -> 10\n// 10 -> 11\n// 11 -> 12\n// 12 -> 00\n      for (j = s1 = ref8 = ndim - 1; (ref8 <= 0 ? s1 <= 0 : s1 >= 0); j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  // Evaluate a user defined function\n\n  //define F p3 # F is the function body\n  //define A p4 # A is the formal argument list\n  //define B p5 # B is the calling argument list\n  //define S p6 # S is the argument substitution list\n\n  // we got here because there was a function invocation and\n  // it's not been parsed (and consequently tagged) as any\n  // system function.\n  // So we are dealing with another function.\n  // The function could be actually defined, or not yet,\n  // so we'll deal with both cases.\n  /* d =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x\n\n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n\n  */\n  Eval_user_function = function() {\n    var bodyAndFormalArguments, h;\n    // Use \"derivative\" instead of \"d\" if there is no user function \"d\"\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n    // normally car(p1) is a symbol with the function name\n    // but it could be something that has to be\n    // evaluated to get to the function definition instead\n    // (e.g. the function is an element of an array)\n    // so we do an eval to sort it all out. \n    push(car(p1));\n    Eval();\n    // we expect to find either the body and\n    // formula arguments, OR, if the function\n    // has not been defined yet, then the\n    // function will just contain its own name, as\n    // all undefined variables do.\n    bodyAndFormalArguments = pop();\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n    p3 = car(cdr(bodyAndFormalArguments)); // p3 is function body F\n    // p4 is the formal argument list\n    // that is also contained here in the FUNCTION node \n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n    // next check is whether evaluation did nothing, so the function is undefined\n    if ((car(bodyAndFormalArguments) !== symbol(FUNCTION)) || (bodyAndFormalArguments === car(p1))) { // p3 is F\n      // leave everything as it was and return\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      return;\n    }\n    // Create the argument substitution list p6(S)\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      // why explicitly Eval the parameters when\n      // the body of the function is\n      // evalled anyways? Commenting it out. All tests pass...\n      //Eval()\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n    if (iscons(p6)) { // p6 is S\n      push(p6);\n      rewrite_args();\n    }\n    //console.log \"rewritten body: \" + stack[tos-1]\n    return Eval();\n  };\n\n  // Rewrite by expanding symbols that contain args\n  rewrite_args = function() {\n    var h, n;\n    n = 0;\n    save();\n    // subst. list which is a list\n    // where each consecutive pair\n    // is what needs to be substituted and with what\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      if (car(p1) === car(p2)) {\n        // rewrite a function in\n        // the body with the one\n        // passed from the paramaters\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        // if there is no match\n        // then no substitution necessary\n        push(car(p1));\n      }\n      // continue recursively to\n      // rewrite the rest of the body\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += rewrite_args();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return n;\n    }\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n    // Here we are in a symbol case\n    // so we need to substitute\n\n    // Check if there is a direct match\n    // of symbols right away\n    p3 = p2;\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n      p3 = cddr(p3);\n    }\n    // Get the symbol's content, if _that_\n    // matches then do the substitution\n    p3 = get_binding(p1);\n    push(p3);\n    if (p1 !== p3) {\n      push(p2);\n      n = rewrite_args();\n      if (n === 0) {\n        pop();\n        push(p1); // restore if not rewritten with arg\n      }\n    }\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n      if (i < 1 || isNaN(i)) {\n        // if the input is nonsensical\n        // just return 0\n        push(zero);\n        return;\n      }\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n    return push(p1);\n  };\n\n  allocatedId = 0;\n\n  alloc_tensor = function(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n    for (i = l1 = 0, ref2 = nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n    p.tensor.allocatedId = allocatedId;\n    //if allocatedId == 9\n    //  debugger\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n\n  /*\n  // garbage collector\n\n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n\n    // tag everything\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n\n    // untag what's used\n\n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n\n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n\n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n\n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n\n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n\n    // collect everything that's still tagged\n\n    free_count = 0\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n\n  void\n  untag(U *p)\n  {\n    int i\n\n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n\n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n\n  // get memory for 100,000 atoms\n\n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n\n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n\n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n\n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n\n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n  */\n  // returns 1 if expr p contains expr q, otherweise returns 0\n  Find = function(p, q) {\n    var i, l1, ref2;\n    i = 0;\n    if (equal(p, q)) {\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (Find(car(p), q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (-1)^(something (but disregard\n  // imaginary units which are in the form (-1)^(1/2))\n  findPossibleClockForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (Find(cadr(p), imaginaryunit)) {\n        //console.log \"found i^fraction \" + p\n        return 1;\n      }\n    }\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      //console.log \"found -1^fraction in \" + p\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleClockForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (e)^(i something)\n  findPossibleExponentialForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return Find(caddr(p), imaginaryunit);\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  $.Find = Find;\n\n  init = function() {\n    var i, l1, ref2;\n    //debugger\n    //console.log \"DOING AN INIT ========================================================================\"\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n    if (flag) { // already initted\n      return;\n    }\n    flag = 1;\n// total clearout of symbol table\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n    return defn();\n  };\n\n  defn_str = [\n    \"version=\\\"\" + version + \"\\\"\",\n    \"e=exp(1)\",\n    \"i=sqrt(-1)\",\n    \"autoexpand=1\",\n    \"assumeRealVariables=1\",\n    \"trange=[-pi,pi]\",\n    \"xrange=[-10,10]\",\n    \"yrange=[-10,10]\",\n    \"last=0\",\n    \"trace=0\",\n    \"forceFixedPrintout=1\",\n    \"maxFixedPrintoutDigits=6\",\n    \"printLeaveEAlone=1\",\n    \"printLeaveXAlone=0\",\n    // cross definition\n    \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\",\n    // curl definition\n    \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\",\n    // div definition\n    \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\",\n    // Note that we use the mathematics / Javascript / Mathematica\n    // convention that \"log\" is indeed the natural logarithm.\n\n    // In engineering, biology, astronomy, \"log\" can stand instead\n    // for the \"common\" logarithm i.e. base 10. Also note that Google\n    // calculations use log for the common logarithm.\n    \"ln(x)=log(x)\"\n  ];\n\n  defn = function() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    //  std_symbol(\"laplace\", LAPLACE)\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE); // tilde so sort puts it after other symbols\n    std_symbol(\"$DRAWX\", DRAWX); // special purpose internal symbols\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    // don't add all these functions to the\n    // symbolsDependencies, clone the original\n    originalCodeGen = codeGen;\n    codeGen = false;\n    for (defn_i = l1 = 0, ref2 = defn_str.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(print_list(stack[tos - 1]));\n      }\n      Eval();\n      pop();\n    }\n    // restore the symbol dependencies as they were before.\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function() {\n    zero = new_integer(0);\n    one = new_integer(1);\n    push_double(1.0);\n    one_as_double = pop();\n    // i is the square root of -1 i.e. -1 ^ 1/2\n    push_symbol(POWER);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_integer(-1);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_rational(1, 2);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    list(3);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    return imaginaryunit = pop(); // must be untagged in gc\n  };\n\n  // Bignum compare\n\n  //  returns\n\n  //  -1    a < b\n\n  //  0    a = b\n\n  //  1    a > b\n  mcmp = function(a, b) {\n    return a.compare(b);\n  };\n\n  // a is a bigint, n is a normal int\n  mcmpint = function(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n    // when generating code, print out\n    // the standard JS Number printout\n    if (codeGen) {\n      return \"\" + d;\n    }\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n      // manipulate the string so that it can be parsed by\n      // Algebrite (something like 1.23e-123 wouldn't cut it because\n      // that would be parsed as 1.23*e - 123)\n      if (printMode === PRINTMODE_LATEX) {\n        // 1.0\\mathrm{e}{-10} looks much better than the plain 1.0e-10\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0\\mathrm{e}{-10}\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0e-10\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      //console.log \"maxFixedPrintoutDigits: \" + maxFixedPrintoutDigits\n      //console.log \"type: \" + typeof(maxFixedPrintoutDigits)\n      //console.log \"toFixed: \" + d.toFixed(maxFixedPrintoutDigits)\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      // remove any trailing zeroes after the dot\n      // see https://stackoverflow.com/questions/26299160/using-regex-how-do-i-remove-the-trailing-zeros-from-a-decimal-number\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      // in case there are only zeroes after the dot, removes the dot too\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n      // we actually want to give a hint to user that\n      // it's a double, so add a trailing \".0\" if there\n      // is no decimal point\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n    return stringRepresentation;\n  };\n\n  // does nothing\n  clear_term = function() {};\n\n  // s is a string here anyways\n  isspace = function(s) {\n    if (s == null) {\n      return false;\n    }\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  count = function(p) {\n    var n;\n    if (iscons(p)) {\n      n = 0;\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  // this probably works out to be\n  // more general than just counting symbols, it can\n  // probably count instances of anything you pass as\n  // first argument but didn't try it.\n  countOccurrencesOfSymbol = function(needle, p) {\n    var n;\n    n = 0;\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n    return n;\n  };\n\n  // returns the total number of elements\n  // in an expression\n  countsize = function(p) {\n    var i, l1, n, ref2;\n    n = 0;\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  //jmp_buf stop_return, draw_stop_return\n\n  // s is a string here\n  stop = function(s) {\n    var message;\n    //if (draw_flag == 2)\n    //  longjmp(draw_stop_return, 1)\n    //else\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    //debugger\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  \n  //longjmp(stop_return, 1)\n\n  // Figuring out dependencies is key to automatically\n  // generating a method signature when generating JS code\n  // from algebrite scripts.\n  // This is important because the user can keep using normal Algebrite\n  // scripting without special notations.\n  // Basically the process consists of figuring out\n  // the \"ground variables\" that are needed to compute each variable.\n  // Now there are two ways of doing this:\n  //   * at parse time\n  //   * after running the scripts\n  // Doing it at parse time means that we can't track simplifications\n  // canceling-out some variables for example. But on the other side\n  // it's very quick and the user can somehow see what the signature is\n  // going to look like (assuming tha code is rather simple), or anyways\n  // is going to easily make sense of the generated signature.\n  // Doing it after execution on the other hand would allow us to see\n  // if some variable cancel-out. But if variables cancel out then\n  // they might do so according to some run-time behaviour that the user\n  // might struggle to keep track of.\n  // So the effort for the user to make sense of the signature in the first case\n  // is similar to the effort of keeping tab of types in a typed language.\n  // While in the second case the effort is similar to running the\n  // code and simplifications in her head.\n\n  // If we just want to compute the dependencies, we don't need to do\n  // anything costly, we don't \"run\" the code and we don't simplify\n  // the code. Just finding the plain dependencies\n  // TODO change the name of this function, as it doesn't just find the\n  // dependencies. It also runs it and generates the JS code.\n  findDependenciesInScript = function(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    // we are going to store the dependencies _of the block as a whole_\n    // so all affected variables in the whole block are lumped\n    // together, and same for the variable that affect those, we\n    // lump them all together.\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n    // parse the input. This collects the\n    // dependency information\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      indexOfPartRemainingToBeParsed += n;\n    }\n    testableString = \"\";\n    // print out all local dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n    testableString += \"All local dependencies: \";\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n        testableString += i + \", \";\n      }\n      testableString += \"; \";\n    }\n    testableString += \". \";\n    // print out the symbols with re-assignments:\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n    testableString += \"Symbols with reassignments: \";\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // print out the symbols that appear in expressions without assignments\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n    testableString += \"Symbols in expressions without assignments: \";\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // ALL Algebrite code is affected by any pattern changing\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n    // print out all global dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        init();\n      }\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          codeGen = false;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n          recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n            testableString += i + \", \";\n          }\n          testableString += \"; \";\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          // we really want to make an extra effort\n          // to generate simplified code, so\n          // run a \"simplify\" on the content of each\n          // variable that we are generating code for.\n          // Note that the variable\n          // will still point to un-simplified structures,\n          // we only simplify the generated code.\n          push(get_binding(usr_symbol(key)));\n          // Since we go and simplify all variables we meet,\n          // we have to replace each variable passed as a parameter\n          // with something entirely new, so that there is no chance\n          // that it might evoke previous values in the external scope\n          // as in this case:\n          //  a = 2\n          //  f(a) = a+1+b\n          // we don't want 'a' in the body of f to be simplified to 2\n          // There are two cases: 1) the variable actually was already in\n          // the symbol table, in which case there is going to be this new\n          // one prepended with AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE, and\n          // we'll have to remove up this variable later.\n          // OR 2) the variable wasn't already in the symbol table, in which\n          // case we directly create this one, which means that we'll have\n          // to rename it later to the correct name without the prepended\n          // part.\n          replacementsFrom = [];\n          replacementsTo = [];\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n              subst();\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n            errorMessage = error + \"\";\n            //debugger\n            init();\n          }\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; (0 <= ref2 ? t1 < ref2 : t1 > ref2); indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            //console.log \"replacing back \" + replacementsTo[indexOfEachReplacement] + \" into: \" + replacementsFrom[indexOfEachReplacement]\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n            subst();\n          }\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            // we have to get all the variables used on the right side\n            // here. I.e. to print the arguments it's better to look at the\n            // actual method body after simplification.\n            userVariablesMentioned = [];\n            collectUserSymbols(toBePrinted, userVariablesMentioned);\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              // remove all native functions from the\n              // parameters as well.\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              // remove the variable that are not in the dependency list\n              // i.e. only allow the variables that are in the dependency list\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n                // eliminate the last \", \" for printout clarity\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n    // eliminate the last new line\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    // cleanup\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n    // recursive dependencies can only be descended if the variable is not bound to a parameter\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n    chainBeingChecked.push(variableToBeChecked);\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      // end case: the passed variable has no dependencies\n      // so there is nothing else to do\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n      // recursion case: we have to dig deeper\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n        // check that there is no recursion in dependencies\n        // we do that by keeping a list of variables that\n        // have already been \"fleshed-out\". If we encounter\n        // any of those \"fleshed-out\" variables while\n        // fleshing out, then there is a cycle \n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n          cyclesDescription = \"\";\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n            cyclesDescription += k + \" --> \";\n          }\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n          //if DEBUG then console.log \"    --> cycle through \" + i\n          // we want to flesh-out i but it's already been\n          // fleshed-out, just add it to the variables\n          // with cycles and move on\n          // todo refactor this, there are two copies of these two lines\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          // flesh-out i recursively\n          recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n          chainBeingChecked.pop();\n        }\n      }\n      //variablesAlreadyFleshedOut.pop()\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  // parses and runs one statement/expression at a time\n  inited = false;\n\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    //console.log \"theErrorMessage: \" + theErrorMessage\n    return theErrorMessage;\n  };\n\n  // there are around a dozen different unicodes that\n  // represent some sort of middle dot, let's catch the most\n  // common and turn them into what we can process\n  normaliseDots = function(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function(stringToBeRun, generateLatex = false) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n    timeStart = new Date().getTime();\n    //stringToBeRun = stringToBeRun + \"\\n\"\n    stringToBeRun = normaliseDots(stringToBeRun);\n    //console.log \"run running: \" + stringToBeRun\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n    if (!inited) {\n      inited = true;\n      init();\n    }\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    while (1) {\n      try {\n        // while we can keep scanning commands out of the\n        // passed input AND we can execute them...\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        //debugger\n        allReturnedPlainStrings += error.message;\n        if (generateLatex) {\n          //debugger\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      // if debug mode then print the source text\n\n      //if (equaln(get_binding(symbol(TRACE)), 1)) {\n      //  for (i = 0 i < n i++)\n      //    if (s[i] != '\\r')\n      //      printchar(s[i])\n      //  if (s[n - 1] != '\\n') # n is not zero, see above\n      //    printchar('\\n')\n      //}\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      //debugger\n      errorWhileExecution = false;\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        //console.log \"emitted string after top_level_eval(): >\" + stringsEmittedByUserPrintouts + \"<\"\n        //console.log \"allReturnedPlainStrings string after top_level_eval(): >\" + allReturnedPlainStrings + \"<\"\n        p2 = pop();\n        check_stack();\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n        // if the return value is nil there isn't much point\n        // in adding \"nil\" to the printout\n        if (p2 === symbol(NIL)) {\n          //collectedPlainResult = stringsEmittedByUserPrintouts\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          //console.log \"emitted string before collectPlainStringFromReturnValue: >\" + stringsEmittedByUserPrintouts + \"<\"\n          //console.log \"allReturnedPlainStrings string before collectPlainStringFromReturnValue: >\" + allReturnedPlainStrings + \"<\"\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n          //console.log \"collectedPlainResult: >\" + collectedPlainResult + \"<\"\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n        //alert collectedPlainResult\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n          print2dascii(p2);\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n        init();\n      }\n    }\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  // cannot reference symbols yet\n\n  // returns nil on stack if no result to print\n  top_level_eval = function() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n    // \"draw\", \"for\" and \"setq\" return \"nil\", there is no result to print\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n    // update \"last\" to contain the last result\n    set_binding(symbol(LAST), evalledArgument);\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      bake();\n      evalledArgument = top();\n    }\n    // If user asked explicitly asked to evaluate \"i\" or \"j\" and\n    // they represent the imaginary unit (-1)^(1/2), then \n    // show (-1)^(1/2).\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {\n\n    // In all other cases, replace all instances of (-1)^(1/2) in the result\n    // with the symbol \"i\" or \"j\" depending on which one\n    // represents the imaginary unit\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return subst();\n    }\n  };\n\n  check_esc_flag = function() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  // this is called when the whole notebook is re-run\n  // so we get the chance of clearing the whole state from\n  // scratch.\n  // In practice, the state we need to clear that persists\n  // across blocks are only the patterns, so\n  // just eject those.\n  clearAlgebraEnvironment = function() {\n    //console.log \"CLEARING clearAlgebraEnvironment =============================================================\"\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n    // return findDependenciesInScript(codeFromAlgebraBlock, true)[6]\n\n    // TODO this part below is duplicated from computeResultsAndJavaScriptFromAlgebra\n    //      ...should refactor.\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + (new Date()));\n    }\n    // we start \"clean\" each time:\n    // clear all the symbols and then re-define\n    // the \"starting\" symbols.\n\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    //debugger\n    [testableStringIsIgnoredHere, result, code, readableSummaryOfCode, latexResult, errorMessage, dependencyInfo] = findDependenciesInScript(codeFromAlgebraBlock);\n    called_from_Algebra_block = false;\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n    // remove empty results altogether from latex output, which happens\n    // for example for assignments to variables or\n    // functions definitions\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n    //console.log \"code: \" + code\n    //console.log \"result: \" + result\n    //console.log \"latexResult: \" + latexResult\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return {\n      //code: \"// no code generated yet\\n//try again later\"\n      //code: \"console.log('some passed code is run'); window.something = 1;\"\n      code: code,\n      // TODO temporarily pass latex in place of standard result too\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n\n  //   _______\n  //  |  | <- stack\n  //  |  |\n  //  |_______|\n  //  |  | <- stack + tos\n  //  |  |\n  //  |  |\n  //  |_______|\n  //  |  | <- frame\n  //  |_______|\n  //      <- stack + TOS\n\n  //  The stack grows from low memory towards high memory. This is so that\n  //  multiple expressions can be pushed on the stack and then accessed as an\n  //  array.\n\n  //  The frame area holds local variables and grows from high memory towards\n  //  low memory. The frame area makes local variables visible to the garbage\n  //  collector.\n  tos = 0;\n\n  // p is a U\n  nil_symbols = 0;\n\n  push = function(p) {\n    if (p == null) {\n      debugger;\n    }\n    if (p.isZero != null) {\n      debugger;\n    }\n    //console.log \"pushing \"\n    //console.log print_list(p)\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n    //if nil_symbols == 111\n    //  debugger\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n    return stack[tos++] = p;\n  };\n\n  // returns a U\n  moveTos = function(stackPos) {\n    if (tos <= stackPos) {\n      // we are moving the stack pointer\n      // \"up\" the stack (as if we were doing a push)\n      tos = stackPos;\n      return;\n    }\n    // we are moving the stack pointer\n    // \"down\" the stack i.e. as if we were\n    // doing a pop, we can zero-\n    // out all the elements that we pass\n    // so we can reclaim the memory\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function() {\n    return stack[tos - 1];\n  };\n\n  pop = function() {\n    var elementToBeReturned;\n    //popsNum++\n    //console.log \"pop #\" + popsNum\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n    elementToBeReturned = stack[--tos];\n    \n    // give a chance to the garbage\n    // collection to reclaim space\n    // This is JS-specific, it would\n    // actually make the C garbage\n    // collector useless.\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  // n is an integer\n  push_frame = function(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    results = [];\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n    return results;\n  };\n\n  // n is an integer\n  pop_frame = function(n) {\n    frame += n;\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function() {\n    frame -= 10;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  swap = function() {\n    var p, q;\n    //U *p, *q\n    // p and q are both Us\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  dupl = function() {\n    var p;\n    //U *p\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n\n  $.swap = swap;\n\n  $.restore = restore;\n\n  $.save = save;\n\n  $.push = push;\n\n  $.pop = pop;\n\n  // The symbol table is a simple array of struct U.\n\n  // put symbol at index n\n  Eval_symbolsinfo = function() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n    if (symbolsinfoToBePrinted !== \"\") {\n      return push(new_string(symbolsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n    return symbolsinfoToBePrinted;\n  };\n\n  // s is a string, n is an int\n  // TODO: elsewhere when we create a symbol we\n  // rather prefer to create a new entry. Here we just\n  // reuse the existing one. If that can never be a problem\n  // then explain why, otherwise do create a new entry.\n  std_symbol = function(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n    if (p == null) {\n      debugger;\n    }\n    p.printname = s;\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  // symbol lookup, or symbol creation if symbol doesn't exist yet\n  // this happens often from the scanner. When the scanner sees something\n  // like myVar = 2, it create a tree (SETQ (\"myVar\" symbol as created/looked up here (2)))\n  // user-defined functions also have a usr symbol.\n\n  // Note that some symbols like, say, \"abs\",\n  // are picked up by the scanner directly as keywords,\n  // so they are not looked up via this.\n  // So in fact you could redefine abs to be abs(x) = x\n  // but still abs would be picked up by the scanner as a particular\n  // node type and calls to abs() will be always to the \"native\" abs\n\n  // Also note that some symbols such as \"zero\" are (strangely) not picked up by\n  // the scanner as special nodes, rather they are identified as keywords\n  // (e.g. not redefinable) at time of symbol lookup (in Eval_sym) and\n  // evalled, where eval has a case for ZERO.\n\n  // Also note that there are a number of symbols, such as a,b,c,x,y,z,...\n  // that are actually created by std_symbols.\n  // They are not special node types (like abs), they are normal symbols\n  // that are looked up, but the advantage is that since they are often\n  // used internally by algebrite, we create the symbol in advance and\n  // we can reference the symbol entry in a clean way\n  // (e.g. symbol(SYMBOL_X)) rather than\n  // by looking up a string.\n\n  // s is a string\n  usr_symbol = function(s) {\n    var i, l1, ref2;\n    //console.log \"usr_symbol of \" + s\n    //if s == \"aaa\"\n    //  debugger\n\n    // find either the existing symbol, or if we\n    // reach an empty symbol (printname == \"\") then\n    // re-use that location.\n    i = 0;\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        // found the symbol\n        return symtab[i];\n      }\n      if (symtab[i].printname === \"\") {\n        // found an entry in the symbol table\n        // with no printname, exit the loop\n        // and re-use this location\n        break;\n      }\n    }\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    // say that we just created the symbol\n    // then, binding[the new symbol entry]\n    // by default points to the symbol.\n    // So the value of an unassigned symbol will\n    // be just its name.\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  // get the symbol's printname\n\n  // p is a U\n  get_printname = function(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    return p.printname;\n  };\n\n  // p and q are both U\n  // there are two Us at play here. One belongs to the\n  // symtab array and is the variable name.\n  // The other one is the U with the content, and that\n  // one will go in the corresponding \"binding\" array entry.\n  set_binding = function(p, q) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"setting binding of \" + p.toString() + \" to: \" + q.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  // p is a U\n  get_binding = function(p) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"getting binding of \" + p.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n    //if indexFound == 139\n    //  debugger\n    //if indexFound == 137\n    //  debugger\n    return binding[indexFound];\n  };\n\n  // the concept of user symbol is a little fuzzy\n  // beucase mathematics is full of symbols that actually\n  // have a special meaning, e.g. e,i,I in some cases j...\n  is_usr_symbol = function(p) {\n    var theSymnum;\n    if (p.k !== SYM) {\n      return false;\n    }\n    theSymnum = symnum(p);\n    // see \"defs\" file for the naming of the symbols\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n    return false;\n  };\n\n  // get symbol's number from ptr\n  // p is U\n  lookupsTotal = 0;\n\n  symnum = function(p) {\n    var indexFound;\n    lookupsTotal++;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    indexFound = symtab.indexOf(p);\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n    //if lookupsTotal == 21\n    //  debugger\n    //if indexFound == 79\n    //  debugger\n    return indexFound;\n  };\n\n  // push indexed symbol\n\n  // k is an int\n  push_symbol = function(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function() {\n    var i, l1, ref2, ref3, results;\n// we can clear just what's assignable.\n// everything before NIL is not assignable,\n// so there is no need to clear it.\n    results = [];\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      // stop at the first empty\n      // entry that is not reclaimable\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n    return results;\n  };\n\n  //symtab[i].printname = \"\"\n  //binding[i] = symtab[i]\n\n  // collect all the variables in a tree\n  collectUserSymbols = function(p, accumulator = []) {\n    var i, l1, ref2;\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n      return;\n    }\n    while (iscons(p)) {\n      collectUserSymbols(car(p), accumulator);\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n\n  $.set_binding = set_binding;\n\n  $.usr_symbol = usr_symbol;\n\n  $.symbolsinfo = symbolsinfo;\n\n  $.collectUserSymbols = collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    // now its in the stack\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      // hey look its a U\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function(argu) {\n    var data, error;\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return data;\n  };\n\n  // exec handles the running ia JS of all the algebrite\n  // functions. The function name is passed in \"name\" and\n  // the corresponding function is pushed at the top of the stack\n  exec = function(name, ...argus) {\n    var argu, error, fn, l1, len, result;\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return result;\n  };\n\n  $.exec = exec;\n\n  $.parse = parse;\n\n  (function() {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n    return results;\n  })();\n\n  freeze = function() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n    for (i = l1 = 0, ref2 = symtab.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      //if symtab[i].printname == \"\"\n      //  if isSymbolReclaimable[i] == false\n      //    break\n      //  else\n      //    continue\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n    // just clone them\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit] = frozen;\n//clear_symbols()\n    for (i = l1 = 0, ref2 = frozenSymbols.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = print_list(symtab[i]);\n      bindingi = print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n    return frozenHash;\n  };\n\n}).call(this);\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","window.Algebrite  = require('algebrite')\n"],"names":["$","ABS","ADD","ADJ","AND","APPROXRATIO","ARCCOS","ARCCOSH","ARCSIN","ARCSINH","ARCTAN","ARCTANH","ARG","ASSUME_REAL_VARIABLES","ATOMIZE","AUTOEXPAND","BAKE","BESSELJ","BESSELY","BINDING","BINOMIAL","BINOM_check_args","BUF","C1","C2","C3","C4","C5","C6","CEILING","CHECK","CHOOSE","CIRCEXP","CLEAR","CLEARALL","CLEARPATTERNS","CLOCK","COEFF","COFACTOR","CONDENSE","CONJ","CONS","CONTRACT","COS","COSH","Condense","DEBUG","DEBUG_ABS","DEBUG_ARG","DEBUG_CLOCKFORM","DEBUG_IMAG","DEBUG_IS","DEBUG_MULTIPLY","DEBUG_POWER","DEBUG_RATIONALIZE","DEBUG_RECT","DEBUG_SIMPLIFY","DECOMP","DEFINT","DEGREE","DENOMINATOR","DERIVATIVE","DET","DET_check_arg","DIM","DIRAC","DIVISORS","DO","DOT","DOUBLE","DRAW","DRAWX","DSOLVE","E","EIGEN","EIGENVAL","EIGENVEC","EIG_N","EIG_check_arg","EIG_yydd","EIG_yyqq","ERF","ERFC","EVAL","EXP","EXPAND","EXPCOS","EXPSIN","Eval","Eval_Eval","Eval_abs","Eval_add","Eval_adj","Eval_and","Eval_approxratio","Eval_arccos","Eval_arccosh","Eval_arcsin","Eval_arcsinh","Eval_arctan","Eval_arctanh","Eval_arg","Eval_besselj","Eval_bessely","Eval_binding","Eval_binomial","Eval_ceiling","Eval_check","Eval_choose","Eval_circexp","Eval_clear","Eval_clearall","Eval_clearpatterns","Eval_clock","Eval_coeff","Eval_cofactor","Eval_condense","Eval_conj","Eval_cons","Eval_contract","Eval_cos","Eval_cosh","Eval_decomp","Eval_defint","Eval_degree","Eval_denominator","Eval_derivative","Eval_det","Eval_dim","Eval_dirac","Eval_divisors","Eval_do","Eval_dsolve","Eval_eigen","Eval_eigenval","Eval_eigenvec","Eval_erf","Eval_erfc","Eval_exp","Eval_expand","Eval_expcos","Eval_expsin","Eval_factor","Eval_factorial","Eval_factorpoly","Eval_filter","Eval_float","Eval_floor","Eval_for","Eval_function_reference","Eval_gamma","Eval_gcd","Eval_hermite","Eval_hilbert","Eval_imag","Eval_index","Eval_inner","Eval_integral","Eval_inv","Eval_invg","Eval_isinteger","Eval_isprime","Eval_laguerre","Eval_lcm","Eval_leading","Eval_legendre","Eval_log","Eval_lookup","Eval_mod","Eval_multiply","Eval_noexpand","Eval_not","Eval_nroots","Eval_number","Eval_numerator","Eval_operator","Eval_or","Eval_outer","Eval_pattern","Eval_patternsinfo","Eval_polar","Eval_power","Eval_predicate","Eval_prime","Eval_print","Eval_print2dascii","Eval_printcomputer","Eval_printhuman","Eval_printlatex","Eval_printlist","Eval_product","Eval_quote","Eval_quotient","Eval_rank","Eval_rationalize","Eval_real","Eval_rect","Eval_roots","Eval_round","Eval_setq","Eval_sgn","Eval_shape","Eval_silentpattern","Eval_simfac","Eval_simplify","Eval_sin","Eval_sinh","Eval_sqrt","Eval_stop","Eval_subst","Eval_sum","Eval_sym","Eval_symbolsinfo","Eval_tan","Eval_tanh","Eval_taylor","Eval_tensor","Eval_test","Eval_testeq","Eval_testge","Eval_testgt","Eval_testle","Eval_testlt","Eval_transpose","Eval_unit","Eval_user_function","Eval_zero","Evalpoly","FACTOR","FACTORIAL","FACTORPOLY","FILTER","FLOATF","FLOOR","FOR","FORCE_FIXED_PRINTOUT","FUNCTION","Find","GAMMA","GCD","HERMITE","HILBERT","IMAG","INDEX","INNER","INTEGRAL","INV","INVG","INV_check_arg","INV_decomp","ISINTEGER","ISPRIME","LAGUERRE","LAST","LAST_2DASCII_PRINT","LAST_FULL_PRINT","LAST_LATEX_PRINT","LAST_LIST_PRINT","LAST_PLAIN_PRINT","LAST_PRINT","LCM","LEADING","LEGENDRE","LOG","LOOKUP","M","MAXDIM","MAXPRIMETAB","MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES","MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE","MAX_FIXED_PRINTOUT_DIGITS","MAX_PROGRAM_SIZE","MEQUAL","METAA","METAB","METAX","MLENGTH","MOD","MSIGN","MULTIPLY","MZERO","N","NIL","NOT","NROOTS","NROOTS_ABS","NROOTS_DELTA","NROOTS_EPSILON","NROOTS_RANDOM","NROOTS_YMAX","NROOTS_divpoly","NSYM","NUM","NUMBER","NUMERATOR","OPERATOR","OR","OUTER","PATTERN","PATTERNSINFO","PI","POLAR","POWER","PRIME","PRINT","PRINT2DASCII","PRINTFULL","PRINTLATEX","PRINTLIST","PRINTMODE_2DASCII","PRINTMODE_COMPUTER","PRINTMODE_HUMAN","PRINTMODE_LATEX","PRINTMODE_LIST","PRINTOUTRESULT","PRINTPLAIN","PRINT_LEAVE_E_ALONE","PRINT_LEAVE_X_ALONE","PRODUCT","QUOTE","QUOTIENT","RANK","RATIONALIZE","REAL","ROOTS","ROUND","SECRETX","SELFTEST","SETQ","SGN","SHAPE","SILENTPATTERN","SIMPLIFY","SIN","SINH","SPACE_BETWEEN_COLUMNS","SPACE_BETWEEN_ROWS","SQRT","STOP","STR","SUBST","SUM","SYM","SYMBOLSINFO","SYMBOL_A","SYMBOL_A_UNDERSCORE","SYMBOL_B","SYMBOL_B_UNDERSCORE","SYMBOL_C","SYMBOL_D","SYMBOL_I","SYMBOL_IDENTITY_MATRIX","SYMBOL_J","SYMBOL_N","SYMBOL_R","SYMBOL_S","SYMBOL_T","SYMBOL_X","SYMBOL_X_UNDERSCORE","SYMBOL_Y","SYMBOL_Z","TAN","TANH","TAYLOR","TENSOR","TEST","TESTEQ","TESTGE","TESTGT","TESTLE","TESTLT","TIMING_DEBUGS","TOS","TRACE","TRANSPOSE","T_DOUBLE","T_EQ","T_FUNCTION","T_GTEQ","T_INTEGER","T_LTEQ","T_NEQ","T_NEWLINE","T_QUOTASSIGN","T_STRING","T_SYMBOL","U1","UNIT","USR_SYMBOLS","VERSION","YMAX","YYE","YYRECT","ZERO","__emit_char","__emit_str","__factor_add","__factorial","__is_negative","__is_radical_number","__lcm","__legendre","__legendre2","__legendre3","__normalize_radical_factors","__rationalize_tensor","_print","abs","absValFloat","absval","absval_tensor","add","addSymbolLeftOfAssignment","addSymbolRightOfAssignment","add_all","add_factor_to_accumulator","add_numbers","add_terms","addf","adj","alloc_tensor","allocatedId","any_denominators","approxAll","approxLogs","approxLogsOfRationals","approxOneRatioOnly","approxRadicals","approxRadicalsOfRationals","approxRationalsOfLogs","approxRationalsOfPowersOfE","approxRationalsOfPowersOfPI","approxRationalsOfRadicals","approxSineOfRationalMultiplesOfPI","approxSineOfRationals","approxTrigonometric","approx_just_an_integer","approx_logarithmsOfRationals","approx_nothingUseful","approx_radicalOfRatio","approx_ratioOfRadical","approx_rationalOfE","approx_rationalOfPi","approx_rationalsOfLogarithms","approx_sine_of_pi_times_rational","approx_sine_of_rational","approxratioRecursive","arccos","arccosh","arcsin","arcsinh","arctan","arctanh","areunivarpolysfactoredorexpandedform","arg","arglist","assignmentFound","avoidCalculatingPowersIntoArctans","bake","bake_poly","bake_poly_term","besselj","bessely","bigInt","bignum_factorial","bignum_float","bignum_power_number","bignum_scan_float","bignum_scan_integer","bignum_truncate","binding","binomial","buffer","build_tensor","caaddr","caadr","caar","cadaddr","cadadr","cadar","caddaddr","caddadr","caddar","caddddr","cadddr","caddr","cadr","called_from_Algebra_block","car","cdaddr","cdadr","cdar","cddaddr","cddar","cdddaddr","cddddr","cdddr","cddr","cdr","ceiling","chainOfUserSymbolsNotFunctionsBeingEvaluated","charTabIndex","chartab","checkFloatHasWorkedOutCompletely","check_esc_flag","check_stack","check_tensor_dimensions","choose","choose_check_args","circexp","clearAlgebraEnvironment","clearRenamedVariablesToAvoidBindingToExternalScope","clear_symbols","clear_term","clearall","clockform","cmpGlyphs","cmp_args","cmp_expr","cmp_terms","cmp_terms_count","codeGen","coeff","cofactor","collectLatexStringFromReturnValue","collectUserSymbols","combine_factors","combine_gammas","combine_terms","compareState","compare_numbers","compare_rationals","compare_tensors","compatible","computeDependenciesFromAlgebra","computeResultsAndJavaScriptFromAlgebra","compute_fa","conjugate","cons","consCount","contract","convert_bignum_to_double","convert_rational_to_double","copy_tensor","cosine","cosine_of_angle","cosine_of_angle_sum","count1","countOccurrencesOfSymbol","count_denominators","counter","countsize","d_scalar_scalar","d_scalar_scalar_1","d_scalar_tensor","d_tensor_scalar","d_tensor_tensor","dabs","darccos","darccosh","darcsin","darcsinh","darctan","darctanh","dbesselj0","dbesseljn","dbessely0","dbesselyn","dcos","dcosh","dd","decomp","decomp_product","decomp_sum","defineSomeHandyConstants","define_user_function","defn","defn_str","degree","denominator","derf","derfc","derivative","derivative_of_integral","det","determinant","detg","dfunction","dhermite","dirac","display1","display_flag","displaychar","divide","divide_numbers","divisors","divisors_onstack","divpoly","dlog","do_clearPatterns","do_clearall","do_simplify_nested_radicals","dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication","dotprod_unicode","doubleToReasonableString","dpow","dpower","dproduct","draw_flag","draw_stop_return","dsgn","dsin","dsinh","dsum","dtan","dtanh","dupl","eigen","elelmIndex","elem","emit_denominator","emit_denominators","emit_expr","emit_factor","emit_factorial_function","emit_flat_tensor","emit_fraction","emit_function","emit_index_function","emit_multiply","emit_number","emit_numerators","emit_numerical_fraction","emit_power","emit_string","emit_subexpr","emit_symbol","emit_tensor","emit_tensor_inner","emit_term","emit_top_expr","emit_unsigned_expr","emit_x","equal","equaln","equalq","erfc","errorMessage","esc_flag","evaluatingAsFloats","evaluatingPolar","exec","expand","expand_get_A","expand_get_AF","expand_get_B","expand_get_C","expand_get_CF","expand_tensor","expanding","expcos","exponential","expr_level","expsin","f1","f10","f2","f3","f4","f5","f9","f_equals_a","factor","factor_a","factor_again","factor_b","factor_number","factor_small_number","factor_term","factorial","factorpoly","factors","fill_buf","filter","filter_main","filter_sum","filter_tensor","findDependenciesInScript","findPossibleClockForm","findPossibleExponentialForm","findroot","fixup_fraction","fixup_power","flag1","floatToRatioRoutine","fmt_index","fmt_level","fmt_x","frame","freeze","functionInvokationsScanningStack","gamma","gamma_of_sum","gammaf","gcd","gcd_main","gcd_numbers","gcd_polys","gcd_powers_with_same_base","gcd_product_product","gcd_product_sum","gcd_sum","gcd_sum_product","gcd_sum_sum","gen","getSimpleRoots","getStateHash","get_binding","get_factor_from_complex_root","get_factor_from_real_root","get_innerprod_factors","get_next_token","get_printname","get_size","get_token","getdisplaystr","glyph1","gp","guess","hasImaginaryCoeff","hasNegativeRationalExponent","hash_addition","hash_function","hash_multiplication","hash_power","hashcode_values","hashed_itab","hermite","hilbert","i11","imag","imaginaryunit","index_function","init","initNRoots","inited1","inner","inner_f","input_str","integral","integral_of_form","integral_of_product","integral_of_sum","inv","inverse","invert_number","invg","isNumberOneOverSomething","isNumericAtom","isNumericAtomOrTensor","isSimpleRoot","isSmall","isSymbolLeftOfAssignment","isSymbolReclaimable","isZeroAtom","isZeroAtomOrTensor","isZeroLikeOrNonZeroLikeOrUndetermined","isZeroTensor","is_denominator","is_factor","is_small_integer","is_square_matrix","is_usr_symbol","isadd","isalnumorunderscore","isalpha","isalphaOrUnderscore","iscomplexnumber","iscomplexnumberdouble","iscons","isdenominator","isdigit","isdouble","iseveninteger","isfactor","isfactorial","isfloating","isfraction","isidentitymatrix","isimaginarynumber","isimaginarynumberdouble","isimaginaryunit","isinnerordot","isinteger","isintegerfactor","isintegerorintegerfloat","isinv","iskeyword","isminusone","isminusoneoversqrttwo","isminusoneovertwo","isminussqrtthreeovertwo","ismultiply","isnegative","isnegativenumber","isnegativeterm","isnonnegativeinteger","isnpi","isone","isoneover","isoneoversqrttwo","isoneovertwo","isplusone","isplustwo","ispolyexpandedform","ispolyexpandedform_expr","ispolyexpandedform_factor","ispolyexpandedform_term","ispolyfactoredorexpandedform","ispolyfactoredorexpandedform_factor","ispolyfactoredorexpandedform_power","isposint","ispositivenumber","ispower","isquarterturn","isrational","isspace","issqrtthree","issqrtthreeovertwo","isstr","issymbol","issymbolic","istensor","istranspose","isunderscore","isunivarpolyfactoredorexpandedform","itab","italu_hashcode","j11","laguerre","laguerre2","lastFoundSymbol","latexErrorSign","lcm","leading","legendre","length","lessp","level","list","listLength","logarithm","logbuf","lookupsTotal","lu_decomp","madd","makePositive","makeSignSameAs","make_hashed_itab","mask","mcmp","mcmpint","mdiv","mdivrem","meta_mode","mgcd","mini_solve","mint","mmod","mmul","mod","monic","move","moveTos","mp_clr_bit","mp_denominator","mp_numerator","mp_set_bit","mpow","mprime","mroot","mshiftright","msub","mtotal","multinomial_sum","multiply","multiply_all","multiply_all_noexpand","multiply_consecutive_constants","multiply_denominators","multiply_denominators_factor","multiply_denominators_term","multiply_noexpand","multiply_numbers","n_factor_number","negate","negate_expand","negate_noexpand","negate_number","new_integer","new_string","newline_flag","nil_symbols","normaliseDots","normalisedCoeff","normalize_angle","nroots_a","nroots_b","nroots_c","nroots_df","nroots_dx","nroots_fa","nroots_fb","nroots_x","nroots_y","nterms","nthCadr","numerator","numericRootOfPolynomial1","o1","one","oneElement1","one_as_double","out_buf","out_count","out_of_memory","outer","p0","p11","p21","p3","p4","p5","p6","p7","p8","p9","parse","parse_internal","parse_p1","parse_p2","parse_time_simplifications","partition","patternHasBeenFound","patternsinfo","performing_roots","polar","polarRectAMinusOneBase","polyform","pop","pop_double","pop_frame","pop_integer","power1","power_str","power_sum","power_tensor","predefinedSymbolsInGlobalScope_doNotTrackInDependencies","prime","primetab","print2dascii","printMode","print_ABS_latex","print_ARCCOS_codegen","print_ARCSIN_codegen","print_ARCTAN_codegen","print_BINOMIAL_latex","print_COS_codegen","print_DEFINT_latex","print_DOT_codegen","print_DOT_latex","print_DO_codegen","print_FOR_codegen","print_INV_codegen","print_INV_latex","print_PRODUCT_codegen","print_PRODUCT_latex","print_SETQ_codegen","print_SIN_codegen","print_SQRT_latex","print_SUM_codegen","print_SUM_latex","print_TAN_codegen","print_TESTEQ_latex","print_TESTGE_latex","print_TESTGT_latex","print_TESTLE_latex","print_TESTLT_latex","print_TEST_codegen","print_TEST_latex","print_TRANSPOSE_codegen","print_TRANSPOSE_latex","print_UNIT_codegen","print_a_over_b","print_base","print_base_of_denom","print_char","print_denom","print_double","print_expo_of_denom","print_exponent","print_expr","print_factor","print_factorial_function","print_glyphs","print_index_function","print_list","print_multiply_sign","print_number","print_power","print_str","print_subexpr","print_tensor","print_tensor_inner","print_tensor_inner_latex","print_tensor_latex","print_term","printchar","printchar_nowrap","printline","program_buf","promote_tensor","push","pushTryNotToDuplicate","push_cars","push_double","push_factor","push_frame","push_identity_matrix","push_integer","push_rational","push_symbol","push_term_factors","push_terms","push_zero_matrix","qadd","qdiv","qmul","qpow","qpowf","quickfactor","quickpower","rational1","rationalize","rationalize_coefficients","real","reciprocate","rect","recursionLevelNestedRadicalsRemoval","recursiveDependencies","ref2","ref11","rememberPrint","remove_negative_exponents","reset_after_error","restore","restoreMetaBindings","rewrite_args","rewrite_args_tensor","roots","roots2","roots3","run","runUserDefinedSimplifications","save","saveMetaBindings","scalar_times_tensor","scan","scan_error","scan_expression","scan_factor","scan_function_call_with_function_name","scan_function_call_without_function_name","scan_index","scan_meta","scan_power","scan_relation","scan_stmt","scan_str","scan_string","scan_subexpr","scan_symbol","scan_tensor","scan_term","scanned","scanningParameters","setM","setSignTo","set_binding","set_component","setq_indexed","sfac_product","sfac_product_f","sgn","shape","show_power_debug","sign","sign_of_term","simfac","simfac_term","simpleComplexityMeasure","simplify","simplifyForCodeGeneration","simplify_1_in_products","simplify_main","simplify_nested_radicals","simplify_polar","simplify_polarRect","simplify_rational_expressions","simplify_rectToClock","simplify_tensor","simplify_trig","simplifyfactorials","sine","sine_of_angle","sine_of_angle_sum","skipRootVariableToBeSolved","sort_stack","square","ssqrt","stack","stackAddsCount","std_symbol","step","step2","stop","strcmp","stringsEmittedByUserPrintouts","subf","subst","subtract","subtract_numbers","swap","symbol","symbolsDependencies","symbolsHavingReassignments","symbolsInExpressionsWithoutAssignments","symbolsLeftOfAssignment","symbolsRightOfAssignment","symbolsinfo","symnum","symtab","take_care_of_nested_radicals","tangent","taylor","tensor1","tensor_plus_tensor","tensor_times_scalar","testApprox","test_flag","text_metric1","theRandom","token","token_buf","token_str","top","top_level_eval","tos1","transform","transpose","transpose_unicode","trigmode","trivial_divide","try_kth_prime","turnErrorMessageToLatex","ucmp","unfreeze","unique","unique_f","update_token_buf","userSimplificationsInListForm","userSimplificationsInStringForm","usr_symbol","verbosing","version","will_be_displayed_as_fraction","ybinomial","ycosh","ydirac","yerf","yerfc","yfloor","yindex","yround","ysinh","yyarg","yybesselj","yybessely","yyceiling","yycondense","yycontract","yycosh","yydegree","yydetg","yydivpoly","yyerf","yyerfc","yyexpand","yyfactorpoly","yyfloat","yyfloor","yyhermite","yyhermite2","yyinvg","yylcm","yylog","yymultiply","yyouter","yypower","yyrationalize","yyround","yysgn","yysimfac","yysinh","yytangent","zero","zzfloat","hasProp","hasOwnProperty","parcelRequire","rational","prototype","a","b","call","this","U","toString","toLatexString","constructor","q","printname","str","tensor","d","k","tag","dim","o","ref","results","ndim","nelem","display","h","w","n","text_metric","ascent","descent","width","ceil","i","j","primes","Math","sqrt","x","p","startCount","isPositive","isZero","equals","exports","theArgument","console","trace","log","anyFactorsYet","input","i1","j1","ref1","subsetOfStack","slice","sort","concat","p1","p2","t","s","l1","m1","ref3","ref4","ref5","ref6","ref7","ref8","ref9","numberOfDigitsAfterTheDot","precision","splitBeforeAndAfterDot","supposedlyTheFloat","theFloat","theRatio","split","pow","decimal","AccuracyFactor","DecimalSign","FractionDenominator","FractionNumerator","PreviousDenominator","ScratchValue","Z","ret","isNaN","Infinity","floor","bestResultSoFar","complexity","error","hypothesis","len","likelyMultiplier","minimumComplexity","ratio","Number","MAX_VALUE","round","len1","approxRadicalsOfRationalsResult","approxRationalsOfRadicalsResult","approxLogsOfRationalsResult","approxRationalsOfLogsResult","approxSineOfRationalMultiplesOfPIResult","approxSineOfRationalsResult","fraction","sin","approxLogsResult","approxRadicalsResult","approxRationalsOfPowersOfEResult","approxRationalsOfPowersOfPIResult","approxTrigonometricResult","bestApproxSoFar","constantsSum","constantsSumMin","aResult","c","theSum","Array","i2","i3","j2","j3","k3","l2","l3","len2","len3","len4","len5","len6","len7","m2","m3","n1","n2","o2","originalValue","q1","q2","r1","r2","returned","returnedFraction","returnedValue","s1","s2","t1","t2","u1","u2","v1","v2","value","x1","x2","z1","z2","toFixed","acos","asin","atan","y","z","jn","yn","geq","MIN_SAFE_INTEGER","leq","MAX_SAFE_INTEGER","isNegative","qsub","ab","ba","minusOne","expo","toJSNumber","quotientAndRemainder","divmod","quotient","remainder","theNewInteger","flag","accumulator","buf","scounter","sign_","substring","parseFloat","signed","aAsString","denominatorString","shiftRight","indexOf","indexFound","variableToBeCleared","variable","polynomial","coeffsCount","constant","polynomialWithoutConstant","prev_expanding","row","col","ai","an","l","m","cos","cosh","toBePushed","generalTransform","breakFromOutherWhile","base","result","theta","op","ref10","printstr","results1","count","cc","ss","ans","exp","willEvaluateAsFloats","cycleString","positionIfSymbolAlreadyBeingEvaluated","cons_head","Eval_atomize","Eval_draw","checkResult","dsolve","orig","theTensor","A","AxPlusB","B","checkingTheDivision","dividend","factpoly_expo","firstParam","foundComplexRoot","foundRealRoot","partOfPolynomialFactoredSoFar","polycoeff","previousFactorisation","remainingPoly","secondDegreePloly","secondParam","whichRootsAreWeFinding","ratioInverse","a0","evalPolyResult","na0","nan","rootsTries_i","rootsTries_j","testDenominator","testNumerator","testValue","Q","evaluateAt","nodeToCheck","numberOfEs","numberOfMults","numberOfPIs","numberOfPowers","numberOfSums","loopingVariable","polyVar","difference","moretheArguments","operands","refinedOperands","shift","theArguments","arg1","arg2","arg3","subtractionResult","ak","bk","tree","factors_accumulator","hc","tab","constexp","constbase","tan","sinh","tanh","erf","u","half","arg_hash","name","Error","terms","sum","term","term_set","product","power","base_hash","exp_hash","f","key","JSON","stringify","eachEntry","results2","valueOrPredicate","evalledArgument","isEven","minussign","compareAbs","v","theNewString","toReturn","isProbablePrime","index","and","shiftLeft","not","or","append","_gamma","r","random","numericRootOfPolynomial","nrabs","firstArgument","patternPosition","secondArgument","stringKey","thirdArgument","patternsinfoToBePrinted","compare","bigint_one","g","xprime","b_isEven_and_c_isItsInverse","hopefullySimplified","inputBase","inputExp","isThisOne","is_a_moreThanZero","original_test_flag","beenPrinted","passedPrintMode","origPrintMode","theString","theTypeOfPrint","parsedString","originalCodeGen","returnedString","replace","denom","numberOneOverSomething","origAccumulator","previousFactorWasANumber","functionBody","numberOfIntegrals","originalIntegral","theIntegral","theVariable","retString","firstLevel","body","lowerlimit","upperlimit","howManyIfs","exponent","denomExponent","newExponent","numExponent","omitParens","pastFirstFactor","fbody","parameters","glyph","character","k1","k2","pPrintName","pString","dx","h1","h2","w1","w2","y1","y2","dy","max_x","max_y","min_x","min_y","emit_sign","tmpString","sIndex","tmpBuffer","oneElement","eh","ew","ncol","nrow","indexVariable","oldIndexVariableValue","gcdBetweenNumeratorAndDenominator","qadd_ab","qadd_ba","qadd_denominator","qadd_frac1","qadd_frac2","qadd_numerator","resultSum","aa","bb","isOdd","stackIndex","divisor","commonDenominator","eachTerm","imaginaryCoefficients","isSimpleRootPolynomial","divideBy","miniStack","lastCoeff","leadingCoeff","aSol","commonPart","rootsOfOne","C_CHECKED_AS_NOT_ZERO","R_18_a_b_c_d","R_27_a2_d","R_2_b3","R_3_a","R_3_a_C","R_3_a_c","R_4_DELTA03","R_6_a_C","R_C","R_C_over_3a","R_C_simplified_toCheckIfZero","R_DELTA0","R_DELTA0_toBeCheckedIfZero","R_DELTA1","R_Q","R_a2","R_a2_d","R_a2_d2","R_a3","R_a_b_c","R_a_b_c_d","R_a_c","R_b2","R_b2_c2","R_b3","R_b3_d","R_c2","R_c3","R_d2","R_determinant","R_e2","R_e3","R_m","R_m27_a2_d2","R_m4_a_c3","R_m4_b3_d","R_m9_a_b_c","R_m_b_over_3a","R_p","R_q","R_r","ThreePPlus2M","TwoQOversqrtPPlus2M","coeff2","coeff3","coeff4","depressedSolutions","eachSolution","flipSignOFQSoCIsNotZero","i_sqrt3","one_minus_i_sqrt3","one_plus_i_sqrt3","resolventCubicSolutions","root_solution","sqrtPPlus2M","toBeCheckedIFZero","assignmentIsOfQuotedType","existingDependencies","indexOfSymbolLeftOfAssignment","symbolLeftOfAssignment","splice","charCodeAt","tos","firstFactorIsNumber","theSymbol","prefixVar","functionName","RegExp","test","errmsg","atLeastOneSuccessInRouldOfRulesApplications","eachConsecutiveRuleApplication","eachSimplification","numberOfRulesApplications","originalexpanding","success","args","eval","carp1","oldp1","oldp2","num","theGCD","simplificationWithCondense","simplificationWithoutCondense","somethingSimplified","C","SOLUTION","anyRadicalSimplificationWorked","checkSize","commonBases","commonInnerExponent","countingTerms","firstTerm","innerbase","innerexponent","lowercase_a","lowercase_b","numberOfTerms","possibleNewExpression","possibleNewExpressionValue","possibleRationalSolutions","possibleSolutions","potentialPower","realOfpossibleRationalSolutions","secondTerm","secondTermFactor","termsThatAreNotPowers","max","apply","expr","newExpr","newTensor","oldExpr","comparison","wholeAndExpression","andPredicates","somePredicateUnknown","orPredicates","wholeOrExpression","bookmarkTosToPrintDecomps","eachTransformEntry","numberOfDecomps","restTerm","theTransform","transform_h","transformationSuccessful","transformedTerms","fea_i","fea_j","innerTranspSwitch1","innerTranspSwitch2","bodyAndFormalArguments","definitionOfInterest","defn_i","str1","str2","maxFixedPrintoutDigits","stringRepresentation","search","needle","message","stringToBeParsed","dontGenerateCode","bodyForReadableSummaryOfGeneratedCode","cyclesDescriptions","deQuotedDep","dependencyInfo","eachDependency","generatedBody","generatedCode","indexOfEachReplacement","indexOfPartRemainingToBeParsed","newUserSymbol","originalUserSymbol","readableSummaryOfGeneratedCode","recursedDependencies","replacementsFrom","replacementsTo","scriptEvaluation","stringToBeRun","testableString","timeStartFromAlgebra","toBePrinted","userVariablesMentioned","variablesWithCycles","Date","getTime","affectsVariables","affectedBy","error1","variableToBeChecked","arrayWhereDependenciesWillBeAdded","variablesAlreadyFleshedOut","chainBeingChecked","cyclesDescription","theErrorMessage","String","fromCharCode","stringToNormalise","generateLatex","allReturnedLatexStrings","allReturnedPlainStrings","collectedLatexResult","collectedPlainResult","stringToBeReturned","timeStart","timingDebugWrite","error11","selftest","originalArgument","shouldAutoexpand","codeFromAlgebraBlock","code","latexResult","readableSummaryOfCode","testableStringIsIgnoredHere","stackPos","elementToBeReturned","symbolsinfoToBePrinted","bindingi","symtabi","latexPrint","theSymnum","argu","warn","data","argus","fn","builtin_fns","bind","frozenContents","frozenSymbols","frozen","frozenPatterns","previousHash","frozenHash","undefined","BASE","MAX_INT","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","SmallInteger","NativeBigInt","isPrecise","arrayToSmall","arr","trim","createArray","truncate","l_a","l_b","carry","addAny","addSmall","a_l","b_l","borrow","subtractSmall","multiplyLong","a_i","multiplySmall","multiplyKaratsuba","ac","bd","abcd","multiplySmallAndArray","divModSmall","lambda","divModAny","self","quotientDigit","divisorMostSignificantDigit","divMod1","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mSign","isBasicPrime","isUnit","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","next","modPow","Object","create","plus","subtractAny","minus","small","times","_multiplyBySmall","over","_0","_1","_2","modInv","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","lesserOrEquals","isPrime","strict","bits","bitLength","logN","iterations","rng","randBetween","lastT","lastR","newT","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","xSign","ySign","xRem","yRem","xDigit","yDigit","xDivMod","yDivMod","remQuo","xor","LOBMASK_I","roughLOB","integerLogarithm","tmp","e","max1","min1","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","val","toBase","map","valueOf","neg","out","left","digit","toBaseString","join","parseStringValue","decimalPlace","min","parseNumberValue","toArray","toJSON","parseInt","isInstance","usedRNG","low","range","restricted","fromArray","module","define","amd","window","Algebrite"],"version":3,"file":"index.js.map"}