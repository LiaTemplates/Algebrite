{"mappings":"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AI,IAAI,IAAM,CAAC,EAAG,EAAG,GAAG,GAAI,GAAK,IAAI,GAAI,GAAK,GAAI,IAAI,EAAI,GAAG,EAAI,IAAI,EAAI,GAAG,IAAM,CAAC,EAAG,EAAG,EAAG,IAAI,GAAI,EAAI,IAAI,GAAI,GAAK,EAAG,IAAI,GAAI,GAAK,EAAG,IAAI,GAAI,IAAM,CAAC,EAAG,EAAG,GAAG,GAAK,GAAG,GAAI,GAAK,IAAI,GAAI,EAAI,EAAG,IAAI,IAAK,EAAI,EAAG,IAAI,IAAM,CAAC,EAAG,EAAG,EAAG,EAAG,IAAI,GAAK,EAAG,IAAI,GAAK,IAAI,EAAI,EAAG,GAAI,IAAI,EAAI,EAAG,GAAI,CAAC,EAAG,EAAG,GAAG,GAAK,EAAG,IAAI,GAAK,EAAG,EAAG,EAAG,IAAI,EAAI,GAAI,EAAG,IAAI,EAAI,IAAK,CAAC,EAAG,EAAG,EAAG,IAAI,GAAK,EAAG,IAAI,EAAI,GAAG,EAAI,EAAG,GAAI,IAAI,EAAI,EAAG,GAAI,IAAK,CAAC,EAAG,EAAG,GAAI,IAAI,EAAI,EAAG,IAAI,EAAI,GAAG,GAAI,GAAK,IAAI,GAAI,GAAI,GAAK,IAAI,GAAK,CAAC,EAAG,EAAG,GAAI,EAAG,IAAI,EAAI,EAAG,IAAI,EAAI,IAAI,GAAI,GAAI,EAAI,IAAI,GAAI,IAAK,GAAK,CAAC,EAAG,EAAG,IAAI,EAAI,EAAG,IAAI,EAAI,EAAG,IAAI,GAAK,GAAG,GAAI,GAAI,GAAK,IAAI,GAAI,GAAK,CAAC,EAAG,EAAG,IAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,EAAI,GAAG,GAAI,GAAI,EAAI,GAAI,CAAC,EAAG,EAAG,GAAG,GAAK,GAAG,GAAI,GAAK,GAAG,GAAI,GAAI,GAAK,GAAI,GAAG,GAAI,GAAK,GAAI,GAAI,CAAC,EAAG,EAAG,IAAI,GAAI,GAAK,GAAG,GAAI,GAAK,EAAG,IAAI,GAAI,GAAK,EAAG,IAAI,GAAI,EAAI,GAAI,CAAC,EAAG,EAAG,GAAI,GAAG,GAAI,GAAK,GAAG,GAAI,IAAK,GAAK,IAAI,EAAI,GAAG,GAAK,GAAG,EAAI,GAAI,CAAC,EAAG,EAAG,GA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","sources":["node_modules/algebrite/dist/algebrite.js","node_modules/big-integer/BigInteger.js","src/index.js"],"sourcesContent":["// Generated by CoffeeScript 2.5.1\n(function() {\n\n  /* arg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the angle of complex z.\n\n  */\n  /*\n   Argument (angle) of complex z\n\n    z    arg(z)\n    -    ------\n\n    a    0\n\n    -a    -pi      See note 3 below\n\n    (-1)^a    a pi\n\n    exp(a + i b)  b\n\n    a b    arg(a) + arg(b)\n\n    a + i b    arctan(b/a)\n\n  Result by quadrant\n\n    z    arg(z)\n    -    ------\n\n    1 + i    1/4 pi\n\n    1 - i    -1/4 pi\n\n    -1 + i    3/4 pi\n\n    -1 - i    -3/4 pi\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. Symbols in z are assumed to be positive and real.\n\n    3. Negative direction adds -pi to angle.\n\n       Example: z = (-1)^(1/3), abs(z) = 1/3 pi, abs(-z) = -2/3 pi\n\n    4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      arg(numerator(z)) - arg(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  /*\n   Returns the coefficient of the imaginary part of complex z\n\n    z    imag(z)\n    -    -------\n\n    a + i b    b\n\n    exp(i a)  sin(a)\n  */\n  /* Power function\n\n    Input:    push  Base\n\n        push  Exponent\n\n    Output:    Result on stack\n  */\n  /*\n  Convert complex z to rectangular form\n\n    Input:    push  z\n\n    Output:    Result on stack\n  */\n  /* det =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the determinant of matrix m.\n  Uses Gaussian elimination for numerical matrices.\n\n  Example:\n\n    det(((1,2),(3,4)))\n    > -2\n\n  */\n  /* adj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Returns the adjunct of matrix m. The inverse of m is equal to adj(m) divided by det(m).\n\n  */\n  /*\n   Guesses a rational for each float in the passed expression\n  */\n  /* arccos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse cosine of x.\n\n  */\n  /* arccosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic cosine of x.\n\n  */\n  /* arcsin =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse sine of x.\n\n  */\n  /* arcsinh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic sine of x.\n\n  */\n  /* arctan =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse tangent of x.\n\n  */\n  /* arctanh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the inverse hyperbolic tangent of x.\n\n  */\n  /* besselj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Returns a solution to the Bessel differential equation (Bessel function of first kind).\n\n  Recurrence relation:\n\n    besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)\n\n    besselj(x,1/2) = sqrt(2/pi/x) sin(x)\n\n    besselj(x,-1/2) = sqrt(2/pi/x) cos(x)\n\n  For negative n, reorder the recurrence relation as:\n\n    besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)\n\n  Substitute n+2 for n to obtain\n\n    besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)\n\n  Examples:\n\n    besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)\n\n    besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)\n\n  */\n  /* bessely =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x,n\n\n  General description\n  -------------------\n\n  Bessel function of second kind.\n\n  */\n  /* ceiling =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns the smallest integer not less than x.\n\n  */\n  /* check =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p\n\n  General description\n  -------------------\n  Returns whether the predicate p is true/false or unknown:\n  0 if false, 1 if true or remains unevaluated if unknown.\n  Note that if \"check\" is passed an assignment, it turns it into a test,\n  i.e. check(a = b) is turned into check(a==b) \n  so \"a\" is not assigned anything.\n  Like in many programming languages, \"check\" also gives truthyness/falsyness\n  for numeric values. In which case, \"true\" is returned for non-zero values.\n  Potential improvements: \"check\" can't evaluate strings yet.\n\n  */\n  /* choose =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  n,k\n\n  General description\n  -------------------\n\n  Returns the number of combinations of n items taken k at a time.\n\n  For example, the number of five card hands is choose(52,5)\n\n  ```\n                            n!\n        choose(n,k) = -------------\n                       k! (n - k)!\n  ```\n  */\n  /* circexp =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Returns expression x with circular and hyperbolic functions converted to exponential forms. Sometimes this will simplify an expression.\n\n  */\n  /* clear =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n\n  Completely wipes a variable from the environment (while doing x = quote(x) just unassigns it).\n\n  */\n  /* clearall =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n\n  Completely wipes all variables from the environment.\n\n  */\n  /* cofactor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,i,j\n\n  General description\n  -------------------\n  Cofactor of a matrix component.\n  Let c be the cofactor matrix of matrix m, i.e. tranpose(c) = adj(m).\n  This function returns c[i,j].\n\n  */\n  /* conj =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  z\n\n  General description\n  -------------------\n  Returns the complex conjugate of z.\n\n  */\n  /* contract =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,i,j\n\n  General description\n  -------------------\n  Contract across tensor indices i.e. returns \"a\" summed over indices i and j.\n  If i and j are omitted then 1 and 2 are used.\n  contract(m) is equivalent to the trace of matrix m.\n\n  */\n  /* cosh =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the hyperbolic cosine of x\n\n  ```\n              exp(x) + exp(-x)\n    cosh(x) = ----------------\n                     2\n  ```\n\n  */\n  /* deg =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x\n\n  General description\n  -------------------\n  Returns the degree of polynomial p(x).\n\n  */\n  /* denominator =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the denominator of expression x.\n\n  */\n  /* dim =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m,n\n\n  General description\n  -------------------\n  Returns the cardinality of the nth index of tensor \"m\".\n\n  */\n  /* do =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Evaluates each argument from left to right. Returns the result of the last argument.\n\n  */\n  /* eigenval =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues of m. See \"eigen\" for more info.\n\n  */\n  /* eigenvec =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvectors of m. See \"eigen\" for more info.\n\n  */\n  /* erf =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Authors\n  -------\n  philippe.billet@noos.fr\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Error function erf(x).\n  erf(-x)=erf(x)\n\n  */\n  /*\n  Remove terms that involve a given symbol or expression. For example...\n\n    filter(x^2 + x + 1, x)    =>  1\n\n    filter(x^2 + x + 1, x^2)  =>  x + 1\n  */\n  /* dot =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n\n  The inner (or dot) operator gives products of vectors,\n  matrices, and tensors.\n\n  Note that for Algebrite, the elements of a vector/matrix\n  can only be scalars. This allows for example to flesh out\n  matrix multiplication using the usual multiplication.\n  So for example block-representations are not allowed.\n\n  There is an aweful lot of confusion between sw packages on\n  what dot and inner do.\n\n  First off, the \"dot\" operator is different from the\n  mathematical notion of dot product, which can be\n  slightly confusing.\n\n  The mathematical notion of dot product is here:\n    http://mathworld.wolfram.com/DotProduct.html\n\n  However, \"dot\" does that and a bunch of other things,\n  i.e. in Algebrite\n  dot/inner does what the dot of Mathematica does, i.e.:\n\n  scalar product of vectors:\n\n    inner((a, b, c), (x, y, z))\n    > a x + b y + c z\n\n  products of matrices and vectors:\n\n    inner(((a, b), (c,d)), (x, y))\n    > (a x + b y,c x + d y)\n\n    inner((x, y), ((a, b), (c,d)))\n    > (a x + c y,b x + d y)\n\n    inner((x, y), ((a, b), (c,d)), (r, s))\n    > a r x + b s x + c r y + d s y\n\n  matrix product:\n\n    inner(((a,b),(c,d)),((r,s),(t,u)))\n    > ((a r + b t,a s + b u),(c r + d t,c s + d u))\n\n  the \"dot/inner\" operator is associative and\n  distributive but not commutative.\n\n  In Mathematica, Inner is a generalisation of Dot where\n  the user can specify the multiplication and the addition\n  operators.\n  But here in Algebrite they do the same thing.\n\n   https://reference.wolfram.com/language/ref/Dot.html\n   https://reference.wolfram.com/language/ref/Inner.html\n\n   http://uk.mathworks.com/help/matlab/ref/dot.html\n   http://uk.mathworks.com/help/matlab/ref/mtimes.html\n\n  */\n  /*\n   Laguerre function\n\n  Example\n\n    laguerre(x,3)\n\n  Result\n\n       1   3    3   2\n    - --- x  + --- x  - 3 x + 1\n       6        2\n\n  The computation uses the following recurrence relation.\n\n    L(x,0,k) = 1\n\n    L(x,1,k) = -x + k + 1\n\n    n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)\n\n  In the \"for\" loop i = n-1 so the recurrence relation becomes\n\n    (i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)\n  */\n  /*\n   Return the leading coefficient of a polynomial.\n\n  Example\n\n    leading(5x^2+x+1,x)\n\n  Result\n\n    5\n\n  The result is undefined if P is not a polynomial.\n  */\n  /*\n   Legendre function\n\n  Example\n\n    legendre(x,3,0)\n\n  Result\n\n     5   3    3\n    --- x  - --- x\n     2        2\n\n  The computation uses the following recurrence relation.\n\n    P(x,0) = 1\n\n    P(x,1) = x\n\n    n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)\n\n  In the \"for\" loop we have i = n-1 so the recurrence relation becomes\n\n    (i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)\n\n  For m > 0\n\n    P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)\n  */\n  /*\n  Convert complex z to polar form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    polar(z) = abs(z) * exp(i * arg(z))\n  */\n  /*\n   Returns the real part of complex z\n\n    z    real(z)\n    -    -------\n\n    a + i b    a\n\n    exp(i a)  cos(a)\n  */\n  /*\n  Taylor expansion of a function\n\n    push(F)\n    push(X)\n    push(N)\n    push(A)\n    taylor()\n  */\n  /*\n  // up to 100 blocks of 100,000 atoms\n\n  #define M 100\n  #define N 100000\n\n  U *mem[M]\n  int mcount\n\n  U *free_list\n  int free_count\n\n  U *\n  alloc(void)\n  {\n    U *p\n    if (free_count == 0) {\n      if (mcount == 0)\n        alloc_mem()\n      else {\n        gc()\n        if (free_count < N * mcount / 2)\n          alloc_mem()\n      }\n      if (free_count == 0)\n        stop(\"atom space exhausted\")\n    }\n    p = free_list\n    free_list = free_list->u.cons.cdr\n    free_count--\n    return p\n  }\n   */\n  /*\n   Compare adjacent terms in s[] and combine if possible.\n\n    Returns the number of terms remaining in s[].\n\n    n  number of terms in s[] initially\n  */\n  /* cross =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u,v\n\n  General description\n  -------------------\n  Returns the cross product of vectors u and v.\n\n  */\n  /* curl =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept, script_defined\n\n  Parameters\n  ----------\n  u\n\n  General description\n  -------------------\n  Returns the curl of vector u.\n\n  */\n  /*\n    Clear all patterns\n  */\n  /*\n  if 0\n\n   * left brace\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = x - 2\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n   * right brace\n\n    emit_x++\n\n    for (i = 0; i < h; i++) {\n      if (yindex == YMAX)\n        break\n      chartab[yindex].c = '|'\n      chartab[yindex].x = emit_x\n      chartab[yindex].y = y + i\n      yindex++\n    }\n\n    emit_x++\n\n  endif\n   */\n  /*\n   For example...\n\n    push(F)\n    push(X)\n    filter()\n    F = pop()\n  */\n  /*\n   Symbolic addition\n\n    Terms in a sum are combined if they are identical modulo rational\n    coefficients.\n\n    For example, A + 2A becomes 3A.\n\n    However, the sum A + sqrt(2) A is not modified.\n\n    Combining terms can lead to second-order effects.\n\n    For example, consider the case of\n\n      1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A\n\n    The first two terms are combined to yield 2 sqrt(2) A.\n\n    This result can now be combined with the third term to yield\n\n      3 sqrt(2) A\n  */\n  /*\n   Table of integrals\n\n  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where\n\n    A  is the template expression\n\n    B  is the result expression\n\n    C  is an optional list of conditional expressions\n  */\n  /*\n   Partition a term\n\n    Input stack:\n\n      term (factor or product of factors)\n\n      free variable\n\n    Output stack:\n\n      constant expression\n\n      variable expression\n  */\n  /*\n    Substitute new expr for old expr in expr.\n\n    Input:  push  expr\n\n      push  old expr\n\n      push  new expr\n\n    Output:  Result on stack\n  */\n  var $, ABS, ADD, ADJ, AND, APPROXRATIO, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ASSUME_REAL_VARIABLES, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARALL, CLEARPATTERNS, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DEBUG_ABS, DEBUG_ARG, DEBUG_CLOCKFORM, DEBUG_IMAG, DEBUG_IS, DEBUG_MULTIPLY, DEBUG_POWER, DEBUG_RATIONALIZE, DEBUG_RECT, DEBUG_SIMPLIFY, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_approxratio, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearall, Eval_clearpatterns, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_patternsinfo, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_print2dascii, Eval_printcomputer, Eval_printhuman, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_round, Eval_setq, Eval_sgn, Eval_shape, Eval_silentpattern, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_symbolsinfo, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FORCE_FIXED_PRINTOUT, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_2DASCII_PRINT, LAST_FULL_PRINT, LAST_LATEX_PRINT, LAST_LIST_PRINT, LAST_PLAIN_PRINT, LAST_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAXDIM, MAXPRIMETAB, MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES, MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE, MAX_FIXED_PRINTOUT_DIGITS, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PATTERNSINFO, PI, POLAR, POWER, PRIME, PRINT, PRINT2DASCII, PRINTFULL, PRINTLATEX, PRINTLIST, PRINTMODE_2DASCII, PRINTMODE_COMPUTER, PRINTMODE_HUMAN, PRINTMODE_LATEX, PRINTMODE_LIST, PRINTOUTRESULT, PRINTPLAIN, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, ROUND, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SILENTPATTERN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOLSINFO, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TIMING_DEBUGS, TOS, TRACE, TRANSPOSE, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEQ, T_NEWLINE, T_QUOTASSIGN, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, VERSION, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _print, abs, absValFloat, absval, absval_tensor, add, addSymbolLeftOfAssignment, addSymbolRightOfAssignment, add_all, add_factor_to_accumulator, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, approxAll, approxLogs, approxLogsOfRationals, approxOneRatioOnly, approxRadicals, approxRadicalsOfRationals, approxRationalsOfLogs, approxRationalsOfPowersOfE, approxRationalsOfPowersOfPI, approxRationalsOfRadicals, approxSineOfRationalMultiplesOfPI, approxSineOfRationals, approxTrigonometric, approx_just_an_integer, approx_logarithmsOfRationals, approx_nothingUseful, approx_radicalOfRatio, approx_ratioOfRadical, approx_rationalOfE, approx_rationalOfPi, approx_rationalsOfLogarithms, approx_sine_of_pi_times_rational, approx_sine_of_rational, approxratioRecursive, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, areunivarpolysfactoredorexpandedform, arg, arglist, assignmentFound, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, called_from_Algebra_block, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, chainOfUserSymbolsNotFunctionsBeingEvaluated, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, check_tensor_dimensions, choose, choose_check_args, circexp, clearAlgebraEnvironment, clearRenamedVariablesToAvoidBindingToExternalScope, clear_symbols, clear_term, clearall, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexStringFromReturnValue, collectUserSymbols, combine_factors, combine_gammas, combine_terms, compareState, compare_numbers, compare_rationals, compare_tensors, compatible, computeDependenciesFromAlgebra, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, countsize, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, defineSomeHandyConstants, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_clearPatterns, do_clearall, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, evaluatingPolar, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findPossibleClockForm, findPossibleExponentialForm, findroot, fixup_fraction, fixup_power, flag, floatToRatioRoutine, fmt_index, fmt_level, fmt_x, frame, freeze, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_main, gcd_numbers, gcd_polys, gcd_powers_with_same_base, gcd_product_product, gcd_product_sum, gcd_sum, gcd_sum_product, gcd_sum_sum, gen, getSimpleRoots, getStateHash, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_innerprod_factors, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hasNegativeRationalExponent, hash_addition, hash_function, hash_multiplication, hash_power, hashcode_values, hashed_itab, hermite, hilbert, i1, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isNumberOneOverSomething, isNumericAtom, isNumericAtomOrTensor, isSimpleRoot, isSmall, isSymbolLeftOfAssignment, isSymbolReclaimable, isZeroAtom, isZeroAtomOrTensor, isZeroLikeOrNonZeroLikeOrUndetermined, isZeroTensor, is_denominator, is_factor, is_small_integer, is_square_matrix, is_usr_symbol, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isintegerorintegerfloat, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, isminussqrtthreeovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispolyexpandedform, ispolyexpandedform_expr, ispolyexpandedform_factor, ispolyexpandedform_term, ispolyfactoredorexpandedform, ispolyfactoredorexpandedform_factor, ispolyfactoredorexpandedform_power, isposint, ispositivenumber, ispower, isquarterturn, isrational, isspace, issqrtthree, issqrtthreeovertwo, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, isunivarpolyfactoredorexpandedform, itab, italu_hashcode, j1, laguerre, laguerre2, lastFoundSymbol, latexErrorSign, lcm, leading, legendre, length, lessp, level, list, listLength, logarithm, logbuf, lookupsTotal, lu_decomp, madd, makePositive, makeSignSameAs, make_hashed_itab, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, moveTos, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_integer, new_string, newline_flag, nil_symbols, normaliseDots, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, nthCadr, numerator, numericRootOfPolynomial, o, one, oneElement, one_as_double, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, patternHasBeenFound, patternsinfo, performing_roots, polar, polarRectAMinusOneBase, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print2dascii, printMode, print_ABS_latex, print_ARCCOS_codegen, print_ARCSIN_codegen, print_ARCTAN_codegen, print_BINOMIAL_latex, print_COS_codegen, print_DEFINT_latex, print_DOT_codegen, print_DOT_latex, print_DO_codegen, print_FOR_codegen, print_INV_codegen, print_INV_latex, print_PRODUCT_codegen, print_PRODUCT_latex, print_SETQ_codegen, print_SIN_codegen, print_SQRT_latex, print_SUM_codegen, print_SUM_latex, print_TAN_codegen, print_TESTEQ_latex, print_TESTGE_latex, print_TESTGT_latex, print_TESTLE_latex, print_TESTLT_latex, print_TEST_codegen, print_TEST_latex, print_TRANSPOSE_codegen, print_TRANSPOSE_latex, print_UNIT_codegen, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_glyphs, print_index_function, print_list, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_tensor_inner_latex, print_tensor_latex, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, pushTryNotToDuplicate, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, rememberPrint, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, saveMetaBindings, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call_with_function_name, scan_function_call_without_function_name, scan_index, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_tensor, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simpleComplexityMeasure, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_rational_expressions, simplify_rectToClock, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringsEmittedByUserPrintouts, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsHavingReassignments, symbolsInExpressionsWithoutAssignments, symbolsLeftOfAssignment, symbolsRightOfAssignment, symbolsinfo, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, testApprox, test_flag, text_metric, theRandom, token, token_buf, token_str, top, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, turnErrorMessageToLatex, ucmp, unfreeze, unique, unique_f, update_token_buf, userSimplificationsInListForm, userSimplificationsInStringForm, usr_symbol, verbosing, version, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, yround, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymultiply, yyouter, yypower, yyrationalize, yyround, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat,\n    hasProp = {}.hasOwnProperty;\n\n  bigInt = require('big-integer');\n\n  // also change the version in the package.json file\n  version = \"1.4.0\";\n\n  SELFTEST = 1;\n\n  // size of the symbol table\n  NSYM = 1000;\n\n  DEBUG = false;\n\n  PRINTOUTRESULT = false;\n\n  // printing-related constants\n  PRINTMODE_LATEX = \"PRINTMODE_LATEX\";\n\n  PRINTMODE_2DASCII = \"PRINTMODE_2DASCII\";\n\n  PRINTMODE_COMPUTER = \"PRINTMODE_COMPUTER\";\n\n  PRINTMODE_HUMAN = \"PRINTMODE_HUMAN\";\n\n  PRINTMODE_LIST = \"PRINTMODE_LIST\";\n\n  // when the user uses the generic \"print\" statement\n  // this setting kicks-in.\n  printMode = PRINTMODE_COMPUTER;\n\n  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;\n\n  recursionLevelNestedRadicalsRemoval = 0;\n\n  do_simplify_nested_radicals = true;\n\n  avoidCalculatingPowersIntoArctans = true;\n\n  rational = (function() {\n    // Symbolic expressions are built by connecting U structs.\n\n    // For example, (a b + c) is built like this:\n\n    //           _______      _______                                _______\n    //          |CONS   |--->|CONS   |----------------------------->|CONS   |\n    //          |       |    |       |                              |       |\n    //          |_______|    |_______|                              |_______|\n    //              |            |                                      |\n    //           ___v___      ___v___      _______      _______      ___v___\n    //          |ADD    |    |CONS   |--->|CONS   |--->|CONS   |    |SYM c  |\n    //          |       |    |       |    |       |    |       |    |       |\n    //          |_______|    |_______|    |_______|    |_______|    |_______|\n    //                           |            |            |\n    //                        ___v___      ___v___      ___v___\n    //                       |MUL    |    |SYM a  |    |SYM b  |\n    //                       |       |    |       |    |       |\n    //                       |_______|    |_______|    |_______|\n    class rational {};\n\n    rational.prototype.a = null; // a bigInteger\n\n    rational.prototype.b = null; // a bigInteger\n\n    return rational;\n\n  }).call(this);\n\n  U = (function() {\n    class U {\n      toString() {\n        return print_expr(this);\n      }\n\n      toLatexString() {\n        return collectLatexStringFromReturnValue(this);\n      }\n\n      constructor() {\n        this.cons = {};\n        this.cons.car = null;\n        this.cons.cdr = null;\n        this.q = new rational();\n      }\n\n    };\n\n    U.prototype.cons = null; // will have a car and cdr\n\n    U.prototype.printname = \"\";\n\n    U.prototype.str = \"\";\n\n    U.prototype.tensor = null;\n\n    // rational number a over b\n    U.prototype.q = null; // will point to a rational\n\n    U.prototype.d = 0.0; // a double\n\n    U.prototype.k = 0;\n\n    U.prototype.tag = 0;\n\n    return U;\n\n  }).call(this);\n\n  errorMessage = \"\";\n\n  // the following enum is for struct U, member k\n  CONS = 0;\n\n  NUM = 1;\n\n  DOUBLE = 2;\n\n  STR = 3;\n\n  TENSOR = 4;\n\n  SYM = 5;\n\n  // the following enum is for indexing the symbol table\n\n  // standard functions first, then nil, then everything else\n  counter = 0;\n\n  ABS = counter++;\n\n  ADD = counter++;\n\n  ADJ = counter++;\n\n  AND = counter++;\n\n  APPROXRATIO = counter++;\n\n  ARCCOS = counter++;\n\n  ARCCOSH = counter++;\n\n  ARCSIN = counter++;\n\n  ARCSINH = counter++;\n\n  ARCTAN = counter++;\n\n  ARCTANH = counter++;\n\n  ARG = counter++;\n\n  ATOMIZE = counter++;\n\n  BESSELJ = counter++;\n\n  BESSELY = counter++;\n\n  BINDING = counter++;\n\n  BINOMIAL = counter++;\n\n  CEILING = counter++;\n\n  CHECK = counter++;\n\n  CHOOSE = counter++;\n\n  CIRCEXP = counter++;\n\n  CLEAR = counter++;\n\n  CLEARALL = counter++;\n\n  CLEARPATTERNS = counter++;\n\n  CLOCK = counter++;\n\n  COEFF = counter++;\n\n  COFACTOR = counter++;\n\n  CONDENSE = counter++;\n\n  CONJ = counter++;\n\n  CONTRACT = counter++;\n\n  COS = counter++;\n\n  COSH = counter++;\n\n  DECOMP = counter++;\n\n  DEFINT = counter++;\n\n  DEGREE = counter++;\n\n  DENOMINATOR = counter++;\n\n  DERIVATIVE = counter++;\n\n  DET = counter++;\n\n  DIM = counter++;\n\n  DIRAC = counter++;\n\n  DIVISORS = counter++;\n\n  DO = counter++;\n\n  DOT = counter++;\n\n  DRAW = counter++;\n\n  DSOLVE = counter++;\n\n  EIGEN = counter++;\n\n  EIGENVAL = counter++;\n\n  EIGENVEC = counter++;\n\n  ERF = counter++;\n\n  ERFC = counter++;\n\n  EVAL = counter++;\n\n  EXP = counter++;\n\n  EXPAND = counter++;\n\n  EXPCOS = counter++;\n\n  EXPSIN = counter++;\n\n  FACTOR = counter++;\n\n  FACTORIAL = counter++;\n\n  FACTORPOLY = counter++;\n\n  FILTER = counter++;\n\n  FLOATF = counter++;\n\n  FLOOR = counter++;\n\n  FOR = counter++;\n\n  FUNCTION = counter++;\n\n  GAMMA = counter++;\n\n  GCD = counter++;\n\n  HERMITE = counter++;\n\n  HILBERT = counter++;\n\n  IMAG = counter++;\n\n  INDEX = counter++;\n\n  INNER = counter++;\n\n  INTEGRAL = counter++;\n\n  INV = counter++;\n\n  INVG = counter++;\n\n  ISINTEGER = counter++;\n\n  ISPRIME = counter++;\n\n  LAGUERRE = counter++;\n\n  //  LAPLACE = counter++\n  LCM = counter++;\n\n  LEADING = counter++;\n\n  LEGENDRE = counter++;\n\n  LOG = counter++;\n\n  LOOKUP = counter++;\n\n  MOD = counter++;\n\n  MULTIPLY = counter++;\n\n  NOT = counter++;\n\n  NROOTS = counter++;\n\n  NUMBER = counter++;\n\n  NUMERATOR = counter++;\n\n  OPERATOR = counter++;\n\n  OR = counter++;\n\n  OUTER = counter++;\n\n  PATTERN = counter++;\n\n  PATTERNSINFO = counter++;\n\n  POLAR = counter++;\n\n  POWER = counter++;\n\n  PRIME = counter++;\n\n  PRINT_LEAVE_E_ALONE = counter++;\n\n  PRINT_LEAVE_X_ALONE = counter++;\n\n  PRINT = counter++;\n\n  PRINT2DASCII = counter++;\n\n  PRINTFULL = counter++;\n\n  PRINTLATEX = counter++;\n\n  PRINTLIST = counter++;\n\n  PRINTPLAIN = counter++;\n\n  PRODUCT = counter++;\n\n  QUOTE = counter++;\n\n  QUOTIENT = counter++;\n\n  RANK = counter++;\n\n  RATIONALIZE = counter++;\n\n  REAL = counter++;\n\n  ROUND = counter++;\n\n  YYRECT = counter++;\n\n  ROOTS = counter++;\n\n  SETQ = counter++;\n\n  SGN = counter++;\n\n  SILENTPATTERN = counter++;\n\n  SIMPLIFY = counter++;\n\n  SIN = counter++;\n\n  SINH = counter++;\n\n  SHAPE = counter++;\n\n  SQRT = counter++;\n\n  STOP = counter++;\n\n  SUBST = counter++;\n\n  SUM = counter++;\n\n  SYMBOLSINFO = counter++;\n\n  TAN = counter++;\n\n  TANH = counter++;\n\n  TAYLOR = counter++;\n\n  TEST = counter++;\n\n  TESTEQ = counter++;\n\n  TESTGE = counter++;\n\n  TESTGT = counter++;\n\n  TESTLE = counter++;\n\n  TESTLT = counter++;\n\n  TRANSPOSE = counter++;\n\n  UNIT = counter++;\n\n  ZERO = counter++;\n\n  // ALL THE SYMBOLS ABOVE NIL ARE KEYWORDS,\n  // WHICH MEANS THAT USER CANNOT REDEFINE THEM\n  NIL = counter++; // nil goes here, after standard functions\n\n  LAST = counter++;\n\n  LAST_PRINT = counter++;\n\n  LAST_2DASCII_PRINT = counter++;\n\n  LAST_FULL_PRINT = counter++;\n\n  LAST_LATEX_PRINT = counter++;\n\n  LAST_LIST_PRINT = counter++;\n\n  LAST_PLAIN_PRINT = counter++;\n\n  AUTOEXPAND = counter++;\n\n  BAKE = counter++;\n\n  ASSUME_REAL_VARIABLES = counter++;\n\n  TRACE = counter++;\n\n  FORCE_FIXED_PRINTOUT = counter++;\n\n  MAX_FIXED_PRINTOUT_DIGITS = counter++;\n\n  YYE = counter++;\n\n  DRAWX = counter++; // special purpose internal symbols\n\n  METAA = counter++;\n\n  METAB = counter++;\n\n  METAX = counter++;\n\n  SECRETX = counter++;\n\n  VERSION = counter++;\n\n  PI = counter++;\n\n  SYMBOL_A = counter++;\n\n  SYMBOL_B = counter++;\n\n  SYMBOL_C = counter++;\n\n  SYMBOL_D = counter++;\n\n  SYMBOL_I = counter++;\n\n  SYMBOL_J = counter++;\n\n  SYMBOL_N = counter++;\n\n  SYMBOL_R = counter++;\n\n  SYMBOL_S = counter++;\n\n  SYMBOL_T = counter++;\n\n  SYMBOL_X = counter++;\n\n  SYMBOL_Y = counter++;\n\n  SYMBOL_Z = counter++;\n\n  SYMBOL_IDENTITY_MATRIX = counter++;\n\n  SYMBOL_A_UNDERSCORE = counter++;\n\n  SYMBOL_B_UNDERSCORE = counter++;\n\n  SYMBOL_X_UNDERSCORE = counter++;\n\n  C1 = counter++;\n\n  C2 = counter++;\n\n  C3 = counter++;\n\n  C4 = counter++;\n\n  C5 = counter++;\n\n  C6 = counter++;\n\n  USR_SYMBOLS = counter++; // this must be last\n\n  E = YYE;\n\n  // TOS cannot be arbitrarily large because the OS seg faults on deep recursion.\n  // For example, a circular evaluation like x=x+1 can cause a seg fault.\n  // At this setting (100,000) the evaluation stack overruns before seg fault.\n  TOS = 100000;\n\n  BUF = 10000;\n\n  MAX_PROGRAM_SIZE = 100001;\n\n  MAXPRIMETAB = 10000;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;\n\n  MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;\n\n  //define _USE_MATH_DEFINES // for MS C++\n  MAXDIM = 24;\n\n  // needed for the mechanism to\n  // find all dependencies between variables\n  // in a script\n  symbolsDependencies = {};\n\n  symbolsHavingReassignments = [];\n\n  symbolsInExpressionsWithoutAssignments = [];\n\n  patternHasBeenFound = false;\n\n  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = [\"rationalize\", \"abs\", \"e\", \"i\", \"pi\", \"sin\", \"ceiling\", \"cos\", \"roots\", \"integral\", \"derivative\", \"defint\", \"sqrt\", \"eig\", \"cov\", \"deig\", \"dcov\", \"float\", \"floor\", \"product\", \"root\", \"round\", \"sum\", \"test\", \"unit\"];\n\n  // you can do some little simplifications\n  // at parse time, such as calculating away\n  // immediately simple operations on\n  // constants, removing 1s from products\n  // etc.\n  parse_time_simplifications = true;\n\n  chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n\n  stringsEmittedByUserPrintouts = \"\";\n\n  // flag use to potentially switch on/off some quirks \"deep\"\n  // in the code due to call from Algebra block.\n  // Currently not used.\n  called_from_Algebra_block = false;\n\n  tensor = (function() {\n    class tensor {\n      constructor() {\n        this.dim = (function() {\n          var o, ref, results;\n          results = [];\n          for (o = 0, ref = MAXDIM; (0 <= ref ? o <= ref : o >= ref); 0 <= ref ? o++ : o--) {\n            results.push(0);\n          }\n          return results;\n        })();\n        this.elem = [];\n      }\n\n    };\n\n    tensor.prototype.ndim = 0; // number of dimensions\n\n    tensor.prototype.dim = null; // dimension length, for each dimension\n\n    tensor.prototype.nelem = 0; // total number of elements\n\n    tensor.prototype.elem = null; // an array containing all the data\n\n    return tensor;\n\n  }).call(this);\n\n  display = (function() {\n    class display {};\n\n    display.prototype.h = 0;\n\n    display.prototype.w = 0;\n\n    display.prototype.n = 0;\n\n    display.prototype.a = []; // will contain an array of c,x,y (color,x,y)\n\n    return display;\n\n  }).call(this);\n\n  text_metric = (function() {\n    class text_metric {};\n\n    text_metric.prototype.ascent = 0;\n\n    text_metric.prototype.descent = 0;\n\n    text_metric.prototype.width = 0;\n\n    return text_metric;\n\n  }).call(this);\n\n  tos = 0; // top of stack\n\n  expanding = 0;\n\n  evaluatingAsFloats = 0;\n\n  evaluatingPolar = 0;\n\n  fmt_x = 0;\n\n  fmt_index = 0;\n\n  fmt_level = 0;\n\n  verbosing = 0;\n\n  primetab = (function() {\n    var ceil, i, j, primes;\n    primes = [2];\n    i = 3;\n    while (primes.length < MAXPRIMETAB) {\n      j = 0;\n      ceil = Math.sqrt(i);\n      while (j < primes.length && primes[j] <= ceil) {\n        if (i % primes[j] === 0) {\n          j = -1;\n          break;\n        }\n        j++;\n      }\n      if (j !== -1) {\n        primes.push(i);\n      }\n      i += 2;\n    }\n    primes[MAXPRIMETAB] = 0;\n    return primes;\n  })();\n\n  esc_flag = 0;\n\n  draw_flag = 0;\n\n  mtotal = 0;\n\n  trigmode = 0;\n\n  logbuf = \"\";\n\n  program_buf = \"\";\n\n  // will contain the variable names\n  symtab = [];\n\n  // will contain the contents of the variable\n  // in the corresponding position in symtab array\n  binding = [];\n\n  isSymbolReclaimable = [];\n\n  arglist = []; // will contain U\n\n  stack = []; // will contain *U\n\n  frame = 0;\n\n  p0 = null; // will contain U\n\n  p1 = null; // will contain U\n\n  p2 = null; // will contain U\n\n  p3 = null; // will contain U\n\n  p4 = null; // will contain U\n\n  p5 = null; // will contain U\n\n  p6 = null; // will contain U\n\n  p7 = null; // will contain U\n\n  p8 = null; // will contain U\n\n  p9 = null; // will contain U\n\n  zero = null; // will contain U\n\n  one = null; // will contain U\n\n  one_as_double = null;\n\n  imaginaryunit = null; // will contain U\n\n  out_buf = \"\";\n\n  out_count = 0;\n\n  test_flag = 0;\n\n  codeGen = false;\n\n  draw_stop_return = null; // extern jmp_buf ?????\n\n  userSimplificationsInListForm = [];\n\n  userSimplificationsInStringForm = [];\n\n  transpose_unicode = 7488;\n\n  dotprod_unicode = 183;\n\n  symbol = function(x) {\n    return symtab[x];\n  };\n\n  iscons = function(p) {\n    return p.k === CONS;\n  };\n\n  isrational = function(p) {\n    return p.k === NUM;\n  };\n\n  isdouble = function(p) {\n    return p.k === DOUBLE;\n  };\n\n  isNumericAtom = function(p) {\n    return isrational(p) || isdouble(p);\n  };\n\n  isstr = function(p) {\n    return p.k === STR;\n  };\n\n  istensor = function(p) {\n    if (p == null) {\n      debugger;\n    } else {\n      return p.k === TENSOR;\n    }\n  };\n\n  // because of recursion, we consider a scalar to be\n  // a tensor, so a numeric scalar will return true\n  isNumericAtomOrTensor = function(p) {\n    var a, i, n, o, ref;\n    if (isNumericAtom(p) || p === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      return 1;\n    }\n    if (!istensor(p) && !isNumericAtom(p)) {\n      //console.log \"p not an atom nor a tensor: \" + p\n      return 0;\n    }\n    n = p.tensor.nelem;\n    a = p.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtomOrTensor(a[i])) {\n        //console.log \"non-numeric element: \" + a[i]\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  issymbol = function(p) {\n    return p.k === SYM;\n  };\n\n  iskeyword = function(p) {\n    return issymbol(p) && symnum(p) < NIL;\n  };\n\n  car = function(p) {\n    if (iscons(p)) {\n      return p.cons.car;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  cdr = function(p) {\n    if (iscons(p)) {\n      return p.cons.cdr;\n    } else {\n      return symbol(NIL);\n    }\n  };\n\n  caar = function(p) {\n    return car(car(p));\n  };\n\n  cadr = function(p) {\n    return car(cdr(p));\n  };\n\n  cdar = function(p) {\n    return cdr(car(p));\n  };\n\n  cddr = function(p) {\n    return cdr(cdr(p));\n  };\n\n  caadr = function(p) {\n    return car(car(cdr(p)));\n  };\n\n  caddr = function(p) {\n    return car(cdr(cdr(p)));\n  };\n\n  cadar = function(p) {\n    return car(cdr(car(p)));\n  };\n\n  cdadr = function(p) {\n    return cdr(car(cdr(p)));\n  };\n\n  cddar = function(p) {\n    return cdr(cdr(car(p)));\n  };\n\n  cdddr = function(p) {\n    return cdr(cdr(cdr(p)));\n  };\n\n  caaddr = function(p) {\n    return car(car(cdr(cdr(p))));\n  };\n\n  cadadr = function(p) {\n    return car(cdr(car(cdr(p))));\n  };\n\n  caddar = function(p) {\n    return car(cdr(cdr(car(p))));\n  };\n\n  cdaddr = function(p) {\n    return cdr(car(cdr(cdr(p))));\n  };\n\n  cadddr = function(p) {\n    return car(cdr(cdr(cdr(p))));\n  };\n\n  cddddr = function(p) {\n    return cdr(cdr(cdr(cdr(p))));\n  };\n\n  caddddr = function(p) {\n    return car(cdr(cdr(cdr(cdr(p)))));\n  };\n\n  cadaddr = function(p) {\n    return car(cdr(car(cdr(cdr(p)))));\n  };\n\n  cddaddr = function(p) {\n    return cdr(cdr(car(cdr(cdr(p)))));\n  };\n\n  caddadr = function(p) {\n    return car(cdr(cdr(car(cdr(p)))));\n  };\n\n  cdddaddr = function(p) {\n    return cdr(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  caddaddr = function(p) {\n    return car(cdr(cdr(car(cdr(cdr(p))))));\n  };\n\n  // not used yet\n  listLength = function(p) {\n    var startCount;\n    startCount = -1;\n    while (iscons(p)) {\n      p = cdr(p);\n      startCount++;\n    }\n    return startCount;\n  };\n\n  // not used yet\n  nthCadr = function(p, n) {\n    var startCount;\n    startCount = 0;\n    while (startCount <= n) {\n      p = cdr(p);\n      startCount++;\n    }\n    return car(p);\n  };\n\n  isadd = function(p) {\n    return car(p) === symbol(ADD);\n  };\n\n  ismultiply = function(p) {\n    return car(p) === symbol(MULTIPLY);\n  };\n\n  ispower = function(p) {\n    return car(p) === symbol(POWER);\n  };\n\n  isfactorial = function(p) {\n    return car(p) === symbol(FACTORIAL);\n  };\n\n  isinnerordot = function(p) {\n    return (car(p) === symbol(INNER)) || (car(p) === symbol(DOT));\n  };\n\n  istranspose = function(p) {\n    return car(p) === symbol(TRANSPOSE);\n  };\n\n  isinv = function(p) {\n    return car(p) === symbol(INV);\n  };\n\n  // TODO this is a bit of a shallow check, we should\n  // check when we are passed an actual tensor and possibly\n  // cache the test result.\n  isidentitymatrix = function(p) {\n    return p === symbol(SYMBOL_IDENTITY_MATRIX);\n  };\n\n  MSIGN = function(p) {\n    if (p.isPositive()) {\n      return 1;\n    } else if (p.isZero()) {\n      return 0;\n    } else {\n      return -1;\n    }\n  };\n\n  MLENGTH = function(p) {\n    return p.toString().length;\n  };\n\n  MZERO = function(p) {\n    return p.isZero();\n  };\n\n  MEQUAL = function(p, n) {\n    if (p == null) {\n      debugger;\n    }\n    return p.equals(n);\n  };\n\n  reset_after_error = function() {\n    moveTos(0);\n    esc_flag = 0;\n    draw_flag = 0;\n    frame = TOS;\n    evaluatingAsFloats = 0;\n    return evaluatingPolar = 0;\n  };\n\n  $ = typeof exports !== \"undefined\" && exports !== null ? exports : this;\n\n  $.version = version;\n\n  $.isadd = isadd;\n\n  $.ismultiply = ismultiply;\n\n  $.ispower = ispower;\n\n  $.isfactorial = isfactorial;\n\n  $.car = car;\n\n  $.cdr = cdr;\n\n  $.caar = caar;\n\n  $.cadr = cadr;\n\n  $.cdar = cdar;\n\n  $.cddr = cddr;\n\n  $.caadr = caadr;\n\n  $.caddr = caddr;\n\n  $.cadar = cadar;\n\n  $.cdadr = cdadr;\n\n  $.cddar = cddar;\n\n  $.cdddr = cdddr;\n\n  $.caaddr = caaddr;\n\n  $.cadadr = cadadr;\n\n  $.caddar = caddar;\n\n  $.cdaddr = cdaddr;\n\n  $.cadddr = cadddr;\n\n  $.cddddr = cddddr;\n\n  $.caddddr = caddddr;\n\n  $.cadaddr = cadaddr;\n\n  $.cddaddr = cddaddr;\n\n  $.caddadr = caddadr;\n\n  $.cdddaddr = cdddaddr;\n\n  $.caddaddr = caddaddr;\n\n  $.symbol = symbol;\n\n  $.iscons = iscons;\n\n  $.isrational = isrational;\n\n  $.isdouble = isdouble;\n\n  $.isNumericAtom = isNumericAtom;\n\n  $.isstr = isstr;\n\n  $.istensor = istensor;\n\n  $.issymbol = issymbol;\n\n  $.iskeyword = iskeyword;\n\n  $.CONS = CONS;\n\n  $.NUM = NUM;\n\n  $.DOUBLE = DOUBLE;\n\n  $.STR = STR;\n\n  $.TENSOR = TENSOR;\n\n  $.SYM = SYM;\n\n  \n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* abs =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the absolute value of a real number, the magnitude of a complex number, or the vector length.\n\n  */\n  /*\n   Absolute value of a number,or magnitude of complex z, or norm of a vector\n\n    z    abs(z)\n    -    ------\n\n    a    a\n\n    -a    a\n\n    (-1)^a    1\n\n    exp(a + i b)  exp(a)\n\n    a b    abs(a) abs(b)\n\n    a + i b    sqrt(a^2 + b^2)\n\n  Notes\n\n    1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)\n\n    2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then\n\n      abs(numerator(z)) / abs(denominator(z))\n\n       must be used to get the correct answer. Now the operation is\n       automatic.\n  */\n  DEBUG_ABS = false;\n\n  Eval_abs = function() {\n    push(cadr(p1));\n    Eval();\n    return abs();\n  };\n\n  absValFloat = function() {\n    Eval();\n    absval();\n    Eval();\n    return zzfloat();\n  };\n\n  // zzfloat of an abs doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, these two lines come handy to highlight\n  // when that doesn't happen for those tests.\n  //if !isdouble(stack[tos-1])\n  //  stop(\"absValFloat should return a double and instead got: \" + stack[tos-1])\n  abs = function() {\n    var theArgument;\n    theArgument = top();\n    if (DEBUG_ABS) {\n      console.trace(\">>>>  ABS of \" + theArgument);\n    }\n    numerator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS numerator \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL numerator: \" + stack[tos - 1]);\n    }\n    push(theArgument);\n    denominator();\n    if (DEBUG_ABS) {\n      console.log(\"ABS denominator: \" + stack[tos - 1]);\n    }\n    absval();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL denominator: \" + stack[tos - 1]);\n    }\n    divide();\n    if (DEBUG_ABS) {\n      console.log(\"ABSVAL divided: \" + stack[tos - 1]);\n    }\n    if (DEBUG_ABS) {\n      return console.log(\"<<<<<<<  ABS\");\n    }\n  };\n\n  absval = function() {\n    var anyFactorsYet, input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_ABS) {\n      console.log(\"ABS of \" + p1);\n    }\n    // handle all the \"number\" cases first -----------------------------------------\n    if (isZeroAtomOrTensor(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just zero\");\n      }\n      push(zero);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a negative\");\n      }\n      push(p1);\n      negate();\n      restore();\n      return;\n    }\n    if (ispositivenumber(p1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" just a positive\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (p1 === symbol(PI)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" of PI\");\n      }\n      push(p1);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // ??? should there be a shortcut case here for the imaginary unit?\n\n    // now handle decomposition cases ----------------------------------------------\n\n    // we catch the \"add\", \"power\", \"multiply\" cases first,\n    // before falling back to the\n    // negative/positive cases because there are some\n    // simplification thay we might be able to do.\n    // Note that for this routine to give a correct result, this\n    // must be a sum where a complex number appears.\n    // If we apply this to \"a+b\", we get an incorrect result.\n    if (car(p1) === symbol(ADD) && (findPossibleClockForm(p1) || findPossibleExponentialForm(p1) || Find(p1, imaginaryunit))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a sum\");\n      }\n      if (DEBUG_ABS) {\n        console.log(\"abs of a sum\");\n      }\n      // sum\n      push(p1);\n      rect(); // convert polar terms, if any\n      p1 = pop();\n      push(p1);\n      real();\n      push_integer(2);\n      power();\n      push(p1);\n      imag();\n      push_integer(2);\n      power();\n      add();\n      push_rational(1, 2);\n      power();\n      simplify_trig();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is -1 to any power\");\n      }\n      // -1 to any power\n      if (evaluatingAsFloats) {\n        if (DEBUG_ABS) {\n          console.log(\" abs: numeric, so result is 1.0\");\n        }\n        push_double(1.0);\n      } else {\n        if (DEBUG_ABS) {\n          console.log(\" abs: symbolic, so result is 1\");\n        }\n        push_integer(1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(a^b) is equal to abs(a)^b IF b is positive\n    if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is something to the power of a positive number\");\n      }\n      push(cadr(p1));\n      abs();\n      push(caddr(p1));\n      power();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    // abs(e^something)\n    if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is an exponential\");\n      }\n      // exponential\n      push(caddr(p1));\n      real();\n      exponential();\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is a product\");\n      }\n      // product\n      anyFactorsYet = false;\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        absval();\n        if (anyFactorsYet) {\n          multiply();\n        }\n        anyFactorsYet = true;\n        p1 = cdr(p1);\n      }\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      if (DEBUG_ABS) {\n        console.log(\" abs: \" + p1 + \" is abs of a abs\");\n      }\n      // abs of a abs\n      push_symbol(ABS);\n      push(cadr(p1));\n      list(2);\n      if (DEBUG_ABS) {\n        console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n      }\n      restore();\n      return;\n    }\n    /*\n     * Evaluation via zzfloat()\n     * ...while this is in theory a powerful mechanism, I've commented it\n     * out because I've refined this method enough to not need this.\n     * Evaling via zzfloat() is in principle more problematic because it could\n     * require further evaluations which could end up in further \"abs\" which\n     * would end up in infinite loops. Better not use it if not necessary.\n\n     * we look directly at the float evaluation of the argument\n     * to see if we end up with a number, which would mean that there\n     * is no imaginary component and we can just return the input\n     * (or its negation) as the result.\n    push p1\n    zzfloat()\n    floatEvaluation = pop()\n\n    if (isnegativenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a negative\"\n      push(p1)\n      negate()\n      restore()\n      return\n\n    if (ispositivenumber(floatEvaluation))\n      if DEBUG_ABS then console.log \" abs: \" + p1 + \" just a positive\"\n      push(p1)\n      if DEBUG_ABS then console.log \" --> ABS of \" + input + \" : \" + stack[tos-1]\n      restore()\n      return\n     */\n    if (istensor(p1)) {\n      absval_tensor();\n      restore();\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    if (DEBUG_ABS) {\n      console.log(\" abs: \" + p1 + \" is nothing decomposable\");\n    }\n    push_symbol(ABS);\n    push(p1);\n    list(2);\n    if (DEBUG_ABS) {\n      console.log(\" --> ABS of \" + input + \" : \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // also called the \"norm\" of a vector\n  absval_tensor = function() {\n    if (p1.tensor.ndim !== 1) {\n      stop(\"abs(tensor) with tensor rank > 1\");\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    inner();\n    push_rational(1, 2);\n    power();\n    simplify();\n    return Eval();\n  };\n\n  flag = 0;\n\n  Eval_add = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p2 = pop();\n      push_terms(p2);\n      p1 = cdr(p1);\n    }\n    return add_terms(tos - h);\n  };\n\n  // Add n terms, returns one expression on the stack.\n  stackAddsCount = 0;\n\n  add_terms = function(n) {\n    var h, i, i1, j1, o, ref, ref1, results, s, subsetOfStack;\n    stackAddsCount++;\n    i = 0;\n    h = tos - n;\n    s = h;\n    // ensure no infinite loop, use \"for\"\n    if (DEBUG) {\n      console.log(\"stack before adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 137\n    //  debugger\n    if (DEBUG) {\n      for (i = o = 0, ref = tos; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        console.log(print_list(stack[i]));\n      }\n    }\n    for (i = i1 = 0; i1 < 10; i = ++i1) {\n      if (n < 2) {\n        break;\n      }\n      flag = 0;\n      //qsort(s, n, sizeof (U *), cmp_terms)\n      subsetOfStack = stack.slice(h, h + n);\n      subsetOfStack.sort(cmp_terms);\n      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n      if (flag === 0) {\n        break;\n      }\n      n = combine_terms(h, n);\n    }\n    moveTos(h + n);\n    switch (n) {\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        break;\n      default:\n        list(n);\n        p1 = pop();\n        push_symbol(ADD);\n        push(p1);\n        cons();\n    }\n    if (DEBUG) {\n      console.log(\"stack after adding terms #\" + stackAddsCount);\n    }\n    //if stackAddsCount == 5\n    //  debugger\n    if (DEBUG) {\n      results = [];\n      for (i = j1 = 0, ref1 = tos; (0 <= ref1 ? j1 < ref1 : j1 > ref1); i = 0 <= ref1 ? ++j1 : --j1) {\n        results.push(console.log(print_list(stack[i])));\n      }\n      return results;\n    }\n  };\n\n  // Compare terms for order, clobbers p1 and p2.\n  cmp_terms_count = 0;\n\n  cmp_terms = function(p1, p2) {\n    var i, o, ref, t;\n    cmp_terms_count++;\n    //if cmp_terms_count == 52\n    //  debugger\n    i = 0;\n    // numbers can be combined\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    // congruent tensors can be combined\n    if (istensor(p1) && istensor(p2)) {\n      if (p1.tensor.ndim < p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n        return -1;\n      }\n      if (p1.tensor.ndim > p2.tensor.ndim) {\n        //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n        return 1;\n      }\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns -1\"\n          return -1;\n        }\n        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n          //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 1\"\n          return 1;\n        }\n      }\n      flag = 1;\n      //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns 0\"\n      return 0;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        p1 = cdr(p1);\n        if (cdr(p1) === symbol(NIL)) {\n          p1 = car(p1);\n        }\n      }\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n      if (isNumericAtom(car(p2))) {\n        p2 = cdr(p2);\n        if (cdr(p2) === symbol(NIL)) {\n          p2 = car(p2);\n        }\n      }\n    }\n    t = cmp_expr(p1, p2);\n    if (t === 0) {\n      flag = 1;\n    }\n    //if DEBUG then console.log \"cmp_terms #\" + cmp_terms_count + \" returns \" + t\n    return t;\n  };\n\n  combine_terms = function(s, n) {\n    var i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;\n    //debugger\n\n    // I had to turn the coffeescript for loop into\n    // a more mundane while loop because the i\n    // variable was changed from within the body,\n    // which is something that is not supposed to\n    // happen in the coffeescript 'vector' form.\n    // Also this means I had to add a 'i++' jus before\n    // the end of the body and before the \"continue\"s\n    i = 0;\n    while (i < (n - 1)) {\n      check_esc_flag();\n      p3 = stack[s + i];\n      p4 = stack[s + i + 1];\n      if (istensor(p3) && istensor(p4)) {\n        push(p3);\n        push(p4);\n        tensor_plus_tensor();\n        p1 = pop();\n        if (p1 !== symbol(NIL)) {\n          stack[s + i] = p1;\n          for (j = o = ref = i + 1, ref1 = n - 1; (ref <= ref1 ? o < ref1 : o > ref1); j = ref <= ref1 ? ++o : --o) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n          i--;\n        }\n        i++;\n        continue;\n      }\n      if (istensor(p3) || istensor(p4)) {\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) && isNumericAtom(p4)) {\n        push(p3);\n        push(p4);\n        add_numbers();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          for (j = i1 = ref2 = i, ref3 = n - 2; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); j = ref2 <= ref3 ? ++i1 : --i1) {\n            stack[s + j] = stack[s + j + 2];\n          }\n          n -= 2;\n        } else {\n          stack[s + i] = p1;\n          for (j = j1 = ref4 = i + 1, ref5 = n - 1; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); j = ref4 <= ref5 ? ++j1 : --j1) {\n            stack[s + j] = stack[s + j + 1];\n          }\n          n--;\n        }\n        i--;\n        i++;\n        continue;\n      }\n      if (isNumericAtom(p3) || isNumericAtom(p4)) {\n        i++;\n        continue;\n      }\n      if (evaluatingAsFloats) {\n        p1 = one_as_double;\n        p2 = one_as_double;\n      } else {\n        p1 = one;\n        p2 = one;\n      }\n      t = 0;\n      if (car(p3) === symbol(MULTIPLY)) {\n        p3 = cdr(p3);\n        t = 1;\n        if (isNumericAtom(car(p3))) {\n          p1 = car(p3);\n          p3 = cdr(p3);\n          if (cdr(p3) === symbol(NIL)) {\n            p3 = car(p3);\n            t = 0;\n          }\n        }\n      }\n      if (car(p4) === symbol(MULTIPLY)) {\n        p4 = cdr(p4);\n        if (isNumericAtom(car(p4))) {\n          p2 = car(p4);\n          p4 = cdr(p4);\n          if (cdr(p4) === symbol(NIL)) {\n            p4 = car(p4);\n          }\n        }\n      }\n      if (!equal(p3, p4)) {\n        i++;\n        continue;\n      }\n      push(p1);\n      push(p2);\n      add_numbers();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        for (j = l1 = ref6 = i, ref7 = n - 2; (ref6 <= ref7 ? l1 < ref7 : l1 > ref7); j = ref6 <= ref7 ? ++l1 : --l1) {\n          stack[s + j] = stack[s + j + 2];\n        }\n        n -= 2;\n        i--;\n        i++;\n        continue;\n      }\n      push(p1);\n      if (t) {\n        push(symbol(MULTIPLY));\n        push(p3);\n        cons();\n      } else {\n        push(p3);\n      }\n      multiply();\n      stack[s + i] = pop();\n      for (j = m1 = ref8 = i + 1, ref9 = n - 1; (ref8 <= ref9 ? m1 < ref9 : m1 > ref9); j = ref8 <= ref9 ? ++m1 : --m1) {\n        stack[s + j] = stack[s + j + 1];\n      }\n      n--;\n      i--;\n      // this i++ is to match the while\n      i++;\n    }\n    return n;\n  };\n\n  push_terms = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else if (!isZeroAtom(p)) {\n      return push(p);\n    }\n  };\n\n  // add two expressions\n  add = function() {\n    var h;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push_terms(p1);\n    push_terms(p2);\n    add_terms(tos - h);\n    return restore();\n  };\n\n  add_all = function(k) {\n    var h, i, o, ref, s;\n    i = 0;\n    save();\n    s = tos - k;\n    h = tos;\n    for (i = o = 0, ref = k; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push_terms(stack[s + i]);\n    }\n    add_terms(tos - h);\n    p1 = pop();\n    moveTos(tos - k);\n    push(p1);\n    return restore();\n  };\n\n  subtract = function() {\n    negate();\n    return add();\n  };\n\n  Eval_adj = function() {\n    push(cadr(p1));\n    Eval();\n    return adj();\n  };\n\n  adj = function() {\n    var doNothing, i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"adj: square matrix expected\");\n    }\n    n = p1.tensor.dim[0];\n    p2 = alloc_tensor(n * n);\n    p2.tensor.ndim = 2;\n    p2.tensor.dim[0] = n;\n    p2.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        cofactor(p1, n, i, j);\n        p2.tensor.elem[n * j + i] = pop(); // transpose\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  Eval_approxratio = function() {\n    var theArgument;\n    theArgument = cadr(p1);\n    push(theArgument);\n    return approxratioRecursive();\n  };\n\n  approxratioRecursive = function() {\n    var i, i1, o, ref, ref1;\n    i = 0;\n    save();\n    p1 = pop();\n    if (istensor(p1)) {\n      p4 = alloc_tensor(p1.tensor.nelem);\n      p4.tensor.ndim = p1.tensor.ndim;\n      for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        p4.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n        approxratioRecursive();\n        p4.tensor.elem[i] = pop();\n        check_tensor_dimensions(p4);\n      }\n      push(p4);\n    } else if (p1.k === DOUBLE) {\n      push(p1);\n      approxOneRatioOnly();\n    } else if (iscons(p1)) {\n      push(car(p1));\n      approxratioRecursive();\n      push(cdr(p1));\n      approxratioRecursive();\n      cons();\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  approxOneRatioOnly = function() {\n    var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;\n    zzfloat();\n    supposedlyTheFloat = pop();\n    if (supposedlyTheFloat.k === DOUBLE) {\n      theFloat = supposedlyTheFloat.d;\n      splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n      if (splitBeforeAndAfterDot.length === 2) {\n        numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n        precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n        theRatio = floatToRatioRoutine(theFloat, precision);\n        push_rational(theRatio[0], theRatio[1]);\n      } else {\n        push_integer(theFloat);\n      }\n      return;\n    }\n    // we didn't manage, just leave unexpressed\n    push_symbol(APPROXRATIO);\n    push(theArgument);\n    return list(2);\n  };\n\n  // original routine by John Kennedy, see\n  // https://web.archive.org/web/20111027100847/http://homepage.smc.edu/kennedy_john/DEC2FRAC.PDF\n  // courtesy of Michael Borcherds\n  // who ported this to JavaScript under MIT licence\n  // also see\n  // https://github.com/geogebra/geogebra/blob/master/common/src/main/java/org/geogebra/common/kernel/algos/AlgoFractionText.java\n  // potential other ways to do this:\n  //   https://rosettacode.org/wiki/Convert_decimal_number_to_rational\n  //   http://www.homeschoolmath.net/teaching/rational_numbers.php\n  //   http://stackoverflow.com/questions/95727/how-to-convert-floats-to-human-readable-fractions\n  floatToRatioRoutine = function(decimal, AccuracyFactor) {\n    var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z, ret;\n    FractionNumerator = void 0;\n    FractionDenominator = void 0;\n    DecimalSign = void 0;\n    Z = void 0;\n    PreviousDenominator = void 0;\n    ScratchValue = void 0;\n    ret = [0, 0];\n    if (isNaN(decimal)) {\n      return ret;\n    }\n    // return 0/0 \n    if (decimal === 2e308) {\n      ret[0] = 1;\n      ret[1] = 0;\n      // 1/0\n      return ret;\n    }\n    if (decimal === -2e308) {\n      ret[0] = -1;\n      ret[1] = 0;\n      // -1/0\n      return ret;\n    }\n    if (decimal < 0.0) {\n      DecimalSign = -1.0;\n    } else {\n      DecimalSign = 1.0;\n    }\n    decimal = Math.abs(decimal);\n    if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {\n      // handles exact integers including 0 \n      FractionNumerator = decimal * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal < 1.0e-19) {\n      // X = 0 already taken care of \n      FractionNumerator = DecimalSign;\n      FractionDenominator = 9999999999999999999.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    if (decimal > 1.0e19) {\n      FractionNumerator = 9999999999999999999.0 * DecimalSign;\n      FractionDenominator = 1.0;\n      ret[0] = FractionNumerator;\n      ret[1] = FractionDenominator;\n      return ret;\n    }\n    Z = decimal;\n    PreviousDenominator = 0.0;\n    FractionDenominator = 1.0;\n    while (true) {\n      Z = 1.0 / (Z - Math.floor(Z));\n      ScratchValue = FractionDenominator;\n      FractionDenominator = FractionDenominator * Math.floor(Z) + PreviousDenominator;\n      PreviousDenominator = ScratchValue;\n      FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);\n      // Rounding Function\n      if (!(Math.abs(decimal - (FractionNumerator / FractionDenominator)) > AccuracyFactor && Z !== Math.floor(Z))) {\n        break;\n      }\n    }\n    FractionNumerator = DecimalSign * FractionNumerator;\n    ret[0] = FractionNumerator;\n    ret[1] = FractionDenominator;\n    return ret;\n  };\n\n  approx_just_an_integer = 0;\n\n  approx_sine_of_rational = 1;\n\n  approx_sine_of_pi_times_rational = 2;\n\n  approx_rationalOfPi = 3;\n\n  approx_radicalOfRatio = 4;\n\n  approx_nothingUseful = 5;\n\n  approx_ratioOfRadical = 6;\n\n  approx_rationalOfE = 7;\n\n  approx_logarithmsOfRationals = 8;\n\n  approx_rationalsOfLogarithms = 9;\n\n  approxRationalsOfRadicals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      for (j = i1 = 1; i1 <= 10; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sqrt( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicalsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, ref, ref1, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n    ref = [1, 2, 3, 5, 6, 7, 8, 10];\n    // this one catches things like Math.sqrt(3/4), but\n    // things like Math.sqrt(1/2) are caught by the paragraph\n    // above (and in a better form)\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.sqrt(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (sqrt( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRadicals = function(theFloat) {\n    var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // simple radicals.\n\n    // we always prefer a rational of a radical of an integer\n    // to a radical of a rational. Radicals of rationals generate\n    // radicals at the denominator which we'd rather avoid\n    approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);\n    if (approxRationalsOfRadicalsResult != null) {\n      return approxRationalsOfRadicalsResult;\n    }\n    approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);\n    if (approxRadicalsOfRationalsResult != null) {\n      return approxRadicalsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxLogs = function(theFloat) {\n    var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a rational of a log to a log of\n    // a rational\n    approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);\n    if (approxRationalsOfLogsResult != null) {\n      return approxRationalsOfLogsResult;\n    }\n    approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);\n    if (approxLogsOfRationalsResult != null) {\n      return approxLogsOfRationalsResult;\n    }\n    return null;\n  };\n\n  approxRationalsOfLogs = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of logs\n    for (i = o = 2; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n\n        // it does happen that due to roundings \n        // a \"higher multiple\" is picked, which is obviously\n        // unintended.\n        // E.g. 1 * log(1 / 3 ) doesn't match log( 3 ) BUT\n        // it matches -5 * log( 3 ) / 5\n        // so we avoid any case where the multiplier is a multiple\n        // of the divisor.\n        if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j)) === Math.abs(likelyMultiplier / j)) {\n          continue;\n        }\n        if (error < 2.2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxLogsOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple logs of rationals\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 5; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.log(i / j);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 1.96 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * log( \" + i + \" / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfE = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of e\n    for (i = o = 1; o <= 2; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.E, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (e ^ \" + i + \" ) / \" + j;\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxRationalsOfPowersOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    // here we do somethng a little special: since\n    // the powers of pi can get quite big, there might\n    // be multiple hypothesis where more of the\n    // magnitude is shifted to the multiplier, and some\n    // where more of the magnitude is shifted towards the\n    // exponent of pi. So we prefer the hypotheses with the\n    // lower multiplier since it's likely to insert more\n    // information.\n    minimumComplexity = Number.MAX_VALUE;\n// simple rationals of a few powers of PI\n    for (i = o = 1; o <= 5; i = ++o) {\n      for (j = i1 = 1; i1 <= 12; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        hypothesis = Math.pow(Math.PI, i) / j;\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * (pi ^ \" + i + \" ) / \" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    //console.log \"approxRationalsOfPowersOfPI returning: \" + bestResultSoFar\n    return bestResultSoFar;\n  };\n\n  approxTrigonometric = function(theFloat) {\n    var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    // we always prefer a sin of a rational without the PI\n    approxSineOfRationalsResult = approxSineOfRationals(theFloat);\n    if (approxSineOfRationalsResult != null) {\n      return approxSineOfRationalsResult;\n    }\n    approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);\n    if (approxSineOfRationalMultiplesOfPIResult != null) {\n      return approxSineOfRationalMultiplesOfPIResult;\n    }\n    return null;\n  };\n\n  approxSineOfRationals = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// we only check very simple rationals because they begin to get tricky\n// quickly, also they collide often with the \"rational of pi\" hypothesis.\n// For example sin(11) is veeery close to 1 (-0.99999020655)\n// (see: http://mathworld.wolfram.com/AlmostInteger.html )\n// we stop at rationals that mention up to 10\n    for (i = o = 1; o <= 4; i = ++o) {\n      for (j = i1 = 1; i1 <= 4; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        if (error < 2 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxSineOfRationalMultiplesOfPI = function(theFloat) {\n    var bestResultSoFar, complexity, error, fraction, hypothesis, i, i1, j, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o, precision, ratio, result, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    bestResultSoFar = null;\n    minimumComplexity = Number.MAX_VALUE;\n// check rational multiples of pi\n    for (i = o = 1; o <= 13; i = ++o) {\n      for (j = i1 = 1; i1 <= 13; j = ++i1) {\n        //console.log  \"i,j: \" + i + \",\" + j\n        fraction = i / j;\n        hypothesis = Math.sin(Math.PI * fraction);\n        //console.log  \"hypothesis: \" + hypothesis\n        if (Math.abs(hypothesis) > 1e-10) {\n          ratio = theFloat / hypothesis;\n          likelyMultiplier = Math.round(ratio);\n          //console.log  \"ratio: \" + ratio\n          error = Math.abs(1 - ratio / likelyMultiplier);\n        } else {\n          ratio = 1;\n          likelyMultiplier = 1;\n          error = Math.abs(theFloat - hypothesis);\n        }\n        //console.log  \"error: \" + error\n        // magic number 23 comes from the case sin(pi/10)\n        if (error < 23 * precision) {\n          complexity = simpleComplexityMeasure(likelyMultiplier, i, j);\n          if (complexity < minimumComplexity) {\n            //console.log \"MINIMUM MULTIPLIER SO FAR\"\n            minimumComplexity = complexity;\n            result = likelyMultiplier + \" * sin( \" + i + \"/\" + j + \" * pi )\";\n            //console.log result + \" error: \" + error\n            bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i, j];\n          }\n        }\n      }\n    }\n    return bestResultSoFar;\n  };\n\n  approxAll = function(theFloat) {\n    var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;\n    splitBeforeAndAfterDot = theFloat.toString().split(\".\");\n    if (splitBeforeAndAfterDot.length === 2) {\n      numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;\n      precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);\n    } else {\n      return [\"\" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];\n    }\n    console.log(\"precision: \" + precision);\n    constantsSumMin = Number.MAX_VALUE;\n    constantsSum = 0;\n    bestApproxSoFar = null;\n    LOG_EXPLANATIONS = true;\n    approxRadicalsResult = approxRadicals(theFloat);\n    if (approxRadicalsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRadicalsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRadicalsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRadicals: \" + approxRadicalsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxLogsResult = approxLogs(theFloat);\n    if (approxLogsResult != null) {\n      constantsSum = simpleComplexityMeasure(approxLogsResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxLogsResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxLogs: \" + approxLogsResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);\n    if (approxRationalsOfPowersOfEResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfEResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfE: \" + approxRationalsOfPowersOfEResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);\n    if (approxRationalsOfPowersOfPIResult != null) {\n      constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxRationalsOfPowersOfPIResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxRationalsOfPowersOfPI: \" + approxRationalsOfPowersOfPIResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    approxTrigonometricResult = approxTrigonometric(theFloat);\n    if (approxTrigonometricResult != null) {\n      constantsSum = simpleComplexityMeasure(approxTrigonometricResult);\n      if (constantsSum < constantsSumMin) {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"better explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n        constantsSumMin = constantsSum;\n        bestApproxSoFar = approxTrigonometricResult;\n      } else {\n        if (LOG_EXPLANATIONS) {\n          console.log(\"subpar explanation by approxTrigonometric: \" + approxTrigonometricResult + \" complexity: \" + constantsSum);\n        }\n      }\n    }\n    return bestApproxSoFar;\n  };\n\n  simpleComplexityMeasure = function(aResult, b, c) {\n    var theSum;\n    theSum = null;\n    if (aResult instanceof Array) {\n      // we want PI and E to somewhat increase the\n      // complexity of the expression, so basically they count\n      // more than any integer lower than 3, i.e. we consider\n      // 1,2,3 to be more fundamental than PI or E.\n      switch (aResult[1]) {\n        case approx_sine_of_pi_times_rational:\n          theSum = 4;\n          break;\n        // exponents of PI and E need to be penalised as well\n        // otherwise they come to explain any big number\n        // so we count them just as much as the multiplier\n        case approx_rationalOfPi:\n          theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        case approx_rationalOfE:\n          theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);\n          break;\n        default:\n          theSum = 0;\n      }\n      theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));\n    } else {\n      theSum += Math.abs(aResult) * (Math.abs(b) + Math.abs(c));\n    }\n    \n    // heavily discount unit constants\n    if (aResult[2] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[3] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (aResult[4] === 1) {\n      theSum -= 1;\n    } else {\n      theSum += 1;\n    }\n    if (theSum < 0) {\n      theSum = 0;\n    }\n    return theSum;\n  };\n\n  testApprox = function() {\n    var error, fraction, i, i1, i2, i3, j, j1, j2, j3, k3, l1, l2, l3, len, len1, len2, len3, len4, len5, len6, len7, m1, m2, m3, n1, n2, o, o1, o2, originalValue, q1, q2, r1, r2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s2, t1, t2, u1, u2, v1, v2, value, x1, x2, z1, z2;\n    ref = [2, 3, 5, 6, 7, 8, 10];\n    for (o = 0, len = ref.length; o < len; o++) {\n      i = ref[o];\n      ref1 = [2, 3, 5, 6, 7, 8, 10];\n      for (i1 = 0, len1 = ref1.length; i1 < len1; i1++) {\n        j = ref1[i1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.sqrt(i) / j;\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref2 = [2, 3, 5, 6, 7, 8, 10];\n    for (j1 = 0, len2 = ref2.length; j1 < len2; j1++) {\n      i = ref2[j1];\n      ref3 = [2, 3, 5, 6, 7, 8, 10];\n      for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {\n        j = ref3[l1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.sqrt(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits: \" + \"1 * sqrt( \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    ref4 = [2, 3, 5, 6, 7, 8, 10];\n    for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {\n      i = ref4[m1];\n      ref5 = [2, 3, 5, 6, 7, 8, 10];\n      for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {\n        j = ref5[n1];\n        if (i === j) {\n          continue; // this is just 1\n        }\n        console.log(\"testapproxRadicals testing: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.sqrt(i / j);\n        returned = approxRadicals(value);\n        if (returned != null) {\n          returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n          if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {\n            console.log(\"fail testapproxRadicals: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n          }\n        }\n      }\n    }\n    ref6 = [1, 2, 3, 5, 6, 7, 8, 10];\n    for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {\n      i = ref6[o1];\n      ref7 = [1, 2, 3, 5, 6, 7, 8, 10];\n      for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {\n        j = ref7[q1];\n        if (i === 1 && j === 1) {\n          continue;\n        }\n        console.log(\"testapproxRadicals testing with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sqrt(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxRadicals(value);\n        returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);\n        if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testapproxRadicals with 4 digits:: \" + \"1 * sqrt( \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r1 = 1; r1 <= 5; i = ++r1) {\n      for (j = s1 = 1; s1 <= 5; j = ++s1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.log(i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t1 = 1; t1 <= 5; i = ++t1) {\n      for (j = u1 = 1; u1 <= 5; j = ++u1) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.log(i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = v1 = 1; v1 <= 5; i = ++v1) {\n      for (j = x1 = 1; x1 <= 5; j = ++x1) {\n        console.log(\"testApproxAll testing: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        value = Math.log(i / j);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = z1 = 1; z1 <= 5; i = ++z1) {\n      for (j = i2 = 1; i2 <= 5; j = ++i2) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.log(i / j);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.log(returned[3] / returned[4]);\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * log(\" + i + \" / \" + j + \" )\" + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = j2 = 1; j2 <= 2; i = ++j2) {\n      for (j = l2 = 1; l2 <= 12; j = ++l2) {\n        console.log(\"testApproxAll testing: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.E, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = m2 = 1; m2 <= 2; i = ++m2) {\n      for (j = n2 = 1; n2 <= 12; j = ++n2) {\n        console.log(\"approxRationalsOfPowersOfE testing with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.E, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfE(value);\n        returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfE with 4 digits: \" + \"1 * (e ^ \" + i + \" ) / \" + j + \" . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = o2 = 1; o2 <= 2; i = ++o2) {\n      for (j = q2 = 1; q2 <= 12; j = ++q2) {\n        console.log(\"testApproxAll testing: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        value = Math.pow(Math.PI, i) / j;\n        returned = approxAll(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = r2 = 1; r2 <= 2; i = ++r2) {\n      for (j = s2 = 1; s2 <= 12; j = ++s2) {\n        console.log(\"approxRationalsOfPowersOfPI testing with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j);\n        fraction = i / j;\n        originalValue = Math.pow(Math.PI, i) / j;\n        value = originalValue.toFixed(4);\n        returned = approxRationalsOfPowersOfPI(value);\n        returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];\n        if (Math.abs(originalValue - returnedValue) > 1e-15) {\n          console.log(\"fail approxRationalsOfPowersOfPI with 4 digits: \" + \"1 * pi ^ \" + i + \" / \" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = t2 = 1; t2 <= 4; i = ++t2) {\n      for (j = u2 = 1; u2 <= 4; j = ++u2) {\n        console.log(\"testApproxAll testing: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        value = Math.sin(fraction);\n        returned = approxAll(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail testApproxAll: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned);\n        }\n      }\n    }\n// 5 digits create no problem\n    for (i = v2 = 1; v2 <= 4; i = ++v2) {\n      for (j = x2 = 1; x2 <= 4; j = ++x2) {\n        console.log(\"testApproxAll testing with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(5);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 5 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n// 4 digits create two collisions\n    for (i = z2 = 1; z2 <= 4; i = ++z2) {\n      for (j = i3 = 1; i3 <= 4; j = ++i3) {\n        console.log(\"testApproxAll testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" )\");\n        fraction = i / j;\n        originalValue = Math.sin(fraction);\n        value = originalValue.toFixed(4);\n        returned = approxAll(value);\n        if (returned == null) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained:  undefined \");\n        }\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail testApproxAll with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    value = 0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0\");\n    }\n    value = 0.0;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0\");\n    }\n    value = 0.00;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.00\");\n    }\n    value = 0.000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.000\");\n    }\n    value = 0.0000;\n    if (approxAll(value)[0] !== \"0\") {\n      console.log(\"fail testApproxAll: 0.0000\");\n    }\n    value = 1;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1\");\n    }\n    value = 1.0;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0\");\n    }\n    value = 1.00;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00\");\n    }\n    value = 1.000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.000\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 1.00000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.00000\");\n    }\n    value = Math.sqrt(2);\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2)\");\n    }\n    value = 1.41;\n    if (approxAll(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail testApproxAll: 1.41\");\n    }\n    // if we narrow down to a particular family then we can get\n    // an OK guess even with few digits, expecially for really \"famous\" numbers\n    value = 1.4;\n    if (approxRadicals(value)[0] !== \"1 * sqrt( 2 ) / 1\") {\n      console.log(\"fail approxRadicals: 1.4\");\n    }\n    value = 0.6;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.6\");\n    }\n    value = 0.69;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.69\");\n    }\n    value = 0.7;\n    if (approxLogs(value)[0] !== \"1 * log( 2 ) / 1\") {\n      console.log(\"fail approxLogs: 0.7\");\n    }\n    value = 1.09;\n    if (approxLogs(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxLogs: 1.09\");\n    }\n    value = 1.09;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.09\");\n    }\n    value = 1.098;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.098\");\n    }\n    value = 1.1;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.1\");\n    }\n    value = 1.11;\n    if (approxAll(value)[0] !== \"1 * log( 3 ) / 1\") {\n      console.log(\"fail approxAll: 1.11\");\n    }\n    value = Math.sqrt(3);\n    if (approxAll(value)[0] !== \"1 * sqrt( 3 ) / 1\") {\n      console.log(\"fail testApproxAll: Math.sqrt(3)\");\n    }\n    value = 1.0000;\n    if (approxAll(value)[0] !== \"1\") {\n      console.log(\"fail testApproxAll: 1.0000\");\n    }\n    value = 3.141592;\n    if (approxAll(value)[0] !== \"1 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 3.141592\");\n    }\n    value = 31.41592;\n    if (approxAll(value)[0] !== \"10 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31.41592\");\n    }\n    value = 314.1592;\n    if (approxAll(value)[0] !== \"100 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 314.1592\");\n    }\n    value = 31415926.53589793;\n    if (approxAll(value)[0] !== \"10000000 * (pi ^ 1 ) / 1 )\") {\n      console.log(\"fail testApproxAll: 31415926.53589793\");\n    }\n    value = Math.sqrt(2);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/4 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(2)\");\n    }\n    value = Math.sqrt(3);\n    if (approxTrigonometric(value)[0] !== \"2 * sin( 1/3 * pi )\") {\n      console.log(\"fail approxTrigonometric: Math.sqrt(3)\");\n    }\n    value = (Math.sqrt(6) - Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 - Math.sqrt(2)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 1/8 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2\");\n    }\n    value = (Math.sqrt(6) + Math.sqrt(2)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4\");\n    }\n    value = Math.sqrt(2 + Math.sqrt(3)) / 2;\n    if (approxAll(value)[0] !== \"1 * sin( 5/12 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2\");\n    }\n    value = (Math.sqrt(5) - 1) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/10 * pi )\") {\n      console.log(\"fail testApproxAll: (Math.sqrt(5) - 1)/4\");\n    }\n    value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;\n    if (approxAll(value)[0] !== \"1 * sin( 1/5 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 7);\n    if (approxAll(value)[0] !== \"1 * sin( 1/7 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/7)\");\n    }\n    // this has a radical form but it's too long to write\n    value = Math.sin(Math.PI / 9);\n    if (approxAll(value)[0] !== \"1 * sin( 1/9 * pi )\") {\n      console.log(\"fail testApproxAll: Math.sin(Math.PI/9)\");\n    }\n    value = 1836.15267;\n    if (approxRationalsOfPowersOfPI(value)[0] !== \"6 * (pi ^ 5 ) / 1 )\") {\n      console.log(\"fail approxRationalsOfPowersOfPI: 1836.15267\");\n    }\n    for (i = j3 = 1; j3 <= 13; i = ++j3) {\n      for (j = k3 = 1; k3 <= 13; j = ++k3) {\n        console.log(\"approxTrigonometric testing: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        value = Math.sin(Math.PI * fraction);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        if (Math.abs(value - returnedValue) > 1e-15) {\n          console.log(\"fail approxTrigonometric: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned);\n        }\n      }\n    }\n    for (i = l3 = 1; l3 <= 13; i = ++l3) {\n      for (j = m3 = 1; m3 <= 13; j = ++m3) {\n        // with four digits, there are two collisions with the\n        // \"simple fraction\" argument hypotesis, which we prefer since\n        // it's a simpler expression, so let's skip those\n        // two tests\n        if (i === 5 && j === 11 || i === 6 && j === 11) {\n          continue;\n        }\n        console.log(\"approxTrigonometric testing with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi )\");\n        fraction = i / j;\n        originalValue = Math.sin(Math.PI * fraction);\n        value = originalValue.toFixed(4);\n        // we specifically search for sines of rational multiples of PI\n        // because too many of them would be picked up as simple\n        // rationals.\n        returned = approxTrigonometric(value);\n        returnedFraction = returned[3] / returned[4];\n        returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);\n        error = Math.abs(originalValue - returnedValue);\n        if (error > 1e-14) {\n          console.log(\"fail approxTrigonometric with 4 digits: \" + \"1 * sin( \" + i + \"/\" + j + \" * pi ) . obtained: \" + returned + \" error: \" + error);\n        }\n      }\n    }\n    return console.log(\"testApprox done\");\n  };\n\n  $.approxRadicals = approxRadicals;\n\n  $.approxRationalsOfLogs = approxRationalsOfLogs;\n\n  $.approxAll = approxAll;\n\n  $.testApprox = testApprox;\n\n  Eval_arccos = function() {\n    push(cadr(p1));\n    Eval();\n    return arccos();\n  };\n\n  arccos = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.acos(p1.d);\n      if (errno) {\n        stop(\"arccos function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 4.0);\n      } else {\n        push_rational(1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return 3/4*pi (135 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI * 3.0 / 4.0);\n      } else {\n        push_rational(3, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/6*pi (30 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 6.0);\n      } else {\n        push_rational(1, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return 5/6*pi (150 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(5.0 * Math.PI / 6.0);\n      } else {\n        push_rational(5, 6);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCCOS);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push_symbol(PI);\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI * 2.0 / 3.0);\n        } else {\n          push_rational(2, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 3.0);\n        } else {\n          push_rational(1, 3);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      default:\n        push_symbol(ARCCOS);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arccosh = function() {\n    push(cadr(p1));\n    Eval();\n    return arccosh();\n  };\n\n  arccosh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COSH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < 1.0) {\n        stop(\"arccosh function argument is less than 1.0\");\n      }\n      d = Math.log(d + Math.sqrt(d * d - 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isplusone(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCCOSH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arcsin = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsin();\n  };\n\n  arcsin = function() {\n    var d, errno, n;\n    n = 0;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.asin(p1.d);\n      if (errno) {\n        stop(\"arcsin function argument is not in the interval [-1,1]\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    // if p1 == 1/sqrt(2) then return 1/4*pi (45 degrees)\n    // second if catches the other way of saying it, sqrt(2)/2\n    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 4);\n      push_symbol(PI);\n      multiply();\n      restore();\n      return;\n    }\n    // if p1 == -1/sqrt(2) then return -1/4*pi (-45 degrees)\n    // second if catches the other way of saying it, -sqrt(2)/2\n    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 4.0);\n      } else {\n        push_rational(-1, 4);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == sqrt(3)/2 then return 1/3*pi (60 degrees)\n    if (issqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI / 3.0);\n      } else {\n        push_rational(1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    // if p1 == -sqrt(3)/2 then return -1/3*pi (-60 degrees)\n    if (isminussqrtthreeovertwo(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(-Math.PI / 3.0);\n      } else {\n        push_rational(-1, 3);\n        push_symbol(PI);\n        multiply();\n      }\n      restore();\n      return;\n    }\n    if (!isrational(p1)) {\n      push_symbol(ARCSIN);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    push(p1);\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    switch (n) {\n      case -2:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 2.0);\n        } else {\n          push_rational(-1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case -1:\n        if (evaluatingAsFloats) {\n          push_double(-Math.PI / 6.0);\n        } else {\n          push_rational(-1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 0:\n        if (evaluatingAsFloats) {\n          push_double(0.0);\n        } else {\n          push(zero);\n        }\n        break;\n      case 1:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 6.0);\n        } else {\n          push_rational(1, 6);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      case 2:\n        if (evaluatingAsFloats) {\n          push_double(Math.PI / 2.0);\n        } else {\n          push_rational(1, 2);\n          push_symbol(PI);\n          multiply();\n        }\n        break;\n      default:\n        push_symbol(ARCSIN);\n        push(p1);\n        list(2);\n    }\n    return restore();\n  };\n\n  Eval_arcsinh = function() {\n    push(cadr(p1));\n    Eval();\n    return arcsinh();\n  };\n\n  arcsinh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(SINH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      d = Math.log(d + Math.sqrt(d * d + 1.0));\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCSINH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctan = function() {\n    push(cadr(p1));\n    Eval();\n    return arctan();\n  };\n\n  arctan = function() {\n    var d, errno;\n    d = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TAN)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      errno = 0;\n      d = Math.atan(p1.d);\n      if (errno) {\n        stop(\"arctan function error\");\n      }\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      arctan();\n      negate();\n      restore();\n      return;\n    }\n    // arctan(sin(a) / cos(a)) ?\n    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {\n      push(p1);\n      numerator();\n      p2 = pop();\n      push(p1);\n      denominator();\n      p3 = pop();\n      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {\n        push(cadr(p2));\n        restore();\n        return;\n      }\n    }\n    // arctan(1/sqrt(3)) -> pi/6\n    // second if catches the other way of saying it, sqrt(3)/3\n    if ((car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {\n      push_rational(1, 6);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(1) -> pi/4\n    if (equaln(p1, 1)) {\n      push_rational(1, 4);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    // arctan(sqrt(3)) -> pi/3\n    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {\n      push_rational(1, 3);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      multiply();\n      restore();\n      return;\n    }\n    push_symbol(ARCTAN);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  Eval_arctanh = function() {\n    push(cadr(p1));\n    Eval();\n    return arctanh();\n  };\n\n  arctanh = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(TANH)) {\n      push(cadr(p1));\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = p1.d;\n      if (d < -1.0 || d > 1.0) {\n        stop(\"arctanh function argument is not in the interval [-1,1]\");\n      }\n      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;\n      push_double(d);\n      restore();\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      restore();\n      return;\n    }\n    push_symbol(ARCTANH);\n    push(p1);\n    list(2);\n    return restore();\n  };\n\n  DEBUG_ARG = false;\n\n  Eval_arg = function() {\n    push(cadr(p1));\n    Eval();\n    return arg();\n  };\n\n  arg = function() {\n    save();\n    p1 = pop();\n    push(p1);\n    numerator();\n    yyarg();\n    push(p1);\n    denominator();\n    yyarg();\n    subtract();\n    return restore();\n  };\n\n  //define RE p2\n  //define IM p3\n  yyarg = function() {\n    save();\n    p1 = pop();\n    // case of plain number\n    if (ispositivenumber(p1) || p1 === symbol(PI)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(0);\n      } else {\n        push_integer(0);\n      }\n    } else if (isnegativenumber(p1)) {\n      if (isdouble(p1) || evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      negate();\n    // you'd think that something like\n    // arg(a) is always 0 when a is real but no,\n    // arg(a) is pi when a is negative so we have\n    // to leave unexpressed\n    } else if (issymbol(p1)) {\n      push_symbol(ARG);\n      push(p1);\n      list(2);\n    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {\n      // -1 to a power\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push(symbol(PI));\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {\n      // exponential\n      push(caddr(p1));\n      imag();\n    // arg(a^(1/2)) is always equal to 1/2 * arg(a)\n    // this can obviously be made more generic TODO\n    } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {\n      if (DEBUG_ARG) {\n        console.log(\"arg of a sqrt: \" + p1);\n      }\n      if (DEBUG_ARG) {\n        debugger;\n      }\n      push(cadr(p1));\n      arg();\n      if (DEBUG_ARG) {\n        console.log(\" = 1/2 * \" + stack[tos - 1]);\n      }\n      push(caddr(p1));\n      multiply();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      // product of factors\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        arg();\n        add();\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(ADD)) {\n      // sum of terms\n      push(p1);\n      rect();\n      p1 = pop();\n      push(p1);\n      real();\n      p2 = pop();\n      push(p1);\n      imag();\n      p3 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        if (evaluatingAsFloats) {\n          push_double(Math.PI);\n        } else {\n          push(symbol(PI));\n        }\n        if (isnegative(p3)) {\n          negate();\n        }\n      } else {\n        push(p3);\n        push(p2);\n        divide();\n        arctan();\n        if (isnegative(p2)) {\n          if (evaluatingAsFloats) {\n            push_double(Math.PI);\n          } else {\n            push_symbol(PI);\n          }\n          if (isnegative(p3)) {\n            subtract(); // quadrant 1 -> 3\n          } else {\n            add(); // quadrant 4 -> 2\n          }\n        }\n      }\n    } else {\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        // if we assume all passed values are real\n        push_integer(0);\n      } else {\n        // if we don't assume all passed values are real, all\n        // we con do is to leave unexpressed\n        push_symbol(ARG);\n        push(p1);\n        list(2);\n      }\n    }\n    return restore();\n  };\n\n  // pretty print\n  bake = function() {\n    var h, s, t, x, y, z;\n    h = 0;\n    s = 0;\n    t = 0;\n    x = 0;\n    y = 0;\n    z = 0;\n    expanding++;\n    save();\n    p1 = pop();\n    s = ispolyexpandedform(p1, symbol(SYMBOL_S));\n    t = ispolyexpandedform(p1, symbol(SYMBOL_T));\n    x = ispolyexpandedform(p1, symbol(SYMBOL_X));\n    y = ispolyexpandedform(p1, symbol(SYMBOL_Y));\n    z = ispolyexpandedform(p1, symbol(SYMBOL_Z));\n    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_S);\n      bake_poly();\n    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_T);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {\n      p2 = symbol(SYMBOL_X);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {\n      p2 = symbol(SYMBOL_Y);\n      bake_poly();\n    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {\n      p2 = symbol(SYMBOL_Z);\n      bake_poly();\n    // don't bake the contents of some constructs such as \"for\"\n    // because we don't want to evaluate the body of\n    // such constructs \"statically\", i.e. without fully running\n    // the loops.\n    } else if ((iscons(p1)) && car(p1) !== symbol(FOR)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        bake();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n    return expanding--;\n  };\n\n  polyform = function() {\n    var h;\n    h = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (ispolyexpandedform(p1, p2)) {\n      bake_poly();\n    } else if (iscons(p1)) {\n      h = tos;\n      push(car(p1));\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        polyform();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  bake_poly = function() {\n    var a, h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    //U **a\n    a = tos;\n    k = coeff(p2, p1);\n    h = tos;\n    for (i = o = ref = k - 1; o >= 0; i = o += -1) {\n      p1 = stack[a + i];\n      bake_poly_term(i);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(ADD));\n      swap();\n      cons();\n    }\n    p1 = pop();\n    moveTos(tos - k);\n    return push(p1);\n  };\n\n  // p1 points to coefficient of p2 ^ k\n\n  // k is an int\n  bake_poly_term = function(k) {\n    var h, n;\n    h = 0;\n    n = 0;\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    // constant term?\n    if (k === 0) {\n      if (car(p1) === symbol(ADD)) {\n        p1 = cdr(p1);\n        while (iscons(p1)) {\n          push(car(p1));\n          p1 = cdr(p1);\n        }\n      } else {\n        push(p1);\n      }\n      return;\n    }\n    h = tos;\n    // coefficient\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else if (!equaln(p1, 1)) {\n      push(p1);\n    }\n    // x ^ k\n    if (k === 1) {\n      push(p2);\n    } else {\n      push(symbol(POWER));\n      push(p2);\n      push_integer(k);\n      list(3);\n    }\n    n = tos - h;\n    if (n > 1) {\n      list(n);\n      push(symbol(MULTIPLY));\n      swap();\n      return cons();\n    }\n  };\n\n  Eval_besselj = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return besselj();\n  };\n\n  besselj = function() {\n    save();\n    yybesselj();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  //define SGN p3\n  yybesselj = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    // numerical result\n    if (isdouble(p1) && !isNaN(n)) {\n      d = jn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    // bessej(0,0) = 1\n    if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {\n      push_integer(1);\n      return;\n    }\n    // besselj(0,n) = 0\n    if (isZeroAtomOrTensor(p1) && !isNaN(n)) {\n      push_integer(0);\n      return;\n    }\n    // half arguments\n    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {\n      // n = 1/2\n      if (MEQUAL(p2.q.a, 1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        sine();\n        multiply();\n        return;\n      }\n      // n = -1/2\n      if (MEQUAL(p2.q.a, -1)) {\n        if (evaluatingAsFloats) {\n          push_double(2.0 / Math.PI);\n        } else {\n          push_integer(2);\n          push_symbol(PI);\n          divide();\n        }\n        push(p1);\n        divide();\n        push_rational(1, 2);\n        power();\n        push(p1);\n        cosine();\n        multiply();\n        return;\n      }\n      // besselj(x,n) = (2/x) (n-sgn(n)) besselj(x,n-sgn(n)) - besselj(x,n-2*sgn(n))\n      push_integer(MSIGN(p2.q.a));\n      p3 = pop();\n      push_integer(2);\n      push(p1);\n      divide();\n      push(p2);\n      push(p3);\n      subtract();\n      multiply();\n      push(p1);\n      push(p2);\n      push(p3);\n      subtract();\n      besselj();\n      multiply();\n      push(p1);\n      push(p2);\n      push_integer(2);\n      push(p3);\n      multiply();\n      subtract();\n      besselj();\n      subtract();\n      return;\n    }\n    //if 0 # test cases needed\n    if (isnegativeterm(p1)) {\n      push(p1);\n      negate();\n      push(p2);\n      power();\n      push(p1);\n      push(p2);\n      negate();\n      power();\n      multiply();\n      push_symbol(BESSELJ);\n      push(p1);\n      negate();\n      push(p2);\n      list(3);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELJ);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    //endif\n    push(symbol(BESSELJ));\n    push(p1);\n    push(p2);\n    return list(3);\n  };\n\n  Eval_bessely = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return bessely();\n  };\n\n  bessely = function() {\n    save();\n    yybessely();\n    return restore();\n  };\n\n  //define X p1\n  //define N p2\n  yybessely = function() {\n    var d, n;\n    d = 0.0;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (isdouble(p1) && !isNaN(n)) {\n      d = yn(n, p1.d);\n      push_double(d);\n      return;\n    }\n    if (isnegativeterm(p2)) {\n      push_integer(-1);\n      push(p2);\n      power();\n      push_symbol(BESSELY);\n      push(p1);\n      push(p2);\n      negate();\n      list(3);\n      multiply();\n      return;\n    }\n    push_symbol(BESSELY);\n    push(p1);\n    push(p2);\n    list(3);\n  };\n\n  //double convert_rational_to_double(U *)\n  //double convert_bignum_to_double(unsigned int *)\n  //int ge(unsigned int *, unsigned int *, int)\n  mint = function(a) {\n    return bigInt(a);\n  };\n\n  isSmall = function(a) {\n    return a.geq(Number.MIN_SAFE_INTEGER) && a.leq(Number.MAX_SAFE_INTEGER);\n  };\n\n  // b is +1 or -1, a is a bigint\n  setSignTo = function(a, b) {\n    if (a.isPositive()) {\n      if (b < 0) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b > 0) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makeSignSameAs = function(a, b) {\n    if (a.isPositive()) {\n      if (b.isNegative()) {\n        return a.multiply(bigInt(-1));\n      }\n    } else {\n      // a is negative\n      if (b.isPositive()) {\n        return a.multiply(bigInt(-1));\n      }\n    }\n    return a;\n  };\n\n  makePositive = function(a) {\n    if (a.isNegative()) {\n      return a.multiply(bigInt(-1));\n    }\n    return a;\n  };\n\n  // n is an int\n  /*\n  mtotal = 0\n  MP_MIN_SIZE = 2\n  MP_MAX_FREE  = 1000\n\n  mnew = (n) ->\n    if (n < MP_MIN_SIZE)\n      n = MP_MIN_SIZE\n    if (n == MP_MIN_SIZE && mfreecount)\n      p = free_stack[--mfreecount]\n    else\n      p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))\n      #if (p == 0)\n   *  stop(\"malloc failure\")\n    p[0] = n\n    mtotal += n\n    return p[3]\n   */\n  // p is the index of array of ints\n  // !!! array wasn't passed here\n  /*\n  free_stack = []\n\n  mfree = (array, p) ->\n    p -= 3\n    mtotal -= array[p]\n    if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)\n      free_stack[mfreecount++] = p\n    else\n      free(p)\n  */\n  // convert int to bignum\n\n  // n is an int\n  /*\n  mint = (n) ->\n    p = mnew(1)\n    if (n < 0)\n   * !!! this is FU\n   * MSIGN(p) = -1\n      fu = true\n    else\n   * !!! this is FU\n      #MSIGN(p) = 1\n      fu = true\n   * !!! this is FU\n    #MLENGTH(p) = 1\n    p[0] = Math.abs(n)\n    return p\n   */\n  // copy bignum\n\n  // a is an array of ints\n  /*\n  mcopy = (a) ->\n    #unsigned int *b\n\n    b = mnew(MLENGTH(a))\n\n   * !!! fu\n    #MSIGN(b) = MSIGN(a)\n    #MLENGTH(b) = MLENGTH(a)\n\n    for i in [0...MLENGTH(a)]\n      b[i] = a[i]\n\n    return b\n   */\n  /*\n   * \n   * ge not invoked from anywhere - is you need ge\n   * just use the bigNum's ge implementation\n   * leaving it here just in case I decide to backport to C\n   *\n   * a >= b ?\n   * and and b arrays of ints, len is an int\n  ge = (a, b, len) ->\n    i = 0\n    for i in [0...len]\n      if (a[i] == b[i])\n        continue\n      else\n        break\n    if (a[i] >= b[i])\n      return 1\n    else\n      return 0\n   */\n  add_numbers = function() {\n    var a, b, theResult;\n    a = 1.0;\n    b = 1.0;\n    //if DEBUG then console.log(\"add_numbers adding numbers: \" + print_list(stack[tos - 1]) + \" and \" + print_list(stack[tos - 2]))\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qadd();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    theResult = a + b;\n    push_double(theResult);\n    return restore();\n  };\n\n  subtract_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qsub();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a - b);\n    return restore();\n  };\n\n  multiply_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qmul();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a * b);\n    return restore();\n  };\n\n  divide_numbers = function() {\n    var a, b;\n    a = 0.0;\n    b = 0.0;\n    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {\n      qdiv();\n      return;\n    }\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      a = p1.d;\n    } else {\n      a = convert_rational_to_double(p1);\n    }\n    if (isdouble(p2)) {\n      b = p2.d;\n    } else {\n      b = convert_rational_to_double(p2);\n    }\n    push_double(a / b);\n    return restore();\n  };\n\n  invert_number = function() {\n    var a, b;\n    //unsigned int *a, *b\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      stop(\"divide by zero\");\n    }\n    if (isdouble(p1)) {\n      push_double(1 / p1.d);\n      restore();\n      return;\n    }\n    a = bigInt(p1.q.a);\n    b = bigInt(p1.q.b);\n    b = makeSignSameAs(b, a);\n    a = setSignTo(a, 1);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = b;\n    p1.q.b = a;\n    push(p1);\n    return restore();\n  };\n\n  // a and b are Us\n  compare_rationals = function(a, b) {\n    var ab, ba, t;\n    t = 0;\n    //unsigned int *ab, *ba\n    ab = mmul(a.q.a, b.q.b);\n    ba = mmul(a.q.b, b.q.a);\n    t = mcmp(ab, ba);\n    return t;\n  };\n\n  // a and b are Us\n  compare_numbers = function(a, b) {\n    var x, y;\n    x = 0.0;\n    y = 0.0;\n    if (isrational(a) && isrational(b)) {\n      return compare_rationals(a, b);\n    }\n    if (isdouble(a)) {\n      x = a.d;\n    } else {\n      x = convert_rational_to_double(a);\n    }\n    if (isdouble(b)) {\n      y = b.d;\n    } else {\n      y = convert_rational_to_double(b);\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n  negate_number = function() {\n    save();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    switch (p1.k) {\n      case NUM:\n        p2 = new U();\n        p2.k = NUM;\n        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));\n        p2.q.b = bigInt(p1.q.b);\n        push(p2);\n        break;\n      case DOUBLE:\n        push_double(-p1.d);\n        break;\n      default:\n        stop(\"bug caught in mp_negate_number\");\n    }\n    return restore();\n  };\n\n  bignum_truncate = function() {\n    var a;\n    //unsigned int *a\n    save();\n    p1 = pop();\n    a = mdiv(p1.q.a, p1.q.b);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  mp_numerator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.a);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  mp_denominator = function() {\n    save();\n    p1 = pop();\n    if (p1.k !== NUM) {\n      push(one);\n      restore();\n      return;\n    }\n    p2 = new U();\n    p2.k = NUM;\n    p2.q.a = bigInt(p1.q.b);\n    p2.q.b = bigInt(1);\n    push(p2);\n    return restore();\n  };\n\n  // expo is an integer\n  bignum_power_number = function(expo) {\n    var a, b, t;\n    //unsigned int *a, *b, *t\n    save();\n    p1 = pop();\n    a = mpow(p1.q.a, Math.abs(expo));\n    b = mpow(p1.q.b, Math.abs(expo));\n    if (expo < 0) {\n      // swap a and b\n      t = a;\n      a = b;\n      b = t;\n      a = makeSignSameAs(a, b);\n      b = setSignTo(b, 1);\n    }\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = b;\n    push(p1);\n    return restore();\n  };\n\n  // p an array of ints\n  convert_bignum_to_double = function(p) {\n    return p.toJSNumber();\n  };\n\n  // p is a U\n  convert_rational_to_double = function(p) {\n    var quotientAndRemainder, result;\n    if (p.q == null) {\n      debugger;\n    }\n    quotientAndRemainder = p.q.a.divmod(p.q.b);\n    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();\n    return result;\n  };\n\n  // n an integer\n  new_integer = function(n) {\n    var theNewInteger;\n    theNewInteger = new U();\n    theNewInteger.k = NUM;\n    theNewInteger.q.a = bigInt(n);\n    theNewInteger.q.b = bigInt(1);\n    return theNewInteger;\n  };\n\n  // n an integer\n  push_integer = function(n) {\n    if (DEBUG) {\n      console.log(\"pushing integer \" + n);\n    }\n    return push(new_integer(n));\n  };\n\n  // d a double\n  push_double = function(d) {\n    save();\n    p1 = new U();\n    p1.k = DOUBLE;\n    p1.d = d;\n    push(p1);\n    return restore();\n  };\n\n  // a,b parts of a rational\n  push_rational = function(a, b) {\n    /*\n    save()\n    p1 = new U()\n    p1.k = NUM\n    p1.q.a = bigInt(a)\n    p1.q.b = bigInt(b)\n    ## FIXME -- normalize ##\n    push(p1)\n    restore()\n     */\n    var p;\n    p = new U();\n    p.k = NUM;\n    p.q.a = bigInt(a);\n    p.q.b = bigInt(b);\n    return push(p);\n  };\n\n  pop_integer = function() {\n    var n;\n    n = 0/0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        if (isinteger(p1) && isSmall(p1.q.a)) {\n          n = p1.q.a.toJSNumber();\n        }\n        break;\n      case DOUBLE:\n        if (DEBUG) {\n          console.log(\"popping integer but double is found\");\n        }\n        if (Math.floor(p1.d) === p1.d) {\n          if (DEBUG) {\n            console.log(\"...altough it's an integer\");\n          }\n          n = p1.d;\n        }\n    }\n    restore();\n    return n;\n  };\n\n  // p is a U, flag is an int\n  print_double = function(p, flag) {\n    var accumulator, buf;\n    accumulator = \"\";\n    buf = doubleToReasonableString(p.d);\n    if (flag === 1 && buf === '-') {\n      accumulator += print_str(buf + 1);\n    } else {\n      accumulator += print_str(buf);\n    }\n    return accumulator;\n  };\n\n  // s is a string\n  bignum_scan_integer = function(s) {\n    var a, scounter, sign_;\n    //unsigned int *a\n    //char sign\n    save();\n    scounter = 0;\n    sign_ = s[scounter];\n    if (sign_ === '+' || sign_ === '-') {\n      scounter++;\n    }\n    // !!!! some mess in here, added an argument\n    a = bigInt(s.substring(scounter));\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = a;\n    p1.q.b = bigInt(1);\n    push(p1);\n    if (sign_ === '-') {\n      negate();\n    }\n    return restore();\n  };\n\n  // s a string\n  bignum_scan_float = function(s) {\n    return push_double(parseFloat(s));\n  };\n\n  // gives the capability of printing the unsigned\n  // value. This is handy because printing of the sign\n  // might be taken care of \"upstream\"\n  // e.g. when printing a base elevated to a negative exponent\n  // prints the inverse of the base powered to the unsigned\n  // exponent.\n  // p is a U\n  print_number = function(p, signed) {\n    var aAsString, accumulator, buf, denominatorString;\n    accumulator = \"\";\n    denominatorString = \"\";\n    buf = \"\";\n    switch (p.k) {\n      case NUM:\n        aAsString = p.q.a.toString();\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        if (printMode === PRINTMODE_LATEX && isfraction(p)) {\n          aAsString = \"\\\\frac{\" + aAsString + \"}{\";\n        }\n        accumulator += aAsString;\n        if (isfraction(p)) {\n          if (printMode !== PRINTMODE_LATEX) {\n            accumulator += \"/\";\n          }\n          denominatorString = p.q.b.toString();\n          if (printMode === PRINTMODE_LATEX) {\n            denominatorString += \"}\";\n          }\n          accumulator += denominatorString;\n        }\n        break;\n      case DOUBLE:\n        aAsString = doubleToReasonableString(p.d);\n        if (!signed) {\n          if (aAsString[0] === \"-\") {\n            aAsString = aAsString.substring(1);\n          }\n        }\n        accumulator += aAsString;\n    }\n    return accumulator;\n  };\n\n  gcd_numbers = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    //  if (!isinteger(p1) || !isinteger(p2))\n    //    stop(\"integer args expected for gcd\")\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mgcd(p1.q.a, p2.q.a);\n    p3.q.b = mgcd(p1.q.b, p2.q.b);\n    p3.q.a = setSignTo(p3.q.a, 1);\n    push(p3);\n    return restore();\n  };\n\n  pop_double = function() {\n    var d;\n    d = 0.0;\n    save();\n    p1 = pop();\n    switch (p1.k) {\n      case NUM:\n        d = convert_rational_to_double(p1);\n        break;\n      case DOUBLE:\n        d = p1.d;\n        break;\n      default:\n        d = 0.0;\n    }\n    restore();\n    return d;\n  };\n\n  bignum_float = function() {\n    var d;\n    d = 0.0;\n    d = convert_rational_to_double(pop());\n    return push_double(d);\n  };\n\n  //static unsigned int *__factorial(int)\n\n  // n is an int\n  bignum_factorial = function(n) {\n    save();\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = __factorial(n);\n    p1.q.b = bigInt(1);\n    push(p1);\n    return restore();\n  };\n\n  // n is an int\n  __factorial = function(n) {\n    var a, b, i, o, ref, t;\n    i = 0;\n    //unsigned int *a, *b, *t\n    if (n === 0 || n === 1) {\n      a = bigInt(1);\n      return a;\n    }\n    a = bigInt(2);\n    b = bigInt(0);\n    if (3 <= n) {\n      for (i = o = 3, ref = n; (3 <= ref ? o <= ref : o >= ref); i = 3 <= ref ? ++o : --o) {\n        b = bigInt(i);\n        t = mmul(a, b);\n        a = t;\n      }\n    }\n    return a;\n  };\n\n  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];\n\n  // unsigned int *x, unsigned int k\n  mp_set_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] |= mask[k % 32];\n  };\n\n  // unsigned int *x, unsigned int k\n  mp_clr_bit = function(x, k) {\n    console.log(\"not implemented yet\");\n    debugger;\n    return x[k / 32] &= ~mask[k % 32];\n  };\n\n  // unsigned int *a\n  mshiftright = function(a) {\n    return a = a.shiftRight();\n  };\n\n  //  Binomial coefficient\n\n  //  Input:    tos-2    n\n\n  //      tos-1    k\n\n  //  Output:    Binomial coefficient on stack\n\n  //  binomial(n, k) = n! / k! / (n - k)!\n\n  //  The binomial coefficient vanishes for k < 0 or k > n. (A=B, p. 19)\n  Eval_binomial = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return binomial();\n  };\n\n  binomial = function() {\n    save();\n    ybinomial();\n    return restore();\n  };\n\n  //define N p1\n  //define K p2\n  ybinomial = function() {\n    p2 = pop();\n    p1 = pop();\n    if (BINOM_check_args() === 0) {\n      push(zero);\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    return divide();\n  };\n\n  BINOM_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_ceiling = function() {\n    push(cadr(p1));\n    Eval();\n    return ceiling();\n  };\n\n  ceiling = function() {\n    save();\n    yyceiling();\n    return restore();\n  };\n\n  yyceiling = function() {\n    var d, doNothing;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(CEILING);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.ceil(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      return doNothing = 1;\n    } else {\n      push_integer(1);\n      return add();\n    }\n  };\n\n  Eval_choose = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return choose();\n  };\n\n  // Result vanishes for k < 0 or k > n. (A=B, p. 19)\n\n  //define N p1\n  //define K p2\n  choose = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (choose_check_args() === 0) {\n      push_integer(0);\n      restore();\n      return;\n    }\n    push(p1);\n    factorial();\n    push(p2);\n    factorial();\n    divide();\n    push(p1);\n    push(p2);\n    subtract();\n    factorial();\n    divide();\n    return restore();\n  };\n\n  choose_check_args = function() {\n    if (isNumericAtom(p1) && lessp(p1, zero)) {\n      return 0;\n    } else if (isNumericAtom(p2) && lessp(p2, zero)) {\n      return 0;\n    } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  Eval_circexp = function() {\n    push(cadr(p1));\n    Eval();\n    circexp();\n    // normalize\n    return Eval();\n  };\n\n  circexp = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      expcos();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      expsin();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      p1 = cadr(p1);\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      exponential();\n      p2 = pop();\n      push(imaginaryunit);\n      push(p1);\n      multiply();\n      negate();\n      exponential();\n      p3 = pop();\n      push(p3);\n      push(p2);\n      subtract();\n      push(imaginaryunit);\n      multiply();\n      push(p2);\n      push(p3);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      add();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      p1 = cadr(p1);\n      push(p1);\n      exponential();\n      push(p1);\n      negate();\n      exponential();\n      subtract();\n      push_rational(1, 2);\n      multiply();\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      p1 = cadr(p1);\n      push(p1);\n      push_integer(2);\n      multiply();\n      exponential();\n      p1 = pop();\n      push(p1);\n      push_integer(1);\n      subtract();\n      push(p1);\n      push_integer(1);\n      add();\n      divide();\n      restore();\n      return;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        circexp();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return;\n    }\n    if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        circexp();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n      restore();\n      return;\n    }\n    push(p1);\n    return restore();\n  };\n\n  Eval_clearall = function() {\n    do_clearall();\n    return push(symbol(NIL));\n  };\n\n  do_clearall = function() {\n    if (test_flag === 0) {\n      clear_term();\n    }\n    do_clearPatterns();\n    clear_symbols();\n    defn();\n    return codeGen = false;\n  };\n\n  // clearall from application GUI code\n  clearall = function() {\n    return run(\"clearall\");\n  };\n\n  // this transformation is done in run.coffee, see there\n  // for more info.\n  clearRenamedVariablesToAvoidBindingToExternalScope = function() {\n    var i, o, ref, results;\n    results = [];\n    for (i = o = 0, ref = symtab.length; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (symtab[i].printname.indexOf(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\") !== -1) {\n        // just clear it\n        symtab[i].k = SYM;\n        symtab[i].printname = \"\";\n        binding[i] = symtab[i];\n        results.push(isSymbolReclaimable[i] = true);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  Eval_clear = function() {\n    var indexFound, variableToBeCleared;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      variableToBeCleared = car(p2);\n      //console.log variableToBeCleared + \"\"\n      if (variableToBeCleared.k !== SYM) {\n        stop(\"symbol error\");\n      }\n      //console.log \"getting binding of \" + p.toString()\n      //if p.toString() == \"aaa\"\n      //  debugger\n      indexFound = symtab.indexOf(variableToBeCleared);\n      symtab[indexFound].k = SYM;\n      symtab[indexFound].printname = \"\";\n      binding[indexFound] = symtab[indexFound];\n      isSymbolReclaimable[indexFound] = true;\n      p2 = cdr(p2);\n    }\n    return push(symbol(NIL));\n  };\n\n  /*\n   Convert complex z to clock form\n\n    Input:    push  z\n\n    Output:    Result on stack\n\n    clock(z) = abs(z) * (-1) ^ (arg(z) / pi)\n\n    For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)\n  */\n  // P.S. I couldn't find independent definition/aknowledgment\n  // of the naming \"clock form\" anywhere on the web, seems like a\n  // naming specific to eigenmath.\n  // Clock form is another way to express a complex number, and\n  // it has three advantages\n  //   1) it's uniform with how for example\n  //      i is expressed i.e. (-1)^(1/2)\n  //   2) it's very compact\n  //   3) it's a straighforward notation for roots of 1 and -1\n  DEBUG_CLOCKFORM = false;\n\n  Eval_clock = function() {\n    push(cadr(p1));\n    Eval();\n    return clockform();\n  };\n\n  clockform = function() {\n    save();\n    //if 1\n    p1 = pop();\n    push(p1);\n    abs();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: abs of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    // pushing the expression (-1)^... but note\n    // that we can't use \"power\", as \"power\" evaluates\n    // clock forms into rectangular form (see \"-1 ^ rational\"\n    // section in power)\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p1);\n    arg();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: arg of \" + p1 + \" : \" + stack[tos - 1]);\n    }\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push(symbol(PI));\n    }\n    divide();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: divide : \" + stack[tos - 1]);\n    }\n    list(3);\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: power : \" + stack[tos - 1]);\n    }\n    multiply();\n    if (DEBUG_CLOCKFORM) {\n      console.log(\"clockform: multiply : \" + stack[tos - 1]);\n    }\n    //else\n    /*\n    p1 = pop()\n    push(p1)\n    abs()\n    push(symbol(E))\n    push(p1)\n    arg()\n    push(imaginaryunit)\n    multiply()\n    power()\n    multiply()\n    */\n    //endif\n    return restore();\n  };\n\n  /* coeff =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  p,x,n\n\n  General description\n  -------------------\n  Returns the coefficient of x^n in polynomial p. The x argument can be omitted for polynomials in x.\n\n  */\n  //define P p1\n  //define X p2\n  //define N p3\n  Eval_coeff = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (p3 === symbol(NIL)) { // p3 is N  # only 2 args?\n      p3 = p2;\n      p2 = symbol(SYMBOL_X); // p2 is X\n    }\n    push(p1);\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2);\n    return filter();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Put polynomial coefficients on the stack\n\n  //  Input:  as per params\n\n  //  Output:    Returns number of coefficients on stack\n\n  //      tos-n    Coefficient of x^0\n\n  //      tos-1    Coefficient of x^(n-1)\n\n  //-----------------------------------------------------------------------------\n  coeff = function(variable, polynomial) {\n    var coeffsCount, constant, polynomialWithoutConstant, prev_expanding;\n    if (DEBUG) {\n      console.log(\"coeff: \" + variable + \" \" + polynomial);\n    }\n    // works like this:\n    //   1) find the constant (by just evaluating the pol setting the variable to zero)\n    //   2) set aside the found constant: it's one of the coefficients to return\n    //   3) take the polynomial and remove the constant\n    //   4) divide that by variable, lowering the degree by one\n    //   5) go back to 1) until degree is zero\n    coeffsCount = 0;\n    while (true) {\n      push(polynomial);\n      push(variable);\n      push(zero);\n      subst();\n      Eval();\n      constant = pop();\n      \n      // this will be a coefficient that will be returned\n      push(constant);\n      coeffsCount++;\n      push(polynomial);\n      push(constant);\n      subtract();\n      polynomialWithoutConstant = pop();\n      if (equal(polynomialWithoutConstant, zero)) {\n        if (DEBUG) {\n          console.log(\"coeff: result: \" + coeffsCount);\n        }\n        return coeffsCount;\n      }\n      push(polynomialWithoutConstant);\n      push(variable);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      //console.log(\"just divided: \" + stack[tos-1].toString())\n      // this is now the new polynomial with degree decreased by 1\n      polynomial = pop();\n    }\n  };\n\n  Eval_cofactor = function() {\n    var doNothing, i, j, n;\n    i = 0;\n    j = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {\n      doNothing = 1;\n    } else {\n      stop(\"cofactor: 1st arg: square matrix expected\");\n    }\n    n = p2.tensor.dim[0];\n    push(caddr(p1));\n    Eval();\n    i = pop_integer();\n    if (i < 1 || i > n) {\n      stop(\"cofactor: 2nd arg: row index expected\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (j < 1 || j > n) {\n      stop(\"cofactor: 3rd arg: column index expected\");\n    }\n    return cofactor(p2, n, i - 1, j - 1);\n  };\n\n  cofactor = function(p, n, row, col) {\n    var i, i1, j, o, ref, ref1;\n    i = 0;\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i !== row && j !== col) {\n          push(p.tensor.elem[n * i + j]);\n        }\n      }\n    }\n    determinant(n - 1);\n    if ((row + col) % 2) {\n      return negate();\n    }\n  };\n\n  // Condense an expression by factoring common terms.\n  Eval_condense = function() {\n    push(cadr(p1));\n    Eval();\n    return Condense();\n  };\n\n  Condense = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    save();\n    yycondense();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yycondense = function() {\n    //expanding = 0\n    p1 = pop();\n    if (car(p1) !== symbol(ADD)) {\n      push(p1);\n      return;\n    }\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"calculating gcd between: \" + stack[tos - 1] + \" and \" + stack[tos - 2]);\n      }\n      gcd();\n      if (DEBUG) {\n        console.log(\"partial gcd: \" + stack[tos - 1]);\n      }\n      p3 = cdr(p3);\n    }\n    if (DEBUG) {\n      console.log(\"condense: this is the gcd of all the terms: \" + stack[tos - 1]);\n    }\n    // divide each term by gcd\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      //multiply()\n      multiply_noexpand();\n      add();\n      p3 = cdr(p3);\n    }\n    // We multiplied above w/o expanding so some factors cancelled.\n\n    // Now we expand which normalizes the result and, in some cases,\n    // simplifies it too (see test case H).\n    yyexpand();\n    // multiply result by gcd\n    push(p2);\n    return divide();\n  };\n\n  Eval_conj = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    push(p1);\n    if (!Find(p1, imaginaryunit)) { // example: (-1)^(1/3)\n      polar();\n      conjugate();\n      return clockform();\n    } else {\n      return conjugate();\n    }\n  };\n\n  // careful is you pass this one an expression with\n  // i (instead of (-1)^(1/2)) then this doesn't work!\n  conjugate = function() {\n    push(imaginaryunit);\n    push(imaginaryunit);\n    negate();\n    subst();\n    return Eval();\n  };\n\n  // Cons two things on the stack.\n  consCount = 0;\n\n  cons = function() {\n    var p;\n    consCount++;\n    if (DEBUG) {\n      console.log(\"cons tos: \" + tos + \" # \" + consCount);\n    }\n    //if consCount == 444\n    //  debugger\n    // auto var ok, no opportunity for garbage collection after p = alloc()\n    p = new U();\n    p.k = CONS;\n    p.cons.cdr = pop();\n    if (p === p.cons.cdr) {\n      debugger;\n      console.log(\"something wrong p == its cdr\");\n    }\n    p.cons.car = pop();\n    /*\n    console.log \"cons new cdr.k = \" + p.cons.cdr.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.cdr\n    console.log \"cons new car.k = \" + p.cons.car.k + \"\\nor more in detail:\"\n    console.log print_list p.cons.car\n    */\n    return push(p);\n  };\n\n  Eval_contract = function() {\n    push(cadr(p1));\n    Eval();\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return contract();\n  };\n\n  contract = function() {\n    save();\n    yycontract();\n    return restore();\n  };\n\n  yycontract = function() {\n    var a, ai, an, b, h, i, i1, j, j1, k, l, l1, m, m1, n, n1, ndim, nelem, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    n = 0;\n    ndim = 0;\n    nelem = 0;\n    ai = [];\n    an = [];\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"contract: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    ndim = p1.tensor.ndim;\n    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {\n      stop(\"contract: index out of range\");\n    }\n    l--;\n    m--;\n    n = p1.tensor.dim[l];\n    // nelem is the number of elements in \"b\"\n    nelem = 1;\n    for (i = o = 0, ref = ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (i !== l && i !== m) {\n        nelem *= p1.tensor.dim[i];\n      }\n    }\n    //console.log \"nelem:\" + nelem\n    p2 = alloc_tensor(nelem);\n    //console.log \"p2:\" + p2\n    p2.tensor.ndim = ndim - 2;\n    j = 0;\n    for (i = i1 = 0, ref1 = ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (i !== l && i !== m) {\n        p2.tensor.dim[j++] = p1.tensor.dim[i];\n      }\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n//console.log \"a: \" + a\n//console.log \"b: \" + b\n    for (i = j1 = 0, ref2 = ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref3 = nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(zero);\n      for (j = m1 = 0, ref4 = n; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        ai[l] = j;\n        ai[m] = j;\n        h = 0;\n        for (k = n1 = 0, ref5 = ndim; (0 <= ref5 ? n1 < ref5 : n1 > ref5); k = 0 <= ref5 ? ++n1 : --n1) {\n          h = (h * an[k]) + ai[k];\n        }\n        push(a[h]);\n        //console.log \"a[h]: \" + a[h]\n        add();\n      }\n      //console.log \"tos: \" + stack[tos-1]\n      b[i] = pop();\n//console.log \"b[i]: \" + b[i]\n      for (j = o1 = ref6 = ndim - 1; (ref6 <= 0 ? o1 <= 0 : o1 >= 0); j = ref6 <= 0 ? ++o1 : --o1) {\n        if (j === l || j === m) {\n          continue;\n        }\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    if (nelem === 1) {\n      return push(b[0]);\n    } else {\n      return push(p2);\n    }\n  };\n\n  //console.log \"returning: \" + stack[tos-1]\n  /* cos =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  x\n\n  General description\n  -------------------\n  Returns the cosine of x.\n\n  */\n  Eval_cos = function() {\n    push(cadr(p1));\n    Eval();\n    return cosine();\n  };\n\n  cosine = function() {\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      cosine_of_angle_sum();\n    } else {\n      cosine_of_angle();\n    }\n    return restore();\n  };\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n  cosine_of_angle_sum = function() {\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        cosine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        sine();\n        push(p4);\n        sine();\n        multiply();\n        subtract();\n        return;\n      }\n      p2 = cdr(p2);\n    }\n    return cosine_of_angle();\n  };\n\n  cosine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCCOS)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cos(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // cosine function is symmetric, cos(-x) = cos(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // cos(arctan(x)) = 1 / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(COS));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 90:\n      case 270:\n        return push_integer(0);\n      case 60:\n      case 300:\n        return push_rational(1, 2);\n      case 120:\n      case 240:\n        return push_rational(-1, 2);\n      case 45:\n      case 315:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 135:\n      case 225:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 30:\n      case 330:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 210:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 0:\n        return push_integer(1);\n      case 180:\n        return push_integer(-1);\n      default:\n        push(symbol(COS));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  Eval_cosh = function() {\n    push(cadr(p1));\n    Eval();\n    return ycosh();\n  };\n\n  ycosh = function() {\n    save();\n    yycosh();\n    return restore();\n  };\n\n  yycosh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCCOSH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.cosh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(COSH);\n    push(p1);\n    return list(2);\n  };\n\n  // this function extract parts subtrees from a tree.\n  // It is used in two\n  // places that have to do with pattern matching.\n  // One is for integrals, where an expression or its\n  // subparts are matched against cases in an\n  // integrals table.\n  // Another one is for applyging tranformation patterns\n  // defined via PATTERN, again patterns are applied to\n  // either the whole expression or any of its parts.\n\n  // unclear to me at the moment\n  // why this is exposed as something that can\n  // be evalled. Never called.\n  Eval_decomp = function() {\n    var h;\n    save();\n    console.log(\"Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!\");\n    h = tos;\n    push(symbol(NIL));\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    decomp(false);\n    list(tos - h);\n    return restore();\n  };\n\n  pushTryNotToDuplicate = function(toBePushed) {\n    if (tos > 0) {\n      if (DEBUG) {\n        console.log(\"comparing \" + toBePushed + \" to: \" + stack[tos - 1]);\n      }\n      if (equal(toBePushed, stack[tos - 1])) {\n        if (DEBUG) {\n          console.log(\"skipping \" + toBePushed + \" because it's already on stack \");\n        }\n        return;\n      }\n    }\n    return push(toBePushed);\n  };\n\n  // returns constant expressions on the stack\n  decomp = function(generalTransform) {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"DECOMPOSING \" + p1);\n    }\n    // is the entire expression constant?\n    if (generalTransform) {\n      if (!iscons(p1)) {\n        if (DEBUG) {\n          console.log(\" ground thing: \" + p1);\n        }\n        pushTryNotToDuplicate(p1);\n        restore();\n        return;\n      }\n    } else {\n      if (Find(p1, p2) === 0) {\n        if (DEBUG) {\n          console.log(\" entire expression is constant\");\n        }\n        pushTryNotToDuplicate(p1);\n        //push(p1);  # may need later for pushing both +a, -a\n        //negate()\n        restore();\n        return;\n      }\n    }\n    // sum?\n    if (isadd(p1)) {\n      decomp_sum(generalTransform);\n      restore();\n      return;\n    }\n    // product?\n    if (ismultiply(p1)) {\n      decomp_product(generalTransform);\n      restore();\n      return;\n    }\n    // naive decomp if not sum or product\n    if (DEBUG) {\n      console.log(\" naive decomp\");\n    }\n    p3 = cdr(p1);\n    if (DEBUG) {\n      console.log(\"startig p3: \" + p3);\n    }\n    while (iscons(p3)) {\n      // for a general transformations,\n      // we want to match any part of the tree so\n      // we need to push the subtree as well\n      // as recurse to its parts\n      if (generalTransform) {\n        push(car(p3));\n      }\n      if (DEBUG) {\n        console.log(\"recursive decomposition\");\n      }\n      push(car(p3));\n      if (DEBUG) {\n        console.log(\"car(p3): \" + car(p3));\n      }\n      push(p2);\n      if (DEBUG) {\n        console.log(\"p2: \" + p2);\n      }\n      decomp(generalTransform);\n      p3 = cdr(p3);\n    }\n    return restore();\n  };\n\n  decomp_sum = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the sum \");\n    }\n    h = 0;\n    // decomp terms involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // add together all constant terms\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      add_all(tos - h);\n      p3 = pop();\n      pushTryNotToDuplicate(p3);\n      push(p3);\n      return negate(); // need both +a, -a for some integrals\n    }\n  };\n\n  decomp_product = function(generalTransform) {\n    var h;\n    if (DEBUG) {\n      console.log(\" decomposing the product \");\n    }\n    h = 0;\n    // decomp factors involving x\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) || generalTransform) {\n        push(car(p3));\n        push(p2);\n        decomp(generalTransform);\n      }\n      p3 = cdr(p3);\n    }\n    // multiply together all constant factors\n    h = tos;\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      if (Find(car(p3), p2) === 0) {\n        pushTryNotToDuplicate(car(p3));\n      }\n      p3 = cdr(p3);\n    }\n    if (tos - h) {\n      return multiply_all(tos - h);\n    }\n  };\n\n  //p3 = pop();  # may need later for pushing both +a, -a\n  //push(p3)\n  //push(p3)\n  //negate()\n  // Store a function definition\n\n  // Example:\n\n  //      f(x,y)=x^y\n\n  // For this definition, p1 points to the following structure.\n\n  //     p1\n  //      |\n  //   ___v__    ______                        ______ \n  //  |CONS  |->|CONS  |--------------------->|CONS  |\n  //  |______|  |______|                      |______|\n  //      |         |                             |\n  //   ___v__    ___v__    ______    ______    ___v__    ______    ______\n  //  |SETQ  |  |CONS  |->|CONS  |->|CONS  |  |CONS  |->|CONS  |->|CONS  |\n  //  |______|  |______|  |______|  |______|  |______|  |______|  |______|\n  //                |         |         |         |         |         |\n  //             ___v__    ___v__    ___v__    ___v__    ___v__    ___v__\n  //            |SYM f |  |SYM x |  |SYM y |  |POWER |  |SYM x |  |SYM y |\n  //            |______|  |______|  |______|  |______|  |______|  |______|\n\n  // the result (in f) is a FUNCTION node\n  // that contains both the body and the argument list.\n\n  // We have\n\n  //  caadr(p1) points to the function name i.e. f\n  //  cdadr(p1) points to the arguments i.e. the list (x y)\n  //  caddr(p1) points to the function body i.e. (power x y)\n\n  //define F p3 # F points to the function name\n  //define A p4 # A points to the argument list\n  //define B p5 # B points to the function body\n  define_user_function = function() {\n    p3 = caadr(p1);\n    p4 = cdadr(p1);\n    p5 = caddr(p1);\n    if (!issymbol(p3)) { // p3 is F\n      stop(\"function name?\");\n    }\n    // evaluate function body (maybe)\n    if (car(p5) === symbol(EVAL)) { // p5 is B\n      push(cadr(p5));\n      Eval();\n      p5 = pop(); // p5 is B\n    }\n    \n    // note how, unless explicitly forced by an eval,\n    // (handled by the if just above)\n    // we don't eval/simplify\n    // the body.\n    // Why? because it's the easiest way\n    // to solve scope problems i.e.\n    //   x = 0\n    //   f(x) = x + 1\n    //   f(4) # would reply 1\n    // which would need to otherwise\n    // be solved by some scope device\n    // somehow\n    push_symbol(FUNCTION);\n    push(p5);\n    push(p4);\n    list(3);\n    p5 = pop();\n    set_binding(p3, p5);\n    return push_symbol(NIL);\n  };\n\n  Eval_function_reference = function() {\n    return push(p1);\n  };\n\n  /* defint =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x,a,b[,y,c,d...]\n\n  General description\n  -------------------\n  Returns the definite integral of f with respect to x evaluated from \"a\" to b.\n  The argument list can be extended for multiple integrals (or \"iterated\n  integrals\"), for example a double integral (which can represent for\n  example a volume under a surface), or a triple integral, etc. For\n  example, defint(f,x,a,b,y,c,d).\n\n  */\n  //define F p2\n  //define X p3\n  //define A p4\n  //define B p5\n  Eval_defint = function() {\n    push(cadr(p1));\n    Eval();\n    p2 = pop(); // p2 is F\n    p1 = cddr(p1);\n    // defint can handle multiple\n    // integrals, so we loop over the\n    // multiple integrals here\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p3 = pop(); // p3 is X\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p4 = pop(); // p4 is A\n      push(car(p1));\n      p1 = cdr(p1);\n      Eval();\n      p5 = pop(); // p5 is B\n      \n      // obtain the primitive of F against the\n      // specified variable X\n      // note that the primitive changes over\n      // the calculation of the multiple\n      // integrals.\n      push(p2);\n      push(p3);\n      integral();\n      p2 = pop(); // contains the antiderivative of F\n      \n      // evaluate the integral in A\n      push(p2);\n      push(p3);\n      push(p5);\n      subst();\n      Eval();\n      // evaluate the integral in B\n      push(p2);\n      push(p3);\n      push(p4);\n      subst();\n      Eval();\n      // integral between B and A is the\n      // subtraction. Note that this could\n      // be a number but also a function.\n      // and we might have to integrate this\n      // number/function again doing the while\n      // loop again if this is a multiple\n      // integral.\n      subtract();\n      p2 = pop();\n    }\n    return push(p2);\n  };\n\n  Eval_degree = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return degree();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Find the degree of a polynomial\n\n  //  Input:    tos-2    p(x)\n\n  //      tos-1    x\n\n  //  Output:    Result on stack\n\n  //  Note: Finds the largest numerical power of x. Does not check for\n  //  weirdness in p(x).\n\n  //-----------------------------------------------------------------------------\n\n  //define POLY p1\n  //define X p2\n  //define DEGREE p3\n  degree = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    p3 = zero;\n    yydegree(p1);\n    push(p3);\n    return restore();\n  };\n\n  yydegree = function(p) {\n    var results;\n    if (equal(p, p2)) {\n      if (isZeroAtomOrTensor(p3)) {\n        return p3 = one;\n      }\n    } else if (car(p) === symbol(POWER)) {\n      if (equal(cadr(p), p2) && isNumericAtom(caddr(p)) && lessp(p3, caddr(p))) {\n        return p3 = caddr(p);\n      }\n    } else if (iscons(p)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        yydegree(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    }\n  };\n\n  Eval_denominator = function() {\n    push(cadr(p1));\n    Eval();\n    return denominator();\n  };\n\n  denominator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    //console.trace \"denominator of: \" + theArgument\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      rationalize();\n      theArgument = pop();\n    }\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        denominator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_denominator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      push(theArgument);\n      return reciprocate();\n    } else {\n      return push(one);\n    }\n  };\n\n  // derivative\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_derivative = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    // evaluate 1st arg to get function F\n    i = 0;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example  result of 2nd arg  what to do\n\n    // d(f)    nil      guess X, N = nil\n    // d(f,2)  2      guess X, N = 2\n    // d(f,x)  x      X = x, N = nil\n    // d(f,x,2)  x      X = x, N = 2\n    // d(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // p5 (N) might be a symbol instead of a number\n      if (isNumericAtom(p5)) { // p5 is N\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth derivative: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          derivative();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          integral();\n        }\n      }\n      p3 = pop();\n      if (p5 === symbol(NIL)) { // p5 is N\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) { // p5 is N\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) { // p5 is N\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) { // p5 is N\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // p5 is N  # N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // p5 is N  # N = arg1\n      }\n    }\n    return push(p3); // p3 is F # final result\n  };\n\n  derivative = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isNumericAtom(p2)) {\n      stop(\"undefined function\");\n    }\n    if (istensor(p1)) {\n      if (istensor(p2)) {\n        d_tensor_tensor();\n      } else {\n        d_tensor_scalar();\n      }\n    } else {\n      if (istensor(p2)) {\n        d_scalar_tensor();\n      } else {\n        d_scalar_scalar();\n      }\n    }\n    return restore();\n  };\n\n  d_scalar_scalar = function() {\n    if (issymbol(p2)) {\n      return d_scalar_scalar_1();\n    } else {\n      // Example: d(sin(cos(x)),cos(x))\n      // Replace cos(x) <- X, find derivative, then do X <- cos(x)\n      push(p1);\n      push(p2);\n      push(symbol(SECRETX));\n      subst();\n      push(symbol(SECRETX));\n      derivative();\n      push(symbol(SECRETX));\n      push(p2);\n      return subst(); // cos(X) -> cos(cos(x))\n    }\n  };\n\n  d_scalar_scalar_1 = function() {\n    // d(x,x)?\n    if (equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    if (!iscons(p1)) {\n      push(zero);\n      return;\n    }\n    if (isadd(p1)) {\n      dsum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      dproduct();\n      return;\n    }\n    if (car(p1) === symbol(POWER)) {\n      dpower();\n      return;\n    }\n    if (car(p1) === symbol(DERIVATIVE)) {\n      dd();\n      return;\n    }\n    if (car(p1) === symbol(LOG)) {\n      dlog();\n      return;\n    }\n    if (car(p1) === symbol(SIN)) {\n      dsin();\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      dcos();\n      return;\n    }\n    if (car(p1) === symbol(TAN)) {\n      dtan();\n      return;\n    }\n    if (car(p1) === symbol(ARCSIN)) {\n      darcsin();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOS)) {\n      darccos();\n      return;\n    }\n    if (car(p1) === symbol(ARCTAN)) {\n      darctan();\n      return;\n    }\n    if (car(p1) === symbol(SINH)) {\n      dsinh();\n      return;\n    }\n    if (car(p1) === symbol(COSH)) {\n      dcosh();\n      return;\n    }\n    if (car(p1) === symbol(TANH)) {\n      dtanh();\n      return;\n    }\n    if (car(p1) === symbol(ARCSINH)) {\n      darcsinh();\n      return;\n    }\n    if (car(p1) === symbol(ARCCOSH)) {\n      darccosh();\n      return;\n    }\n    if (car(p1) === symbol(ARCTANH)) {\n      darctanh();\n      return;\n    }\n    if (car(p1) === symbol(ABS)) {\n      dabs();\n      return;\n    }\n    if (car(p1) === symbol(SGN)) {\n      dsgn();\n      return;\n    }\n    if (car(p1) === symbol(HERMITE)) {\n      dhermite();\n      return;\n    }\n    if (car(p1) === symbol(ERF)) {\n      derf();\n      return;\n    }\n    if (car(p1) === symbol(ERFC)) {\n      derfc();\n      return;\n    }\n    if (car(p1) === symbol(BESSELJ)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbesselj0();\n      } else {\n        dbesseljn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(BESSELY)) {\n      if (isZeroAtomOrTensor(caddr(p1))) {\n        dbessely0();\n      } else {\n        dbesselyn();\n      }\n      return;\n    }\n    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {\n      derivative_of_integral();\n      return;\n    }\n    return dfunction();\n  };\n\n  dsum = function() {\n    var h;\n    h = tos;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      derivative();\n      p1 = cdr(p1);\n    }\n    return add_all(tos - h);\n  };\n\n  dproduct = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = length(p1) - 1;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3 = cdr(p1);\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(car(p3));\n        if (i === j) {\n          push(p2);\n          derivative();\n        }\n        p3 = cdr(p3);\n      }\n      multiply_all(n);\n    }\n    return add_all(n);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //       v\n  //  y = u\n\n  //  log y = v log u\n\n  //  1 dy   v du           dv\n  //  - -- = - -- + (log u) --\n  //  y dx   u dx           dx\n\n  //  dy    v  v du           dv\n  //  -- = u  (- -- + (log u) --)\n  //  dx       u dx           dx\n\n  //-----------------------------------------------------------------------------\n  dpower = function() {\n    push(caddr(p1));\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    push(cadr(p1));\n    logarithm();\n    push(caddr(p1));\n    push(p2);\n    derivative();\n    multiply();\n    add();\n    push(p1);\n    return multiply();\n  };\n\n  dlog = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    return divide();\n  };\n\n  //  derivative of derivative\n\n  //  example: d(d(f(x,y),y),x)\n\n  //  p1 = d(f(x,y),y)\n\n  //  p2 = x\n\n  //  cadr(p1) = f(x,y)\n\n  //  caddr(p1) = y\n  dd = function() {\n    // d(f(x,y),x)\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    p3 = pop();\n    if (car(p3) === symbol(DERIVATIVE)) {\n      // sort dx terms\n      push_symbol(DERIVATIVE);\n      push_symbol(DERIVATIVE);\n      push(cadr(p3));\n      if (lessp(caddr(p3), caddr(p1))) {\n        push(caddr(p3));\n        list(3);\n        push(caddr(p1));\n      } else {\n        push(caddr(p1));\n        list(3);\n        push(caddr(p3));\n      }\n      return list(3);\n    } else {\n      push(p3);\n      push(caddr(p1));\n      return derivative();\n    }\n  };\n\n  // derivative of a generic function\n  dfunction = function() {\n    p3 = cdr(p1);\n    if (p3 === symbol(NIL) || Find(p3, p2)) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(zero);\n    }\n  };\n\n  dsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    return multiply();\n  };\n\n  dcos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sine();\n    multiply();\n    return negate();\n  };\n\n  dtan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    cosine();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsin = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccos = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    push_rational(-1, 2);\n    power();\n    multiply();\n    return negate();\n  };\n\n  //        Without simplify  With simplify\n\n  //  d(arctan(y/x),x)  -y/(x^2*(y^2/x^2+1))  -y/(x^2+y^2)\n\n  //  d(arctan(y/x),y)  1/(x*(y^2/x^2+1))  x/(x^2+y^2)\n  darctan = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    add();\n    inverse();\n    multiply();\n    return simplify();\n  };\n\n  dsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    return multiply();\n  };\n\n  dcosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ysinh();\n    return multiply();\n  };\n\n  dtanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    ycosh();\n    push_integer(-2);\n    power();\n    return multiply();\n  };\n\n  darcsinh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darccosh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    add();\n    push_rational(-1, 2);\n    power();\n    return multiply();\n  };\n\n  darctanh = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(1);\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    subtract();\n    inverse();\n    return multiply();\n  };\n\n  dabs = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    sgn();\n    return multiply();\n  };\n\n  dsgn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    dirac();\n    multiply();\n    push_integer(2);\n    return multiply();\n  };\n\n  dhermite = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push_integer(2);\n    push(caddr(p1));\n    multiply();\n    multiply();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    hermite();\n    return multiply();\n  };\n\n  derf = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  derfc = function() {\n    push(cadr(p1));\n    push_integer(2);\n    power();\n    push_integer(-1);\n    multiply();\n    exponential();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    push_rational(-1, 2);\n    power();\n    multiply();\n    push_integer(-2);\n    multiply();\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    return multiply();\n  };\n\n  dbesselj0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesseljn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    besselj();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    besselj();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  dbessely0 = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push_integer(1);\n    besselj();\n    multiply();\n    push_integer(-1);\n    return multiply();\n  };\n\n  dbesselyn = function() {\n    push(cadr(p1));\n    push(p2);\n    derivative();\n    push(cadr(p1));\n    push(caddr(p1));\n    push_integer(-1);\n    add();\n    bessely();\n    push(caddr(p1));\n    push_integer(-1);\n    multiply();\n    push(cadr(p1));\n    divide();\n    push(cadr(p1));\n    push(caddr(p1));\n    bessely();\n    multiply();\n    add();\n    return multiply();\n  };\n\n  derivative_of_integral = function() {\n    return push(cadr(p1));\n  };\n\n  DET_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  det = function() {\n    var a, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    n = p1.tensor.nelem;\n    a = p1.tensor.elem;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isNumericAtom(a[i])) {\n        break;\n      }\n    }\n    if (i === n) {\n      yydetg();\n    } else {\n      for (i = i1 = 0, ref1 = p1.tensor.nelem; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        push(p1.tensor.elem[i]);\n      }\n      determinant(p1.tensor.dim[0]);\n    }\n    return restore();\n  };\n\n  // determinant of n * n matrix elements on the stack\n  determinant = function(n) {\n    var a, breakFromOutherWhile, h, i, i1, j, k, o, q, ref, ref1, s, sign_, t;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    q = 0;\n    s = 0;\n    sign_ = 0;\n    t = 0;\n    a = [];\n    //int *a, *c, *d\n    h = tos - n * n;\n//a = (int *) malloc(3 * n * sizeof (int))\n\n    //if (a == NULL)\n//  out_of_memory()\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      a[i] = i;\n      a[i + n] = 0;\n      a[i + n + n] = 1;\n    }\n    sign_ = 1;\n    push(zero);\n    while (1) {\n      if (sign_ === 1) {\n        push_integer(1);\n      } else {\n        push_integer(-1);\n      }\n      for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        k = n * a[i] + i;\n        push(stack[h + k]);\n        multiply(); // FIXME -- problem here\n      }\n      add();\n      // next permutation (Knuth's algorithm P)\n      j = n - 1;\n      s = 0;\n      breakFromOutherWhile = false;\n      while (1) {\n        q = a[n + j] + a[n + n + j];\n        if (q < 0) {\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        if (q === j + 1) {\n          if (j === 0) {\n            breakFromOutherWhile = true;\n            break;\n          }\n          s++;\n          a[n + n + j] = -a[n + n + j];\n          j--;\n          continue;\n        }\n        break;\n      }\n      if (breakFromOutherWhile) {\n        break;\n      }\n      t = a[j - a[n + j] + s];\n      a[j - a[n + j] + s] = a[j - q + s];\n      a[j - q + s] = t;\n      a[n + j] = q;\n      sign_ = -sign_;\n    }\n    stack[h] = stack[tos - 1];\n    return moveTos(h + 1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack\n\n  //  Output:    Determinant on stack\n\n  //  Note:\n\n  //  Uses Gaussian elimination which is faster for numerical matrices.\n\n  //  Gaussian Elimination works by walking down the diagonal and clearing\n  //  out the columns below it.\n\n  //-----------------------------------------------------------------------------\n  detg = function() {\n    save();\n    p1 = pop();\n    if (DET_check_arg() === 0) {\n      push_symbol(DET);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yydetg();\n    return restore();\n  };\n\n  yydetg = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    for (i = o = 0, ref = n * n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p1.tensor.elem[i]);\n    }\n    lu_decomp(n);\n    moveTos(tos - n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n matrix elements on stack\n\n  //  Output:    p1  determinant\n\n  //      p2  mangled\n\n  //      upper diagonal matrix on stack\n\n  //-----------------------------------------------------------------------------\n  M = function(h, n, i, j) {\n    return stack[h + n * i + j];\n  };\n\n  setM = function(h, n, i, j, value) {\n    return stack[h + n * i + j] = value;\n  };\n\n  lu_decomp = function(n) {\n    var d, h, i, i1, j, j1, l1, m1, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;\n    d = 0;\n    h = 0;\n    i = 0;\n    j = 0;\n    h = tos - n * n;\n    p1 = one;\n    for (d = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(M(h, n, d, d), zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(M(h, n, i, d), zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          p1 = zero;\n          break;\n        }\n// exchange rows\n        for (j = j1 = ref3 = d, ref4 = n; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); j = ref3 <= ref4 ? ++j1 : --j1) {\n          p2 = M(h, n, d, j);\n          setM(h, n, d, j, M(h, n, i, j));\n          setM(h, n, i, j, p2);\n        }\n        // negate det\n        push(p1);\n        negate();\n        p1 = pop();\n      }\n      // update det\n      push(p1);\n      push(M(h, n, d, d));\n      multiply();\n      p1 = pop();\n// update lower diagonal matrix\n      for (i = l1 = ref5 = d + 1, ref6 = n; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n        // multiplier\n        push(M(h, n, i, d));\n        push(M(h, n, d, d));\n        divide();\n        negate();\n        p2 = pop();\n        // update one row\n        setM(h, n, i, d, zero);\n        for (j = m1 = ref7 = d + 1, ref8 = n; (ref7 <= ref8 ? m1 < ref8 : m1 > ref8); j = ref7 <= ref8 ? ++m1 : --m1) {\n          push(M(h, n, d, j));\n          push(p2);\n          multiply();\n          push(M(h, n, i, j));\n          add();\n          setM(h, n, i, j, pop());\n        }\n      }\n    }\n    // last diagonal element\n    push(p1);\n    push(M(h, n, n - 1, n - 1));\n    multiply();\n    return p1 = pop();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Dirac function dirac(x)\n  //  dirac(-x)=dirac(x)\n  //  dirac(b-a)=dirac(a-b)\n  //-----------------------------------------------------------------------------\n  Eval_dirac = function() {\n    push(cadr(p1));\n    Eval();\n    return dirac();\n  };\n\n  dirac = function() {\n    save();\n    ydirac();\n    return restore();\n  };\n\n  //define p1 p1\n  ydirac = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d === 0) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (isrational(p1)) {\n      if (MZERO(mmul(p1.q.a, p1.q.b))) {\n        push_integer(1);\n        return;\n      } else {\n        push_integer(0);\n        return;\n      }\n    }\n    if (car(p1) === symbol(POWER)) {\n      push_symbol(DIRAC);\n      push(cadr(p1));\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(DIRAC);\n      push(p1);\n      negate();\n      list(2);\n      return;\n    }\n    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    push_symbol(DIRAC);\n    push(p1);\n    return list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate all divisors of a term\n\n  //  Input:    Term on stack (factor * factor * ...)\n\n  //  Output:    Divisors on stack\n\n  //-----------------------------------------------------------------------------\n  divisors = function() {\n    var h, i, n, o, ref, subsetOfStack;\n    i = 0;\n    h = 0;\n    n = 0;\n    save();\n    h = tos - 1;\n    divisors_onstack();\n    n = tos - h;\n    //qsort(stack + h, n, sizeof (U *), __cmp)\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  divisors_onstack = function() {\n    var h, i, k, n, o, ref;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    save();\n    p1 = pop();\n    h = tos;\n    // push all of the term's factors\n    if (isNumericAtom(p1)) {\n      push(p1);\n      factor_small_number();\n    } else if (car(p1) === symbol(ADD)) {\n      push(p1);\n      __factor_add();\n    //printf(\">>>\\n\")\n    //for (i = h; i < tos; i++)\n    //print(stdout, stack[i])\n    //printf(\"<<<\\n\")\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      if (isNumericAtom(car(p1))) {\n        push(car(p1));\n        factor_small_number();\n        p1 = cdr(p1);\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (car(p2) === symbol(POWER)) {\n          push(cadr(p2));\n          push(caddr(p2));\n        } else {\n          push(p2);\n          push(one);\n        }\n        p1 = cdr(p1);\n      }\n    } else if (car(p1) === symbol(POWER)) {\n      push(cadr(p1));\n      push(caddr(p1));\n    } else {\n      push(p1);\n      push(one);\n    }\n    k = tos;\n    // contruct divisors by recursive descent\n    push(one);\n    gen(h, k);\n    // move\n    n = tos - k;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[h + i] = stack[k + i];\n    }\n    moveTos(h + n);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Generate divisors\n\n  //  Input:    Base-exponent pairs on stack\n\n  //      h  first pair\n\n  //      k  just past last pair\n\n  //  Output:    Divisors on stack\n\n  //  For example, factor list 2 2 3 1 results in 6 divisors,\n\n  //    1\n  //    3\n  //    2\n  //    6\n  //    4\n  //    12\n\n  //-----------------------------------------------------------------------------\n\n  //define ACCUM p1\n  //define BASE p2\n  //define EXPO p3\n  gen = function(h, k) {\n    var expo, i, o, ref;\n    expo = 0;\n    i = 0;\n    save();\n    p1 = pop();\n    if (h === k) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = stack[h + 0];\n    p3 = stack[h + 1];\n    push(p3);\n    expo = pop_integer();\n    if (!isNaN(expo)) {\n      for (i = o = 0, ref = Math.abs(expo); (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(p1);\n        push(p2);\n        push_integer(sign(expo) * i);\n        power();\n        multiply();\n        gen(h + 2, k);\n      }\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor ADD expression\n\n  //  Input:    Expression on stack\n\n  //  Output:    Factors on stack\n\n  //  Each factor consists of two expressions, the factor itself followed\n  //  by the exponent.\n\n  //-----------------------------------------------------------------------------\n  __factor_add = function() {\n    save();\n    p1 = pop();\n    // get gcd of all terms\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    // check gcd\n    p2 = pop();\n    if (isplusone(p2)) {\n      push(p1);\n      push(one);\n      restore();\n      return;\n    }\n    // push factored gcd\n    if (isNumericAtom(p2)) {\n      push(p2);\n      factor_small_number();\n    } else if (car(p2) === symbol(MULTIPLY)) {\n      p3 = cdr(p2);\n      if (isNumericAtom(car(p3))) {\n        push(car(p3));\n        factor_small_number();\n      } else {\n        push(car(p3));\n        push(one);\n      }\n      p3 = cdr(p3);\n      while (iscons(p3)) {\n        push(car(p3));\n        push(one);\n        p3 = cdr(p3);\n      }\n    } else {\n      push(p2);\n      push(one);\n    }\n    // divide each term by gcd\n    push(p2);\n    inverse();\n    p2 = pop();\n    push(zero);\n    p3 = cdr(p1);\n    while (iscons(p3)) {\n      push(p2);\n      push(car(p3));\n      multiply();\n      add();\n      p3 = cdr(p3);\n    }\n    push(one);\n    return restore();\n  };\n\n  // power function for double precision floating point\n  dpow = function() {\n    var a, b, base, expo, result, theta;\n    a = 0.0;\n    b = 0.0;\n    base = 0.0;\n    expo = 0.0;\n    result = 0.0;\n    theta = 0.0;\n    expo = pop_double();\n    base = pop_double();\n    // divide by zero?\n    if (base === 0.0 && expo < 0.0) {\n      stop(\"divide by zero\");\n    }\n    // nonnegative base or integer power?\n    if (base >= 0.0 || (expo % 1.0) === 0.0) {\n      result = Math.pow(base, expo);\n      push_double(result);\n      return;\n    }\n    result = Math.pow(Math.abs(base), expo);\n    theta = Math.PI * expo;\n    // this ensures the real part is 0.0 instead of a tiny fraction\n    if ((expo % 0.5) === 0.0) {\n      a = 0.0;\n      b = Math.sin(theta);\n    } else {\n      a = Math.cos(theta);\n      b = Math.sin(theta);\n    }\n    push_double(a * result);\n    push_double(b * result);\n    push(imaginaryunit);\n    multiply();\n    return add();\n  };\n\n  /* eigen =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  m\n\n  General description\n  -------------------\n  Compute eigenvalues and eigenvectors. Matrix m must be both numerical and symmetric.\n  The eigenval function returns a matrix with the eigenvalues along the diagonal.\n  The eigenvec function returns a matrix with the eigenvectors arranged as row vectors.\n  The eigen function does not return anything but stores the eigenvalue matrix in D\n  and the eigenvector matrix in Q.\n\n  Input:    stack[tos - 1]    symmetric matrix\n\n  Output:    D      diagnonal matrix\n        Q      eigenvector matrix\n\n  D and Q have the property that\n\n    A == dot(transpose(Q),D,Q)\n\n  where A is the original matrix.\n\n  The eigenvalues are on the diagonal of D.\n  The eigenvectors are row vectors in Q.\n\n  The eigenvalue relation:\n\n    A X = lambda X\n\n  can be checked as follows:\n\n    lambda = D[1,1]\n    X = Q[1]\n    dot(A,X) - lambda X\n\n  Example 1. Check the relation AX = lambda X where lambda is an eigenvalue and X is the associated eigenvector.\n\n  Enter:\n\n       A = hilbert(3)\n\n       eigen(A)\n\n       lambda = D[1,1]\n\n       X = Q[1]\n\n       dot(A,X) - lambda X\n\n  Result:\n\n       -1.16435e-14\n\n       -6.46705e-15\n\n       -4.55191e-15\n\n  Example 2: Check the relation A = QTDQ.\n\n  Enter:\n\n    A - dot(transpose(Q),D,Q)\n\n  Result: \n\n    6.27365e-12    -1.58236e-11   1.81902e-11\n\n    -1.58236e-11   -1.95365e-11   2.56514e-12\n\n    1.81902e-11    2.56514e-12    1.32627e-11\n\n  */\n  //define D(i, j) yydd[EIG_N * (i) + (j)]\n  //define Q(i, j) yyqq[EIG_N * (i) + (j)]\n  EIG_N = 0;\n\n  EIG_yydd = [];\n\n  EIG_yyqq = [];\n\n  Eval_eigen = function() {\n    if (EIG_check_arg() === 0) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    eigen(EIGEN);\n    p1 = usr_symbol(\"D\");\n    set_binding(p1, p2);\n    p1 = usr_symbol(\"Q\");\n    set_binding(p1, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_eigenval = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVAL);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVAL);\n    return push(p2);\n  };\n\n  Eval_eigenvec = function() {\n    if (EIG_check_arg() === 0) {\n      push_symbol(EIGENVEC);\n      push(p1);\n      list(2);\n      return;\n    }\n    eigen(EIGENVEC);\n    return push(p3);\n  };\n\n  EIG_check_arg = function() {\n    var i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    p1 = pop();\n    if (!istensor(p1)) {\n      return 0;\n    }\n    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      stop(\"eigen: argument is not a square matrix\");\n    }\n    EIG_N = p1.tensor.dim[0];\n    for (i = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {\n          stop(\"eigen: matrix is not numerical\");\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = EIG_N - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {\n          stop(\"eigen: matrix is not symmetrical\");\n        }\n      }\n    }\n    return 1;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    p1    matrix\n\n  //  Output:    p2    eigenvalues\n\n  //      p3    eigenvectors\n\n  //-----------------------------------------------------------------------------\n  eigen = function(op) {\n    var i, i1, j, j1, l1, m1, n1, o, o1, q1, r1, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;\n    i = 0;\n    j = 0;\n// malloc working vars\n\n    //EIG_yydd = (double *) malloc(n * n * sizeof (double))\n    for (i = o = 0, ref = EIG_N * EIG_N; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      EIG_yydd[i] = 0.0;\n    }\n//if (EIG_yydd == NULL)\n//  stop(\"malloc failure\")\n\n    //EIG_yyqq = (double *) malloc(n * n * sizeof (double))\n    for (i = i1 = 0, ref1 = EIG_N * EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      EIG_yyqq[i] = 0.0;\n    }\n//if (EIG_yyqq == NULL)\n//  stop(\"malloc failure\")\n\n    // initialize D\n    for (i = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;\n      for (j = l1 = ref3 = i + 1, ref4 = EIG_N; (ref3 <= ref4 ? l1 < ref4 : l1 > ref4); j = ref3 <= ref4 ? ++l1 : --l1) {\n        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;\n        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;\n      }\n    }\n// initialize Q\n    for (i = m1 = 0, ref5 = EIG_N; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      EIG_yyqq[EIG_N * i + i] = 1.0;\n      for (j = n1 = ref6 = i + 1, ref7 = EIG_N; (ref6 <= ref7 ? n1 < ref7 : n1 > ref7); j = ref6 <= ref7 ? ++n1 : --n1) {\n        EIG_yyqq[EIG_N * i + j] = 0.0;\n        EIG_yyqq[EIG_N * j + i] = 0.0;\n      }\n    }\n// step up to 100 times\n    for (i = o1 = 0; o1 < 100; i = ++o1) {\n      if (step() === 0) {\n        break;\n      }\n    }\n    if (i === 100) {\n      printstr(\"\\nnote: eigen did not converge\\n\");\n    }\n    // p2 = D\n    if (op === EIGEN || op === EIGENVAL) {\n      push(p1);\n      copy_tensor();\n      p2 = pop();\n      for (i = q1 = 0, ref8 = EIG_N; (0 <= ref8 ? q1 < ref8 : q1 > ref8); i = 0 <= ref8 ? ++q1 : --q1) {\n        for (j = r1 = 0, ref9 = EIG_N; (0 <= ref9 ? r1 < ref9 : r1 > ref9); j = 0 <= ref9 ? ++r1 : --r1) {\n          push_double(EIG_yydd[EIG_N * i + j]);\n          p2.tensor.elem[EIG_N * i + j] = pop();\n        }\n      }\n    }\n    // p3 = Q\n    if (op === EIGEN || op === EIGENVEC) {\n      push(p1);\n      copy_tensor();\n      p3 = pop();\n      results = [];\n      for (i = s1 = 0, ref10 = EIG_N; (0 <= ref10 ? s1 < ref10 : s1 > ref10); i = 0 <= ref10 ? ++s1 : --s1) {\n        results.push((function() {\n          var ref11, results1, t1;\n          results1 = [];\n          for (j = t1 = 0, ref11 = EIG_N; (0 <= ref11 ? t1 < ref11 : t1 > ref11); j = 0 <= ref11 ? ++t1 : --t1) {\n            push_double(EIG_yyqq[EIG_N * i + j]);\n            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());\n          }\n          return results1;\n        })());\n      }\n      return results;\n    }\n  };\n\n  // free working vars\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 1, q = 3\n\n  //    c  0  s  0\n\n  //    0  1  0  0\n  //  G =\n  //    -s  0  c  0\n\n  //    0  0  0  1\n\n  //  The effect of multiplying G times A is...\n\n  //  row 1 of A    = c (row 1 of A ) + s (row 3 of A )\n  //            n+1                n                 n\n\n  //  row 3 of A    = c (row 3 of A ) - s (row 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  row 1 = c row 1 + s row 3\n\n  //    A[1,1] = c A[1,1] + s A[3,1]\n\n  //    A[1,2] = c A[1,2] + s A[3,2]\n\n  //    A[1,3] = c A[1,3] + s A[3,3]\n\n  //    A[1,4] = c A[1,4] + s A[3,4]\n\n  //  row 3 = c row 3 - s row 1\n\n  //    A[3,1] = c A[3,1] - s A[1,1]\n\n  //    A[3,2] = c A[3,2] - s A[1,2]\n\n  //    A[3,3] = c A[3,3] - s A[1,3]\n\n  //    A[3,4] = c A[3,4] - s A[1,4]\n\n  //                                     T\n  //  The effect of multiplying A times G  is...\n\n  //  col 1 of A    = c (col 1 of A ) + s (col 3 of A )\n  //            n+1                n                 n\n\n  //  col 3 of A    = c (col 3 of A ) - s (col 1 of A )\n  //            n+1                n                 n\n\n  //  In terms of components the overall effect is...\n\n  //  col 1 = c col 1 + s col 3\n\n  //    A[1,1] = c A[1,1] + s A[1,3]\n\n  //    A[2,1] = c A[2,1] + s A[2,3]\n\n  //    A[3,1] = c A[3,1] + s A[3,3]\n\n  //    A[4,1] = c A[4,1] + s A[4,3]\n\n  //  col 3 = c col 3 - s col 1\n\n  //    A[1,3] = c A[1,3] - s A[1,1]\n\n  //    A[2,3] = c A[2,3] - s A[2,1]\n\n  //    A[3,3] = c A[3,3] - s A[3,1]\n\n  //    A[4,3] = c A[4,3] - s A[4,1]\n\n  //  What we want to do is just compute the upper triangle of A since we\n  //  know the lower triangle is identical.\n\n  //  In other words, we just want to update components A[i,j] where i < j.\n\n  //-----------------------------------------------------------------------------\n\n  //  Example: p = 2, q = 5\n\n  //        p      q\n\n  //      j=1  j=2  j=3  j=4  j=5  j=6\n\n  //    i=1  .  A[1,2]  .  .  A[1,5]  .\n\n  //  p  i=2  A[2,1]  A[2,2]  A[2,3]  A[2,4]  A[2,5]  A[2,6]\n\n  //    i=3  .  A[3,2]  .  .  A[3,5]  .\n\n  //    i=4  .  A[4,2]  .  .  A[4,5]  .\n\n  //  q  i=5  A[5,1]  A[5,2]  A[5,3]  A[5,4]  A[5,5]  A[5,6]\n\n  //    i=6  .  A[6,2]  .  .  A[6,5]  .\n\n  //-----------------------------------------------------------------------------\n\n  //  This is what B = GA does:\n\n  //  row 2 = c row 2 + s row 5\n\n  //    B[2,1] = c * A[2,1] + s * A[5,1]\n  //    B[2,2] = c * A[2,2] + s * A[5,2]\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,5] = c * A[2,5] + s * A[5,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //  row 5 = c row 5 - s row 2\n\n  //    B[5,1] = c * A[5,1] + s * A[2,1]\n  //    B[5,2] = c * A[5,2] + s * A[2,2]\n  //    B[5,3] = c * A[5,3] + s * A[2,3]\n  //    B[5,4] = c * A[5,4] + s * A[2,4]\n  //    B[5,5] = c * A[5,5] + s * A[2,5]\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //                 T\n  //  This is what BG  does:\n\n  //  col 2 = c col 2 + s col 5\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n  //    B[2,2] = c * A[2,2] + s * A[2,5]\n  //    B[3,2] = c * A[3,2] + s * A[3,5]\n  //    B[4,2] = c * A[4,2] + s * A[4,5]\n  //    B[5,2] = c * A[5,2] + s * A[5,5]\n  //    B[6,2] = c * A[6,2] + s * A[6,5]\n\n  //  col 5 = c col 5 - s col 2\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[2,5] = c * A[2,5] - s * A[2,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n  //    B[5,5] = c * A[5,5] - s * A[5,2]\n  //    B[6,5] = c * A[6,5] - s * A[6,2]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 1: Just do upper triangle (i < j), B[2,5] = 0\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[5,3]\n  //    B[2,4] = c * A[2,4] + s * A[5,4]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[3,2]\n  //    B[4,5] = c * A[4,5] - s * A[4,2]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 2: Transpose where i > j since A[i,j] == A[j,i]\n\n  //    B[1,2] = c * A[1,2] + s * A[1,5]\n\n  //    B[2,3] = c * A[2,3] + s * A[3,5]\n  //    B[2,4] = c * A[2,4] + s * A[4,5]\n  //    B[2,6] = c * A[2,6] + s * A[5,6]\n\n  //    B[1,5] = c * A[1,5] - s * A[1,2]\n  //    B[3,5] = c * A[3,5] - s * A[2,3]\n  //    B[4,5] = c * A[4,5] - s * A[2,4]\n\n  //    B[5,6] = c * A[5,6] + s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n\n  //  Step 3: Same as above except reorder\n\n  //  k < p    (k = 1)\n\n  //    A[1,2] = c * A[1,2] + s * A[1,5]\n  //    A[1,5] = c * A[1,5] - s * A[1,2]\n\n  //  p < k < q  (k = 3..4)\n\n  //    A[2,3] = c * A[2,3] + s * A[3,5]\n  //    A[3,5] = c * A[3,5] - s * A[2,3]\n\n  //    A[2,4] = c * A[2,4] + s * A[4,5]\n  //    A[4,5] = c * A[4,5] - s * A[2,4]\n\n  //  q < k    (k = 6)\n\n  //    A[2,6] = c * A[2,6] + s * A[5,6]\n  //    A[5,6] = c * A[5,6] - s * A[2,6]\n\n  //-----------------------------------------------------------------------------\n  step = function() {\n    var count, i, i1, j, o, ref, ref1, ref2;\n    i = 0;\n    j = 0;\n    count = 0;\n// for each upper triangle \"off-diagonal\" component do step2\n    for (i = o = 0, ref = EIG_N - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = ref1 = i + 1, ref2 = EIG_N; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (EIG_yydd[EIG_N * i + j] !== 0.0) {\n          step2(i, j);\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  step2 = function(p, q) {\n    var c, cc, i1, j1, k, o, ref, ref1, ref2, s, ss, t, theta;\n    k = 0;\n    t = 0.0;\n    theta = 0.0;\n    c = 0.0;\n    cc = 0.0;\n    s = 0.0;\n    ss = 0.0;\n    // compute c and s\n\n    // from Numerical Recipes (except they have a_qq - a_pp)\n    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];\n    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));\n    if (theta < 0.0) {\n      t = -t;\n    }\n    c = 1.0 / Math.sqrt(t * t + 1.0);\n    s = t * c;\n// D = GD\n\n    // which means \"add rows\"\n    for (k = o = 0, ref = EIG_N; (0 <= ref ? o < ref : o > ref); k = 0 <= ref ? ++o : --o) {\n      cc = EIG_yydd[EIG_N * p + k];\n      ss = EIG_yydd[EIG_N * q + k];\n      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;\n    }\n// D = D transpose(G)\n\n    // which means \"add columns\"\n    for (k = i1 = 0, ref1 = EIG_N; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      cc = EIG_yydd[EIG_N * k + p];\n      ss = EIG_yydd[EIG_N * k + q];\n      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;\n      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;\n    }\n// Q = GQ\n\n    // which means \"add rows\"\n    for (k = j1 = 0, ref2 = EIG_N; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      cc = EIG_yyqq[EIG_N * p + k];\n      ss = EIG_yyqq[EIG_N * q + k];\n      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;\n      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;\n    }\n    EIG_yydd[EIG_N * p + q] = 0.0;\n    return EIG_yydd[EIG_N * q + p] = 0.0;\n  };\n\n  Eval_erf = function() {\n    push(cadr(p1));\n    Eval();\n    return yerf();\n  };\n\n  yerf = function() {\n    save();\n    yyerf();\n    return restore();\n  };\n\n  yyerf = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = 1.0 - erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(ERF);\n      push(p1);\n      negate();\n      list(2);\n      negate();\n      return;\n    }\n    push_symbol(ERF);\n    push(p1);\n    list(2);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  erfc(x)\n\n  //  GW  Added erfc() from Numerical Recipes in C\n\n  //-----------------------------------------------------------------------------\n  Eval_erfc = function() {\n    push(cadr(p1));\n    Eval();\n    return yerfc();\n  };\n\n  yerfc = function() {\n    save();\n    yyerfc();\n    return restore();\n  };\n\n  yyerfc = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (isdouble(p1)) {\n      d = erfc(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(one);\n      return;\n    }\n    push_symbol(ERFC);\n    push(p1);\n    list(2);\n  };\n\n  // from Numerical Recipes in C\n  erfc = function(x) {\n    var ans, t, z;\n    if (x === 0) {\n      return 1.0;\n    }\n    t = 0.0;\n    z = 0.0;\n    ans = 0.0;\n    z = Math.abs(x);\n    t = 1.0 / (1.0 + 0.5 * z);\n    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));\n    if (x >= 0.0) {\n      return ans;\n    } else {\n      return 2.0 - ans;\n    }\n  };\n\n  // Evaluate an expression, for example...\n\n  //  push(p1)\n  //  Eval()\n  //  p2 = pop()\n  Eval = function() {\n    var willEvaluateAsFloats;\n    check_esc_flag();\n    save();\n    p1 = pop();\n    if (p1 == null) {\n      debugger;\n    }\n    if (!evaluatingAsFloats && isfloating(p1)) {\n      willEvaluateAsFloats = true;\n      evaluatingAsFloats++;\n    }\n    switch (p1.k) {\n      case CONS:\n        Eval_cons();\n        break;\n      case NUM:\n        if (evaluatingAsFloats) {\n          push_double(convert_rational_to_double(p1));\n        } else {\n          push(p1);\n        }\n        break;\n      case DOUBLE:\n      case STR:\n        push(p1);\n        break;\n      case TENSOR:\n        Eval_tensor();\n        break;\n      case SYM:\n        Eval_sym();\n        break;\n      default:\n        stop(\"atom?\");\n    }\n    if (willEvaluateAsFloats) {\n      evaluatingAsFloats--;\n    }\n    return restore();\n  };\n\n  Eval_sym = function() {\n    var cycleString, i, o, positionIfSymbolAlreadyBeingEvaluated, ref, ref1;\n    // note that function calls are not processed here\n    // because, since they have an argument (at least an empty one)\n    // they are actually CONs, which is a branch of the\n    // switch before the one that calls this function\n\n    // bare keyword?\n    // If it's a keyword, then we don't look\n    // at the binding array, because keywords\n    // are not redefinable. \n    if (iskeyword(p1)) {\n      push(p1);\n      push(symbol(LAST));\n      list(2);\n      Eval();\n      return;\n    } else if (p1 === symbol(PI) && evaluatingAsFloats) {\n      push_double(Math.PI);\n      return;\n    }\n    // Evaluate symbol's binding\n    p2 = get_binding(p1);\n    if (DEBUG) {\n      console.log(\"looked up: \" + p1 + \" which contains: \" + p2);\n    }\n    push(p2);\n    // differently from standard Lisp,\n    // here the evaluation is not\n    // one-step only, rather it keeps evaluating\n    // \"all the way\" until a symbol is\n    // defined as itself.\n    // Uncomment these two lines to get Lisp\n    // behaviour (and break most tests)\n    if (p1 !== p2) {\n      // detect recursive lookup of symbols, which would otherwise\n      // cause a stack overflow.\n      // Note that recursive functions will still work because\n      // as mentioned at the top, this method doesn't look\n      // up and evaluate function calls.\n      positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);\n      if (positionIfSymbolAlreadyBeingEvaluated !== -1) {\n        cycleString = \"\";\n        for (i = o = ref = positionIfSymbolAlreadyBeingEvaluated, ref1 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n          cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i].printname + \" -> \";\n        }\n        cycleString += p1.printname;\n        stop(\"recursive evaluation of symbols: \" + cycleString);\n        return;\n      }\n      chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);\n      Eval();\n      return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();\n    }\n  };\n\n  Eval_cons = function() {\n    var cons_head;\n    cons_head = car(p1);\n    // normally the cons_head is a symbol,\n    // but sometimes in the case of\n    // functions we don't have a symbol,\n    // we have to evaluate something to get to the\n    // symbol. For example if a function is inside\n    // a tensor, then we need to evaluate an index\n    // access first to get to the function.\n    // In those cases, we find an EVAL here,\n    // so we proceed to EVAL\n    if (car(cons_head) === symbol(EVAL)) {\n      Eval_user_function();\n      return;\n    }\n    if (!issymbol(cons_head)) {\n      stop(\"cons?\");\n    }\n    switch (symnum(cons_head)) {\n      case ABS:\n        return Eval_abs();\n      case ADD:\n        return Eval_add();\n      case ADJ:\n        return Eval_adj();\n      case AND:\n        return Eval_and();\n      case ARCCOS:\n        return Eval_arccos();\n      case ARCCOSH:\n        return Eval_arccosh();\n      case ARCSIN:\n        return Eval_arcsin();\n      case ARCSINH:\n        return Eval_arcsinh();\n      case ARCTAN:\n        return Eval_arctan();\n      case ARCTANH:\n        return Eval_arctanh();\n      case ARG:\n        return Eval_arg();\n      case ATOMIZE:\n        return Eval_atomize();\n      case BESSELJ:\n        return Eval_besselj();\n      case BESSELY:\n        return Eval_bessely();\n      case BINDING:\n        return Eval_binding();\n      case BINOMIAL:\n        return Eval_binomial();\n      case CEILING:\n        return Eval_ceiling();\n      case CHECK:\n        return Eval_check();\n      case CHOOSE:\n        return Eval_choose();\n      case CIRCEXP:\n        return Eval_circexp();\n      case CLEAR:\n        return Eval_clear();\n      case CLEARALL:\n        return Eval_clearall();\n      case CLEARPATTERNS:\n        return Eval_clearpatterns();\n      case CLOCK:\n        return Eval_clock();\n      case COEFF:\n        return Eval_coeff();\n      case COFACTOR:\n        return Eval_cofactor();\n      case CONDENSE:\n        return Eval_condense();\n      case CONJ:\n        return Eval_conj();\n      case CONTRACT:\n        return Eval_contract();\n      case COS:\n        return Eval_cos();\n      case COSH:\n        return Eval_cosh();\n      case DECOMP:\n        return Eval_decomp();\n      case DEGREE:\n        return Eval_degree();\n      case DEFINT:\n        return Eval_defint();\n      case DENOMINATOR:\n        return Eval_denominator();\n      case DERIVATIVE:\n        return Eval_derivative();\n      case DET:\n        return Eval_det();\n      case DIM:\n        return Eval_dim();\n      case DIRAC:\n        return Eval_dirac();\n      case DIVISORS:\n        return Eval_divisors();\n      case DO:\n        return Eval_do();\n      case DOT:\n        return Eval_inner();\n      case DRAW:\n        return Eval_draw();\n      case DSOLVE:\n        return Eval_dsolve();\n      case EIGEN:\n        return Eval_eigen();\n      case EIGENVAL:\n        return Eval_eigenval();\n      case EIGENVEC:\n        return Eval_eigenvec();\n      case ERF:\n        return Eval_erf();\n      case ERFC:\n        return Eval_erfc();\n      case EVAL:\n        return Eval_Eval();\n      case EXP:\n        return Eval_exp();\n      case EXPAND:\n        return Eval_expand();\n      case EXPCOS:\n        return Eval_expcos();\n      case EXPSIN:\n        return Eval_expsin();\n      case FACTOR:\n        return Eval_factor();\n      case FACTORIAL:\n        return Eval_factorial();\n      case FACTORPOLY:\n        return Eval_factorpoly();\n      case FILTER:\n        return Eval_filter();\n      case FLOATF:\n        return Eval_float();\n      case APPROXRATIO:\n        return Eval_approxratio();\n      case FLOOR:\n        return Eval_floor();\n      case FOR:\n        return Eval_for();\n      // this is invoked only when we\n      // evaluate a function that is NOT being called\n      // e.g. when f is a function as we do\n      //  g = f\n      case FUNCTION:\n        return Eval_function_reference();\n      case GAMMA:\n        return Eval_gamma();\n      case GCD:\n        return Eval_gcd();\n      case HERMITE:\n        return Eval_hermite();\n      case HILBERT:\n        return Eval_hilbert();\n      case IMAG:\n        return Eval_imag();\n      case INDEX:\n        return Eval_index();\n      case INNER:\n        return Eval_inner();\n      case INTEGRAL:\n        return Eval_integral();\n      case INV:\n        return Eval_inv();\n      case INVG:\n        return Eval_invg();\n      case ISINTEGER:\n        return Eval_isinteger();\n      case ISPRIME:\n        return Eval_isprime();\n      case LAGUERRE:\n        return Eval_laguerre();\n      //  when LAPLACE then Eval_laplace()\n      case LCM:\n        return Eval_lcm();\n      case LEADING:\n        return Eval_leading();\n      case LEGENDRE:\n        return Eval_legendre();\n      case LOG:\n        return Eval_log();\n      case LOOKUP:\n        return Eval_lookup();\n      case MOD:\n        return Eval_mod();\n      case MULTIPLY:\n        return Eval_multiply();\n      case NOT:\n        return Eval_not();\n      case NROOTS:\n        return Eval_nroots();\n      case NUMBER:\n        return Eval_number();\n      case NUMERATOR:\n        return Eval_numerator();\n      case OPERATOR:\n        return Eval_operator();\n      case OR:\n        return Eval_or();\n      case OUTER:\n        return Eval_outer();\n      case PATTERN:\n        return Eval_pattern();\n      case PATTERNSINFO:\n        return Eval_patternsinfo();\n      case POLAR:\n        return Eval_polar();\n      case POWER:\n        return Eval_power();\n      case PRIME:\n        return Eval_prime();\n      case PRINT:\n        return Eval_print();\n      case PRINT2DASCII:\n        return Eval_print2dascii();\n      case PRINTFULL:\n        return Eval_printcomputer();\n      case PRINTLATEX:\n        return Eval_printlatex();\n      case PRINTLIST:\n        return Eval_printlist();\n      case PRINTPLAIN:\n        return Eval_printhuman();\n      case PRODUCT:\n        return Eval_product();\n      case QUOTE:\n        return Eval_quote();\n      case QUOTIENT:\n        return Eval_quotient();\n      case RANK:\n        return Eval_rank();\n      case RATIONALIZE:\n        return Eval_rationalize();\n      case REAL:\n        return Eval_real();\n      case ROUND:\n        return Eval_round();\n      case YYRECT:\n        return Eval_rect();\n      case ROOTS:\n        return Eval_roots();\n      case SETQ:\n        return Eval_setq();\n      case SGN:\n        return Eval_sgn();\n      case SILENTPATTERN:\n        return Eval_silentpattern();\n      case SIMPLIFY:\n        return Eval_simplify();\n      case SIN:\n        return Eval_sin();\n      case SINH:\n        return Eval_sinh();\n      case SHAPE:\n        return Eval_shape();\n      case SQRT:\n        return Eval_sqrt();\n      case STOP:\n        return Eval_stop();\n      case SUBST:\n        return Eval_subst();\n      case SUM:\n        return Eval_sum();\n      case SYMBOLSINFO:\n        return Eval_symbolsinfo();\n      case TAN:\n        return Eval_tan();\n      case TANH:\n        return Eval_tanh();\n      case TAYLOR:\n        return Eval_taylor();\n      case TEST:\n        return Eval_test();\n      case TESTEQ:\n        return Eval_testeq();\n      case TESTGE:\n        return Eval_testge();\n      case TESTGT:\n        return Eval_testgt();\n      case TESTLE:\n        return Eval_testle();\n      case TESTLT:\n        return Eval_testlt();\n      case TRANSPOSE:\n        return Eval_transpose();\n      case UNIT:\n        return Eval_unit();\n      case ZERO:\n        return Eval_zero();\n      default:\n        return Eval_user_function();\n    }\n  };\n\n  Eval_binding = function() {\n    return push(get_binding(cadr(p1)));\n  };\n\n  Eval_check = function() {\n    var checkResult;\n    // check the argument\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // returned null: unknown result\n      // leave the whole check unevalled\n      return push(p1);\n    } else {\n      // returned 1 or 0\n      return push_integer(checkResult);\n    }\n  };\n\n  Eval_det = function() {\n    push(cadr(p1));\n    Eval();\n    return det();\n  };\n\n  Eval_dim = function() {\n    var n;\n    //int n\n    push(cadr(p1));\n    Eval();\n    p2 = pop();\n    if (iscons(cddr(p1))) {\n      push(caddr(p1));\n      Eval();\n      n = pop_integer();\n    } else {\n      n = 1;\n    }\n    if (!istensor(p2)) {\n      return push_integer(1); // dim of scalar is 1\n    } else if (n < 1 || n > p2.tensor.ndim) {\n      return push(p1);\n    } else {\n      return push_integer(p2.tensor.dim[n - 1]);\n    }\n  };\n\n  Eval_divisors = function() {\n    push(cadr(p1));\n    Eval();\n    return divisors();\n  };\n\n  Eval_do = function() {\n    var results;\n    push(car(p1));\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      pop();\n      push(car(p1));\n      Eval();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_dsolve = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    return dsolve();\n  };\n\n  // for example, Eval(f,x,2)\n  Eval_Eval = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      push(cadr(p1));\n      Eval();\n      subst();\n      p1 = cddr(p1);\n    }\n    return Eval();\n  };\n\n  // exp evaluation: it replaces itself with\n  // a POWER(E,something) node and evals that one\n  Eval_exp = function() {\n    push(cadr(p1));\n    Eval();\n    return exponential();\n  };\n\n  Eval_factorial = function() {\n    push(cadr(p1));\n    Eval();\n    return factorial();\n  };\n\n  Eval_factorpoly = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    factorpoly();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factorpoly();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  Eval_hermite = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return hermite();\n  };\n\n  Eval_hilbert = function() {\n    push(cadr(p1));\n    Eval();\n    return hilbert();\n  };\n\n  Eval_index = function() {\n    var h, orig, theTensor;\n    h = tos;\n    orig = p1;\n    \n    // look into the head of the list,\n    // when evaluated it should be a tensor\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    theTensor = stack[tos - 1];\n    if (isNumericAtom(theTensor)) {\n      stop(\"trying to access a scalar as a tensor\");\n    }\n    if (!istensor(theTensor)) {\n      // the tensor is not allocated yet, so\n      // leaving the expression unevalled\n      moveTos(h);\n      push(orig);\n      return;\n    }\n    // we examined the head of the list which\n    // was the tensor, now look into\n    // the indexes\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      if (!isintegerorintegerfloat(stack[tos - 1])) {\n        // index with something other than\n        // an integer\n        moveTos(h);\n        push(orig);\n        return;\n      }\n      p1 = cdr(p1);\n    }\n    return index_function(tos - h);\n  };\n\n  Eval_inv = function() {\n    push(cadr(p1));\n    Eval();\n    return inv();\n  };\n\n  Eval_invg = function() {\n    push(cadr(p1));\n    Eval();\n    return invg();\n  };\n\n  Eval_isinteger = function() {\n    var n;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isrational(p1)) {\n      if (isinteger(p1)) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    if (isdouble(p1)) {\n      n = Math.floor(p1.d);\n      if (n === p1.d) {\n        push(one);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    push_symbol(ISINTEGER);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_number = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (p1.k === NUM || p1.k === DOUBLE) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_operator = function() {\n    var h;\n    h = tos;\n    push_symbol(OPERATOR);\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      p1 = cdr(p1);\n    }\n    return list(tos - h);\n  };\n\n  // quote definition\n  Eval_quote = function() {\n    return push(cadr(p1));\n  };\n\n  // rank definition\n  Eval_rank = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (istensor(p1)) {\n      return push_integer(p1.tensor.ndim);\n    } else {\n      return push(zero);\n    }\n  };\n\n  // Evaluates the right side and assigns the\n  // result of the evaluation to the left side.\n  // It's called setq because it stands for \"set quoted\" from Lisp,\n  // see:\n  //   http://stackoverflow.com/questions/869529/difference-between-set-setq-and-setf-in-common-lisp\n  // Note that this also takes case of assigning to a tensor\n  // element, which is something that setq wouldn't do\n  // in list, see comments further down below.\n\n  // Example:\n  //   f = x\n  //   // f evaluates to x, so x is assigned to g really\n  //   // rather than actually f being assigned to g\n  //   g = f\n  //   f = y\n  //   g\n  //   > x\n  Eval_setq = function() {\n    // case of tensor\n    if (caadr(p1) === symbol(INDEX)) {\n      setq_indexed();\n      return;\n    }\n    // case of function definition\n    if (iscons(cadr(p1))) {\n      define_user_function();\n      return;\n    }\n    if (!issymbol(cadr(p1))) {\n      stop(\"symbol assignment: error in symbol\");\n    }\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    set_binding(cadr(p1), p2);\n    // An assignment returns nothing.\n    // This is unlike most programming languages\n    // where an assignment does return the\n    // assigned value.\n    // TODO Could be changed.\n    return push(symbol(NIL));\n  };\n\n  // Here \"setq\" is a misnomer because\n  // setq wouldn't work in Lisp to set array elements\n  // since setq stands for \"set quoted\" and you wouldn't\n  // quote an array element access.\n  // You'd rather use setf, which is a macro that can\n  // assign a value to anything.\n  //   (setf (aref YourArray 2) \"blue\")\n  // see\n  //   http://stackoverflow.com/questions/18062016/common-lisp-how-to-set-an-element-in-a-2d-array\n  //-----------------------------------------------------------------------------\n\n  //  Example: a[1] = b\n\n  //  p1  *-------*-----------------------*\n  //    |  |      |\n  //    setq  *-------*-------*  b\n  //      |  |  |\n  //      index  a  1\n\n  //  cadadr(p1) -> a\n\n  //-----------------------------------------------------------------------------\n  setq_indexed = function() {\n    var h;\n    p4 = cadadr(p1);\n    if (!issymbol(p4)) {\n      // this is likely to happen when one tries to\n      // do assignments like these\n      //   1[2] = 3\n      // or\n      //   f(x)[1] = 2\n      // or\n      //   [[1,2],[3,4]][5] = 6\n\n      // In other words, one can only do\n      // a straight assignment like\n      //   existingMatrix[index] = something\n      stop(\"indexed assignment: expected a symbol name\");\n    }\n    h = tos;\n    push(caddr(p1));\n    Eval();\n    p2 = cdadr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      p2 = cdr(p2);\n    }\n    set_component(tos - h);\n    p3 = pop();\n    set_binding(p4, p3);\n    return push(symbol(NIL));\n  };\n\n  Eval_sqrt = function() {\n    push(cadr(p1));\n    Eval();\n    push_rational(1, 2);\n    return power();\n  };\n\n  Eval_stop = function() {\n    return stop(\"user stop\");\n  };\n\n  Eval_subst = function() {\n    push(cadddr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadr(p1));\n    Eval();\n    subst();\n    return Eval(); // normalize\n  };\n\n  \n  // always returns a matrix with rank 2\n  // i.e. two dimensions,\n  // the passed parameter is the size\n  Eval_unit = function() {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    n = pop_integer();\n    if (isNaN(n)) {\n      push(p1);\n      return;\n    }\n    if (n < 1) {\n      push(p1);\n      return;\n    }\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1.tensor.elem[n * i + i] = one;\n    }\n    check_tensor_dimensions(p1);\n    return push(p1);\n  };\n\n  Eval_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  // like Eval() except \"=\" (assignment) is treated\n  // as \"==\" (equality test)\n  // This is because\n  //  * this allows users to be lazy and just\n  //    use \"=\" instead of \"==\" as per more common\n  //    mathematical notation\n  //  * in many places we don't expect an assignment\n  //    e.g. we don't expect to test the zero-ness\n  //    of an assignment or the truth value of\n  //    an assignment\n  // Note that these are questionable assumptions\n  // as for example in most programming languages one\n  // can indeed test the value of an assignment (the\n  // value is just the evaluation of the right side)\n  Eval_predicate = function() {\n    save();\n    p1 = top();\n    if (car(p1) === symbol(SETQ)) {\n      // replace the assignment in the\n      // head with an equality test\n      pop();\n      push_symbol(TESTEQ);\n      push(cadr(p1));\n      push(caddr(p1));\n      list(3);\n    }\n    Eval();\n    return restore();\n  };\n\n  // Partial fraction expansion\n\n  // Example\n\n  //      expand(1/(x^3+x^2),x)\n\n  //        1      1       1\n  //      ---- - --- + -------\n  //        2     x     x + 1\n  //       x\n  Eval_expand = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    return expand();\n  };\n\n  //define A p2\n  //define B p3\n  //define C p4\n  //define F p5\n  //define P p6\n  //define Q p7\n  //define T p8\n  //define X p9\n  expand = function() {\n    var prev_expanding;\n    save();\n    p9 = pop();\n    p5 = pop();\n    if (istensor(p5)) {\n      expand_tensor();\n      restore();\n      return;\n    }\n    // if sum of terms then sum over the expansion of each term\n    if (car(p5) === symbol(ADD)) {\n      push_integer(0);\n      p1 = cdr(p5);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p9);\n        expand();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // B = numerator\n    push(p5);\n    numerator();\n    p3 = pop();\n    // A = denominator\n    push(p5);\n    denominator();\n    p2 = pop();\n    remove_negative_exponents();\n    // Q = quotient\n    push(p3);\n    push(p2);\n    push(p9);\n    // if the denominator is one then always bail out\n    // also bail out if the denominator is not one but\n    // it's not anything recognizable as a polynomial.\n    if (isone(p3) || isone(p2)) {\n      if (!ispolyexpandedform(p2, p9) || isone(p2)) {\n        pop();\n        pop();\n        pop();\n        push(p5);\n        // p5 is the original input, leave unchanged\n        restore();\n        return;\n      }\n    }\n    divpoly();\n    p7 = pop();\n    // remainder B = B - A * Q\n    push(p3);\n    push(p2);\n    push(p7);\n    multiply();\n    subtract();\n    p3 = pop();\n    // if the remainder is zero then we're done\n    if (isZeroAtomOrTensor(p3)) {\n      push(p7);\n      restore();\n      return;\n    }\n    // A = factor(A)\n\n    //console.log(\"expand - to be factored: \" + p2)\n    push(p2);\n    push(p9);\n    factorpoly();\n    p2 = pop();\n    //console.log(\"expand - factored to: \" + p2)\n    expand_get_C();\n    expand_get_B();\n    expand_get_A();\n    if (istensor(p4)) {\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      inv();\n      expanding = prev_expanding;\n      push(p3);\n      inner();\n      push(p2);\n      inner();\n    } else {\n      push(p3);\n      push(p4);\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p2);\n      multiply();\n    }\n    push(p7);\n    add();\n    return restore();\n  };\n\n  expand_tensor = function() {\n    var i, o, ref;\n    i = 0;\n    push(p5);\n    copy_tensor();\n    p5 = pop();\n    for (i = o = 0, ref = p5.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p5.tensor.elem[i]);\n      push(p9);\n      expand();\n      p5.tensor.elem[i] = pop();\n    }\n    return push(p5);\n  };\n\n  remove_negative_exponents = function() {\n    var h, i, j, k, n, o, ref;\n    h = 0;\n    i = 0;\n    j = 0;\n    k = 0;\n    n = 0;\n    h = tos;\n    factors(p2);\n    factors(p3);\n    n = tos - h;\n    // find the smallest exponent\n    j = 0;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p1 = stack[h + i];\n      if (car(p1) !== symbol(POWER)) {\n        continue;\n      }\n      if (cadr(p1) !== p9) {\n        continue;\n      }\n      push(caddr(p1));\n      k = pop_integer();\n      if (isNaN(k)) {\n        continue;\n      }\n      if (k < j) {\n        j = k;\n      }\n    }\n    moveTos(h);\n    if (j === 0) {\n      return;\n    }\n    // A = A / X^j\n    push(p2);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    p2 = pop();\n    // B = B / X^j\n    push(p3);\n    push(p9);\n    push_integer(-j);\n    power();\n    multiply();\n    return p3 = pop();\n  };\n\n  // Returns the expansion coefficient matrix C.\n\n  // Example:\n\n  //       B         1\n  //      --- = -----------\n  //       A      2 \n  //             x (x + 1)\n\n  // We have\n\n  //       B     Y1     Y2      Y3\n  //      --- = ---- + ---- + -------\n  //       A      2     x      x + 1\n  //             x\n\n  // Our task is to solve for the unknowns Y1, Y2, and Y3.\n\n  // Multiplying both sides by A yields\n\n  //           AY1     AY2      AY3\n  //      B = ----- + ----- + -------\n  //            2      x       x + 1\n  //           x\n\n  // Let\n\n  //            A               A                 A\n  //      W1 = ----       W2 = ---        W3 = -------\n  //             2              x               x + 1\n  //            x\n\n  // Then the coefficient matrix C is\n\n  //              coeff(W1,x,0)   coeff(W2,x,0)   coeff(W3,x,0)\n\n  //       C =    coeff(W1,x,1)   coeff(W2,x,1)   coeff(W3,x,1)\n\n  //              coeff(W1,x,2)   coeff(W2,x,2)   coeff(W3,x,2)\n\n  // It follows that\n\n  //       coeff(B,x,0)     Y1\n\n  //       coeff(B,x,1) = C Y2\n\n  //       coeff(B,x,2) =   Y3\n\n  // Hence\n\n  //       Y1       coeff(B,x,0)\n  //             -1\n  //       Y2 = C   coeff(B,x,1)\n\n  //       Y3       coeff(B,x,2)\n  expand_get_C = function() {\n    var a, h, i, i1, j, n, o, prev_expanding, ref, ref1;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    //U **a\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p1 = cdr(p2);\n      while (iscons(p1)) {\n        p5 = car(p1);\n        expand_get_CF();\n        p1 = cdr(p1);\n      }\n    } else {\n      p5 = p2;\n      expand_get_CF();\n    }\n    n = tos - h;\n    if (n === 1) {\n      p4 = pop();\n      return;\n    }\n    p4 = alloc_tensor(n * n);\n    p4.tensor.ndim = 2;\n    p4.tensor.dim[0] = n;\n    p4.tensor.dim[1] = n;\n    a = h;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push(stack[a + j]);\n        push(p9);\n        push_integer(i);\n        power();\n        prev_expanding = expanding;\n        expanding = 1;\n        divide();\n        expanding = prev_expanding;\n        push(p9);\n        filter();\n        p4.tensor.elem[n * i + j] = pop();\n      }\n    }\n    return moveTos(tos - n);\n  };\n\n  // The following table shows the push order for simple roots, repeated roots,\n  // and inrreducible factors.\n\n  //  Factor F        Push 1st        Push 2nd         Push 3rd      Push 4th\n\n  //                   A\n  //  x               ---\n  //                   x\n\n  //   2               A               A\n  //  x               ----            ---\n  //                    2              x\n  //                   x\n\n  //                     A\n  //  x + 1           -------\n  //                   x + 1\n\n  //         2            A              A\n  //  (x + 1)         ----------      -------\n  //                          2        x + 1\n  //                   (x + 1)\n\n  //   2                   A               Ax\n  //  x  + x + 1      ------------    ------------\n  //                    2               2\n  //                   x  + x + 1      x  + x + 1\n\n  //    2         2          A              Ax              A             Ax\n  //  (x  + x + 1)    --------------- ---------------  ------------  ------------\n  //                     2         2     2         2     2             2\n  //                   (x  + x + 1)    (x  + x + 1)     x  + x + 1    x  + x + 1\n\n  // For T = A/F and F = P^N we have\n\n  //      Factor F          Push 1st    Push 2nd    Push 3rd    Push 4th\n\n  //      x                 T\n\n  //       2\n  //      x                 T           TP\n\n  //      x + 1             T\n\n  //             2\n  //      (x + 1)           T           TP\n\n  //       2\n  //      x  + x + 1        T           TX\n\n  //        2         2\n  //      (x  + x + 1)      T           TX          TP          TPX\n\n  // Hence we want to push in the order\n\n  //      T * (P ^ i) * (X ^ j)\n\n  // for all i, j such that\n\n  //      i = 0, 1, ..., N - 1\n\n  //      j = 0, 1, ..., deg(P) - 1\n\n  // where index j runs first.\n  expand_get_CF = function() {\n    var d, i, j, n, o, prev_expanding, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    prev_expanding = expanding;\n    expanding = 1;\n    trivial_divide();\n    expanding = prev_expanding;\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p6 = cadr(p5);\n    } else {\n      n = 1;\n      p6 = p5;\n    }\n    push(p6);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p8);\n          push(p6);\n          push_integer(i);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          expanding = prev_expanding;\n          push(p9);\n          push_integer(j);\n          power();\n          prev_expanding = expanding;\n          expanding = 1;\n          multiply();\n          results1.push(expanding = prev_expanding);\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Returns T = A/F where F is a factor of A.\n  trivial_divide = function() {\n    var h;\n    h = 0;\n    if (car(p2) === symbol(MULTIPLY)) {\n      h = tos;\n      p0 = cdr(p2);\n      while (iscons(p0)) {\n        if (!equal(car(p0), p5)) {\n          push(car(p0));\n          Eval(); // force expansion of (x+1)^2, f.e.\n        }\n        p0 = cdr(p0);\n      }\n      multiply_all(tos - h);\n    } else {\n      push_integer(1);\n    }\n    return p8 = pop();\n  };\n\n  // Returns the expansion coefficient vector B.\n  expand_get_B = function() {\n    var i, n, o, prev_expanding, ref;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      return;\n    }\n    n = p4.tensor.dim[0];\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(p3);\n      push(p9);\n      push_integer(i);\n      power();\n      prev_expanding = expanding;\n      expanding = 1;\n      divide();\n      expanding = prev_expanding;\n      push(p9);\n      filter();\n      p8.tensor.elem[i] = pop();\n    }\n    return p3 = p8;\n  };\n\n  // Returns the expansion fractions in A.\n  expand_get_A = function() {\n    var h, i, n, o, ref;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (!istensor(p4)) {\n      push(p2);\n      reciprocate();\n      p2 = pop();\n      return;\n    }\n    h = tos;\n    if (car(p2) === symbol(MULTIPLY)) {\n      p8 = cdr(p2);\n      while (iscons(p8)) {\n        p5 = car(p8);\n        expand_get_AF();\n        p8 = cdr(p8);\n      }\n    } else {\n      p5 = p2;\n      expand_get_AF();\n    }\n    n = tos - h;\n    p8 = alloc_tensor(n);\n    p8.tensor.ndim = 1;\n    p8.tensor.dim[0] = n;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p8.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    return p2 = p8;\n  };\n\n  expand_get_AF = function() {\n    var d, i, j, n, o, ref, results;\n    d = 0;\n    i = 0;\n    j = 0;\n    n = 1;\n    if (!Find(p5, p9)) {\n      return;\n    }\n    if (car(p5) === symbol(POWER)) {\n      push(caddr(p5));\n      n = pop_integer();\n      p5 = cadr(p5);\n    }\n    push(p5);\n    push(p9);\n    degree();\n    d = pop_integer();\n    results = [];\n    for (i = o = ref = n; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      results.push((function() {\n        var i1, ref1, results1;\n        results1 = [];\n        for (j = i1 = 0, ref1 = d; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n          push(p5);\n          push_integer(i);\n          power();\n          reciprocate();\n          push(p9);\n          push_integer(j);\n          power();\n          results1.push(multiply());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  // Do the exponential cosine function.\n  Eval_expcos = function() {\n    push(cadr(p1));\n    Eval();\n    return expcos();\n  };\n\n  expcos = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push_rational(1, 2);\n    multiply();\n    add();\n    return restore();\n  };\n\n  // Do the exponential sine function.\n  Eval_expsin = function() {\n    push(cadr(p1));\n    Eval();\n    return expsin();\n  };\n\n  expsin = function() {\n    save();\n    p1 = pop();\n    push(imaginaryunit);\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    push(imaginaryunit);\n    negate();\n    push(p1);\n    multiply();\n    exponential();\n    push(imaginaryunit);\n    divide();\n    push_rational(1, 2);\n    multiply();\n    subtract();\n    return restore();\n  };\n\n  // factor a polynomial or integer\n  Eval_factor = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    factor();\n    // more factoring?\n    p1 = cdddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      factor_again();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  factor_again = function() {\n    var h, n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        factor_term();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      factor_term();\n    }\n    n = tos - h;\n    if (n > 1) {\n      multiply_all_noexpand(n);\n    }\n    return restore();\n  };\n\n  factor_term = function() {\n    save();\n    factorpoly();\n    p1 = pop();\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n    }\n    return restore();\n  };\n\n  factor = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isinteger(p1)) {\n      push(p1);\n      factor_number(); // see pollard.cpp\n    } else {\n      push(p1);\n      push(p2);\n      factorpoly();\n    }\n    return restore();\n  };\n\n  // for factoring small integers (2^32 or less)\n  factor_small_number = function() {\n    var d, expo, i, n, o, ref;\n    i = 0;\n    save();\n    n = pop_integer();\n    if (isNaN(n)) {\n      stop(\"number too big to factor\");\n    }\n    if (n < 0) {\n      n = -n;\n    }\n    for (i = o = 0, ref = MAXPRIMETAB; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      d = primetab[i];\n      if (d > n / d) {\n        break;\n      }\n      expo = 0;\n      while (n % d === 0) {\n        n /= d;\n        expo++;\n      }\n      if (expo) {\n        push_integer(d);\n        push_integer(expo);\n      }\n    }\n    if (n > 1) {\n      push_integer(n);\n      push_integer(1);\n    }\n    return restore();\n  };\n\n  factorial = function() {\n    var n;\n    n = 0;\n    save();\n    p1 = pop();\n    push(p1);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(FACTORIAL);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    bignum_factorial(n);\n    return restore();\n  };\n\n  // simplification rules for factorials (m < n)\n\n  //  (e + 1) * factorial(e)  ->  factorial(e + 1)\n\n  //  factorial(e) / e  ->  factorial(e - 1)\n\n  //  e / factorial(e)  ->  1 / factorial(e - 1)\n\n  //  factorial(e + n)\n  //  ----------------  ->  (e + m + 1)(e + m + 2)...(e + n)\n  //  factorial(e + m)\n\n  //  factorial(e + m)                               1\n  //  ----------------  ->  --------------------------------\n  //  factorial(e + n)    (e + m + 1)(e + m + 2)...(e + n)\n\n  // this function is not actually used, but\n  // all these simplifications\n  // do happen automatically via simplify\n  simplifyfactorials = function() {\n    var x;\n    x = 0;\n    save();\n    x = expanding;\n    expanding = 0;\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      push(zero);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        simplifyfactorials();\n        add();\n        p1 = cdr(p1);\n      }\n      expanding = x;\n      restore();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      sfac_product();\n      expanding = x;\n      restore();\n      return;\n    }\n    push(p1);\n    expanding = x;\n    return restore();\n  };\n\n  sfac_product = function() {\n    var i, i1, j, j1, n, o, ref, ref1, ref2, ref3, s;\n    i = 0;\n    j = 0;\n    n = 0;\n    s = tos;\n    p1 = cdr(p1);\n    n = 0;\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n      n++;\n    }\n    for (i = o = 0, ref = n - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      for (j = i1 = ref1 = i + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); j = ref1 <= ref2 ? ++i1 : --i1) {\n        if (stack[s + j] === symbol(NIL)) {\n          continue;\n        }\n        sfac_product_f(s, i, j);\n      }\n    }\n    push(one);\n    for (i = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      if (stack[s + i] === symbol(NIL)) {\n        continue;\n      }\n      push(stack[s + i]);\n      multiply();\n    }\n    p1 = pop();\n    moveTos(tos - n);\n    return push(p1);\n  };\n\n  sfac_product_f = function(s, a, b) {\n    var i, n, o, ref;\n    i = 0;\n    n = 0;\n    p1 = stack[s + a];\n    p2 = stack[s + b];\n    if (ispower(p1)) {\n      p3 = caddr(p1);\n      p1 = cadr(p1);\n    } else {\n      p3 = one;\n    }\n    if (ispower(p2)) {\n      p4 = caddr(p2);\n      p2 = cadr(p2);\n    } else {\n      p4 = one;\n    }\n    if (isfactorial(p1) && isfactorial(p2)) {\n      // Determine if the powers cancel.\n      push(p3);\n      push(p4);\n      add();\n      yyexpand();\n      n = pop_integer();\n      if (n !== 0) {\n        return;\n      }\n      // Find the difference between the two factorial args.\n\n      // For example, the difference between (a + 2)! and a! is 2.\n      push(cadr(p1));\n      push(cadr(p2));\n      subtract();\n      yyexpand();\n      n = pop_integer();\n      if (n === 0 || isNaN(n)) {\n        return;\n      }\n      if (n < 0) {\n        n = -n;\n        p5 = p1;\n        p1 = p2;\n        p2 = p5;\n        p5 = p3;\n        p3 = p4;\n        p4 = p5;\n      }\n      push(one);\n      for (i = o = 1, ref = n; (1 <= ref ? o <= ref : o >= ref); i = 1 <= ref ? ++o : --o) {\n        push(cadr(p2));\n        push_integer(i);\n        add();\n        push(p3);\n        power();\n        multiply();\n      }\n      stack[s + a] = pop();\n      return stack[s + b] = symbol(NIL);\n    }\n  };\n\n  // Factor a polynomial\n  factorpoly = function() {\n    var polynomial, variable;\n    if (DEBUG) {\n      console.log(\"factorpoly: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    variable = pop();\n    polynomial = pop();\n    if (!Find(polynomial, variable) || !ispolyexpandedform(polynomial, variable) || !issymbol(variable)) {\n      push(polynomial);\n    } else {\n      yyfactorpoly(variable, polynomial);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    tos-2    true polynomial\n\n  //      tos-1    free variable\n\n  //  Output:    factored polynomial on stack\n\n  //-----------------------------------------------------------------------------\n  yyfactorpoly = function(variable, polynomial) {\n    var A, AxPlusB, B, checkingTheDivision, dividend, factpoly_expo, firstParam, foundComplexRoot, foundRealRoot, h, i, i1, j1, l1, o, partOfPolynomialFactoredSoFar, polycoeff, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, secondDegreePloly, secondParam, whichRootsAreWeFinding;\n    if (DEBUG) {\n      firstParam = variable;\n      secondParam = polynomial;\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam);\n    }\n    save();\n    h = tos;\n    if (isfloating(polynomial)) {\n      stop(\"floating point numbers in polynomial\");\n    }\n    polycoeff = tos;\n    factpoly_expo = coeff(variable, polynomial) - 1;\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo before rationalize_coefficients: \" + factpoly_expo);\n    }\n    partOfPolynomialFactoredSoFar = rationalize_coefficients(h);\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo  after rationalize_coefficients: \" + factpoly_expo);\n    }\n    // for univariate polynomials we could do factpoly_expo > 1\n    whichRootsAreWeFinding = \"real\";\n    remainingPoly = null;\n    while (factpoly_expo > 0) {\n      if (DEBUG) {\n        console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" factpoly_expo inside while loop: \" + factpoly_expo);\n      }\n      if (isZeroAtomOrTensor(stack[polycoeff + 0])) {\n        if (DEBUG) {\n          console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" isZeroAtomOrTensor\");\n        }\n        A = one;\n        B = zero;\n      } else {\n        //console.log(\"trying to find a \" + whichRootsAreWeFinding + \" root\")\n        if (whichRootsAreWeFinding === \"real\") {\n          [foundRealRoot, A, B] = get_factor_from_real_root(variable, factpoly_expo, polycoeff);\n        } else if (whichRootsAreWeFinding === \"complex\") {\n          [foundComplexRoot, A] = get_factor_from_complex_root(remainingPoly, factpoly_expo, polycoeff);\n        }\n      }\n      if (whichRootsAreWeFinding === \"real\") {\n        if (foundRealRoot === 0) {\n          whichRootsAreWeFinding = \"complex\";\n          continue;\n        } else {\n          // build the 1-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          multiply();\n          push(B); // B\n          add();\n          AxPlusB = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + AxPlusB);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(AxPlusB)\n            negate()\n            AxPlusB = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          push(AxPlusB);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          // ok now on stack we have the coefficients of the\n          // remaining part of the polynomial still to factor.\n          // Divide it by the newly-found factor so that\n          // the stack then contains the coefficients of the\n          // polynomial part still left to factor.\n          yydivpoly(factpoly_expo, polycoeff, A, B);\n          while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {\n            factpoly_expo--;\n          }\n          push(zero);\n          for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n            push(stack[polycoeff + i]);\n            push(variable); // the free variable\n            push_integer(i);\n            power();\n            multiply();\n            add();\n          }\n          remainingPoly = pop();\n        }\n      //console.log(\"real branch remainingPoly: \" + remainingPoly)\n      } else if (whichRootsAreWeFinding === \"complex\") {\n        if (foundComplexRoot === 0) {\n          break;\n        } else {\n          // build the 2-degree polynomial out of the\n          // real solution that was just found.\n          push(A); // A\n          push(variable); // x\n          subtract();\n          //console.log(\"first factor: \" + stack[tos-1].toString())\n          push(A); // A\n          conjugate();\n          push(variable); // x\n          subtract();\n          //console.log(\"second factor: \" + stack[tos-1].toString())\n          multiply();\n          //if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff+factpoly_expo]))\n          //  negate()\n          //  negate_noexpand()\n          secondDegreePloly = pop();\n          if (DEBUG) {\n            console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" success\\nFACTOR=\" + secondDegreePloly);\n          }\n          // factor out negative sign (not req'd because A > 1)\n          //if 0\n          /*\n          if (isnegativeterm(A))\n            push(secondDegreePloly)\n            negate()\n            secondDegreePloly = pop()\n            push(partOfPolynomialFactoredSoFar)\n            negate_noexpand()\n            partOfPolynomialFactoredSoFar = pop()\n          */\n          //endif\n\n          // partOfPolynomialFactoredSoFar is the part of the polynomial that was factored so far,\n          // add the newly found factor to it. Note that we are not actually\n          // multiplying the polynomials fully, we are just leaving them\n          // expressed as (P1)*(P2), we are not expanding the product.\n          push(partOfPolynomialFactoredSoFar);\n          previousFactorisation = pop();\n          //console.log(\"previousFactorisation: \" + previousFactorisation)\n          push(partOfPolynomialFactoredSoFar);\n          push(secondDegreePloly);\n          multiply_noexpand();\n          partOfPolynomialFactoredSoFar = pop();\n          if (remainingPoly == null) {\n            push(zero);\n            for (i = i1 = 0, ref1 = factpoly_expo; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n              push(stack[polycoeff + i]);\n              push(variable); // the free variable\n              push_integer(i);\n              power();\n              multiply();\n              add();\n            }\n            remainingPoly = pop();\n          }\n          //console.log(\"original polynomial (dividend): \" + remainingPoly)\n          dividend = remainingPoly;\n          //push(dividend)\n          //degree()\n          //startingDegree = pop()\n          push(dividend);\n          //console.log(\"dividing \" + stack[tos-1].toString() + \" by \" + secondDegreePloly)\n          push(secondDegreePloly); // divisor\n          push(variable); // X\n          divpoly();\n          remainingPoly = pop();\n          push(remainingPoly);\n          push(secondDegreePloly); // divisor\n          multiply();\n          checkingTheDivision = pop();\n          if (!equal(checkingTheDivision, dividend)) {\n            //push(dividend)\n            //gcd_sum()\n            //console.log(\"gcd top of stack: \" + stack[tos-1].toString())\n            if (DEBUG) {\n              console.log(\"we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting\");\n            }\n            if (DEBUG) {\n              console.log(\"so just returning previousFactorisation times dividend: \" + previousFactorisation + \" * \" + dividend);\n            }\n            push(previousFactorisation);\n            push(dividend);\n            prev_expanding = expanding;\n            expanding = 0;\n            yycondense();\n            expanding = prev_expanding;\n            multiply_noexpand();\n            partOfPolynomialFactoredSoFar = pop();\n            stack[h] = partOfPolynomialFactoredSoFar;\n            moveTos(h + 1);\n            restore();\n            return;\n          }\n//console.log(\"result: (still to be factored) \" + remainingPoly)\n\n          //push(remainingPoly)\n//degree()\n//remainingDegree = pop()\n/*\nif compare_numbers(startingDegree, remainingDegree)\n * ok even if we found a complex root that\n * together with the conjugate generates a poly in Z,\n * that doesn't mean that the division would end up in Z.\n * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots\n * so a factor is 1+x^2 ( = (x+i)*(x-i))\n * BUT \n */\n          for (i = j1 = 0, ref2 = factpoly_expo; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n            pop();\n          }\n          coeff(variable, remainingPoly);\n          factpoly_expo -= 2;\n        }\n      }\n    }\n    //console.log(\"factpoly_expo: \" + factpoly_expo)\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" building the remaining unfactored part of the polynomial\");\n    }\n    push(zero);\n    for (i = l1 = 0, ref3 = factpoly_expo; (0 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[polycoeff + i]);\n      push(variable); // the free variable\n      push_integer(i);\n      power();\n      multiply();\n      add();\n    }\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" remaining unfactored part of the polynomial: \" + polynomial.toString());\n    }\n    push(polynomial);\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    polynomial = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" new poly with extracted common factor: \" + polynomial.toString());\n    }\n    //debugger\n\n    // factor out negative sign\n    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {\n      push(polynomial);\n      //prev_expanding = expanding\n      //expanding = 1\n      negate();\n      //expanding = prev_expanding\n      polynomial = pop();\n      push(partOfPolynomialFactoredSoFar);\n      negate_noexpand();\n      partOfPolynomialFactoredSoFar = pop();\n    }\n    push(partOfPolynomialFactoredSoFar);\n    push(polynomial);\n    multiply_noexpand();\n    partOfPolynomialFactoredSoFar = pop();\n    if (DEBUG) {\n      console.log(\"yyfactorpoly: \" + firstParam + \" \" + secondParam + \" result: \" + partOfPolynomialFactoredSoFar);\n    }\n    stack[h] = partOfPolynomialFactoredSoFar;\n    moveTos(h + 1);\n    return restore();\n  };\n\n  rationalize_coefficients = function(h) {\n    var i, i1, o, ratio, ratioInverse, ref, ref1, ref2, ref3;\n    // LCM of all polynomial coefficients\n    ratio = one;\n    for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      push(stack[i]);\n      denominator();\n      push(ratio);\n      lcm();\n      ratio = pop();\n    }\n// multiply each coefficient by RESULT\n    for (i = i1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      push(ratio);\n      push(stack[i]);\n      multiply();\n      stack[i] = pop();\n    }\n    // reciprocate RESULT\n    push(ratio);\n    reciprocate();\n    ratioInverse = pop();\n    if (DEBUG) {\n      console.log(\"rationalize_coefficients result: \" + ratioInverse.toString());\n    }\n    return ratioInverse;\n  };\n\n  get_factor_from_real_root = function(variable, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, j1, l1, m1, na0, nan, o, polynomial, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j, testDenominator, testNumerator, testValue;\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root\");\n    }\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (DEBUG) {\n      push(zero);\n      for (i = o = 0, ref = factpoly_expo; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {\n        push(stack[polycoeff + i]);\n        push(variable);\n        push_integer(i);\n        power();\n        multiply();\n        add();\n      }\n      polynomial = pop();\n      console.log(\"POLY=\" + polynomial);\n    }\n    h = tos;\n    an = tos;\n    push(stack[polycoeff + factpoly_expo]);\n    divisors_onstack();\n    nan = tos - an;\n    a0 = tos;\n    push(stack[polycoeff + 0]);\n    divisors_onstack();\n    na0 = tos - a0;\n    if (DEBUG) {\n      console.log(\"divisors of base term\");\n      for (i = i1 = 0, ref1 = na0; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        console.log(\", \" + stack[a0 + i]);\n      }\n      console.log(\"divisors of leading term\");\n      for (i = j1 = 0, ref2 = nan; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        console.log(\", \" + stack[an + i]);\n      }\n    }\n// try roots\n    for (rootsTries_i = l1 = 0, ref3 = nan; (0 <= ref3 ? l1 < ref3 : l1 > ref3); rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {\n      for (rootsTries_j = m1 = 0, ref4 = na0; (0 <= ref4 ? m1 < ref4 : m1 > ref4); rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {\n        //if DEBUG then console.log \"nan: \" + nan + \" na0: \" + na0 + \" i: \" + rootsTries_i + \" j: \" + rootsTries_j\n        testNumerator = stack[an + rootsTries_i];\n        testDenominator = stack[a0 + rootsTries_j];\n        push(testDenominator);\n        push(testNumerator);\n        divide();\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n        push(testDenominator);\n        negate();\n        testDenominator = pop();\n        push(testValue);\n        negate();\n        testValue = pop();\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        if (DEBUG) {\n          console.log(\"try A=\" + testNumerator);\n          console.log(\", B=\" + testDenominator);\n          console.log(\", root \" + variable);\n          console.log(\"=-B/A=\" + testValue);\n          console.log(\", POLY(\" + testValue);\n          console.log(\")=\" + evalPolyResult);\n        }\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"get_factor_from_real_root returning 1\");\n          }\n          return [1, testNumerator, testDenominator];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_real_root returning\");\n    }\n    return [0, null, null];\n  };\n\n  get_factor_from_complex_root = function(remainingPoly, factpoly_expo, polycoeff) {\n    var a0, an, evalPolyResult, h, i, i1, j, na0, nan, o, rootsTries_i, rootsTries_j, testValue;\n    i = 0;\n    j = 0;\n    h = 0;\n    a0 = 0;\n    an = 0;\n    na0 = 0;\n    nan = 0;\n    if (factpoly_expo <= 2) {\n      if (DEBUG) {\n        console.log(\"no more factoring via complex roots to be found in polynomial of degree <= 2\");\n      }\n      return [0, null];\n    }\n    if (DEBUG) {\n      console.log(\"complex root finding for POLY=\" + remainingPoly);\n    }\n    h = tos;\n    an = tos;\n    // trying -1^(2/3) which generates a polynomial in Z\n    // generates x^2 + 2x + 1\n    push_integer(-1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n    // trying 1^(2/3) which generates a polynomial in Z\n    // http://www.wolframalpha.com/input/?i=(1)%5E(2%2F3)\n    // generates x^2 - 2x + 1\n    push_integer(1);\n    push_rational(2, 3);\n    power();\n    rect();\n    testValue = pop();\n    if (DEBUG) {\n      console.log(\"complex root finding: trying with \" + testValue);\n    }\n    push(testValue);\n    evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n    if (DEBUG) {\n      console.log(\"complex root finding result: \" + evalPolyResult);\n    }\n    if (isZeroAtomOrTensor(evalPolyResult)) {\n      moveTos(h);\n      if (DEBUG) {\n        console.log(\"get_factor_from_complex_root returning 1\");\n      }\n      return [1, testValue];\n    }\n// trying some simple complex numbers. All of these\n// generate polynomials in Z\n    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {\n      for (rootsTries_j = i1 = 1; i1 <= 5; rootsTries_j = ++i1) {\n        push_integer(rootsTries_i);\n        push_integer(rootsTries_j);\n        push(imaginaryunit);\n        multiply();\n        add();\n        rect();\n        testValue = pop();\n        if (DEBUG) {\n          console.log(\"complex root finding: trying simple complex combination \" + testValue);\n        }\n        push(testValue);\n        evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);\n        //console.log(\"complex root finding result: \" + evalPolyResult)\n        if (isZeroAtomOrTensor(evalPolyResult)) {\n          moveTos(h);\n          if (DEBUG) {\n            console.log(\"found complex root: \" + evalPolyResult);\n          }\n          return [1, testValue];\n        }\n      }\n    }\n    moveTos(h);\n    if (DEBUG) {\n      console.log(\"get_factor_from_complex_root returning 0\");\n    }\n    return [0, null];\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide a polynomial by Ax+B\n\n  //  Input:  on stack:  polycoeff  Dividend coefficients\n\n  //      factpoly_expo   as parameter\n\n  //      A    as parameter\n\n  //      B    as parameter\n\n  //  Output:   on stack: polycoeff  Contains quotient coefficients\n\n  //-----------------------------------------------------------------------------\n  yydivpoly = function(factpoly_expo, polycoeff, A, B) {\n    var Q, i, o, ref;\n    Q = zero;\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o < 0 : o > 0); i = ref <= 0 ? ++o : --o) {\n      push(stack[polycoeff + i]);\n      stack[polycoeff + i] = Q;\n      push(A);\n      divide();\n      Q = pop();\n      push(stack[polycoeff + i - 1]);\n      push(Q);\n      push(B);\n      multiply();\n      subtract();\n      stack[polycoeff + i - 1] = pop();\n    }\n    stack[polycoeff + 0] = Q;\n    if (DEBUG) {\n      return console.log(\"yydivpoly Q: \" + Q.toString());\n    }\n  };\n\n  Evalpoly = function(factpoly_expo, polycoeff, evaluateAt) {\n    var i, o, ref;\n    push(zero);\n    for (i = o = ref = factpoly_expo; (ref <= 0 ? o <= 0 : o >= 0); i = ref <= 0 ? ++o : --o) {\n      push(evaluateAt);\n      multiply();\n      push(stack[polycoeff + i]);\n      //if DEBUG\n      //  console.log(\"Evalpoly top of stack:\")\n      //  console.log stack[tos-i].toString()\n      add();\n    }\n    return pop();\n  };\n\n  // Push expression factors onto the stack. For example...\n\n  // Input\n\n  //       2\n  //     3x  + 2x + 1\n\n  // Output on stack\n\n  //     [  3  ]\n  //     [ x^2 ]\n  //     [  2  ]\n  //     [  x  ]\n  //     [  1  ]\n\n  // but not necessarily in that order. Returns the number of factors.\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  factors = function(p) {\n    var h;\n    h = tos;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        push_term_factors(car(p));\n        p = cdr(p);\n      }\n    } else {\n      push_term_factors(p);\n    }\n    return tos - h;\n  };\n\n  // Local U *p is OK here because no functional path to garbage collector.\n  push_term_factors = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        push(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return push(p);\n    }\n  };\n\n  Eval_filter = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      filter();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    filter_main();\n    return restore();\n  };\n\n  filter_main = function() {\n    if (car(p1) === symbol(ADD)) {\n      return filter_sum();\n    } else if (istensor(p1)) {\n      return filter_tensor();\n    } else if (Find(p1, p2)) {\n      return push_integer(0);\n    } else {\n      return push(p1);\n    }\n  };\n\n  filter_sum = function() {\n    var results;\n    push_integer(0);\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      filter();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  filter_tensor = function() {\n    var i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    n = p1.tensor.nelem;\n    p3 = alloc_tensor(n);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = o = 0, ref = p1.tensor.ndim; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      filter();\n      p3.tensor.elem[i] = pop();\n    }\n    return push(p3);\n  };\n\n  Eval_float = function() {\n    evaluatingAsFloats++;\n    push(cadr(p1));\n    Eval();\n    yyfloat();\n    Eval();\n    return evaluatingAsFloats--;\n  };\n\n  checkFloatHasWorkedOutCompletely = function(nodeToCheck) {\n    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;\n    numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);\n    numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);\n    numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);\n    numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);\n    numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);\n    if (DEBUG) {\n      console.log(\"     ... numberOfPowers: \" + numberOfPowers);\n      console.log(\"     ... numberOfPIs: \" + numberOfPIs);\n      console.log(\"     ... numberOfEs: \" + numberOfEs);\n      console.log(\"     ... numberOfMults: \" + numberOfMults);\n      console.log(\"     ... numberOfSums: \" + numberOfSums);\n    }\n    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {\n      return stop(\"float: some unevalued parts in \" + nodeToCheck);\n    }\n  };\n\n  zzfloat = function() {\n    save();\n    evaluatingAsFloats++;\n    //p1 = pop()\n    //push(cadr(p1))\n    //push(p1)\n    Eval();\n    yyfloat();\n    Eval();\n    evaluatingAsFloats--;\n    return restore();\n  };\n\n  // zzfloat doesn't necessarily result in a double\n  // , for example if there are variables. But\n  // in many of the tests there should be indeed\n  // a float, this line comes handy to highlight\n  // when that doesn't happen for those tests.\n  //checkFloatHasWorkedOutCompletely(stack[tos-1])\n  yyfloat = function() {\n    var h, i, o, ref;\n    i = 0;\n    h = 0;\n    evaluatingAsFloats++;\n    save();\n    p1 = pop();\n    if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        push(car(p1));\n        yyfloat();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else if (p1.k === TENSOR) {\n      push(p1);\n      copy_tensor();\n      p1 = pop();\n      for (i = o = 0, ref = p1.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n        push(p1.tensor.elem[i]);\n        yyfloat();\n        p1.tensor.elem[i] = pop();\n      }\n      push(p1);\n    } else if (p1.k === NUM) {\n      push(p1);\n      bignum_float();\n    } else if (p1 === symbol(PI)) {\n      push_double(Math.PI);\n    } else if (p1 === symbol(E)) {\n      push_double(Math.E);\n    } else {\n      push(p1);\n    }\n    restore();\n    return evaluatingAsFloats--;\n  };\n\n  Eval_floor = function() {\n    push(cadr(p1));\n    Eval();\n    return yfloor();\n  };\n\n  yfloor = function() {\n    save();\n    yyfloor();\n    return restore();\n  };\n\n  yyfloor = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(FLOOR);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.floor(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mdiv(p1.q.a, p1.q.b);\n    p3.q.b = mint(1);\n    push(p3);\n    if (isnegativenumber(p1)) {\n      push_integer(-1);\n      return add();\n    }\n  };\n\n  // 'for' function\n  /*\n  x=0\n  y=2\n  for(do(x=sqrt(2+x),y=2*y/x),k,1,9)\n  float(y)\n\n  X: k\n  B: 1...9\n\n  1st parameter is the body\n  2nd parameter is the variable to loop with\n  3rd and 4th are the limits\n\n  */\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n  Eval_for = function() {\n    var i, j, k, loopingVariable, o, ref, ref1;\n    i = 0;\n    j = 0;\n    k = 0;\n    loopingVariable = caddr(p1);\n    if (!issymbol(loopingVariable)) {\n      stop(\"for: 2nd arg should be the variable to loop over\");\n    }\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(loopingVariable);\n    for (i = o = ref = j, ref1 = k; (ref <= ref1 ? o <= ref1 : o >= ref1); i = ref <= ref1 ? ++o : --o) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(loopingVariable, p5);\n      push(cadr(p1));\n      Eval();\n      pop();\n    }\n    // put back the index variable to original content\n    set_binding(loopingVariable, p4);\n    // return value\n    return push_symbol(NIL);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  Gamma function gamma(x)\n\n  //-----------------------------------------------------------------------------\n  Eval_gamma = function() {\n    push(cadr(p1));\n    Eval();\n    return gamma();\n  };\n\n  gamma = function() {\n    save();\n    gammaf();\n    return restore();\n  };\n\n  gammaf = function() {\n    //  double d\n    p1 = pop();\n    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      return;\n    }\n    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_rational(1, 2);\n      power();\n      push_rational(1, 2);\n      multiply();\n      return;\n    }\n    \n    //  if (p1->k == DOUBLE) {\n    //    d = exp(lgamma(p1.d))\n    //    push_double(d)\n    //    return\n    //  }\n    if (isnegativeterm(p1)) {\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push_integer(-1);\n      multiply();\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      push(p1);\n      multiply();\n      sine();\n      push(p1);\n      multiply();\n      push(p1);\n      negate();\n      gamma();\n      multiply();\n      divide();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gamma_of_sum();\n      return;\n    }\n    push_symbol(GAMMA);\n    push(p1);\n    list(2);\n  };\n\n  gamma_of_sum = function() {\n    p3 = cdr(p1);\n    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {\n      push(cadr(p3));\n      push(cadr(p3));\n      gamma();\n      return multiply();\n    } else {\n      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {\n        push(cadr(p3));\n        gamma();\n        push(cadr(p3));\n        push_integer(-1);\n        add();\n        return divide();\n      } else {\n        push_symbol(GAMMA);\n        push(p1);\n        list(2);\n      }\n    }\n  };\n\n  // Greatest common denominator\n  // can also be run on polynomials, however\n  // it works only on the integers and it works\n  // by factoring the polynomials (not Euclidean algorithm)\n  Eval_gcd = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      gcd();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  gcd = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    gcd_main();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  gcd_main = function() {\n    var polyVar;\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    if (DEBUG) {\n      console.log(\"gcd_main: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (equal(p1, p2)) {\n      push(p1);\n      return;\n    }\n    if (isrational(p1) && isrational(p2)) {\n      push(p1);\n      push(p2);\n      gcd_numbers();\n      return;\n    }\n    if ((polyVar = areunivarpolysfactoredorexpandedform(p1, p2))) {\n      gcd_polys(polyVar);\n      return;\n    }\n    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {\n      gcd_sum_sum();\n      return;\n    }\n    if (car(p1) === symbol(ADD)) {\n      gcd_sum(p1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(ADD)) {\n      gcd_sum(p2);\n      p2 = pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      gcd_sum_product();\n      return;\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      gcd_product_sum();\n      return;\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    return gcd_powers_with_same_base();\n  };\n\n  areunivarpolysfactoredorexpandedform = function(p1, p2) {\n    var polyVar;\n    if (DEBUG) {\n      console.log(\"areunivarpolysfactoredorexpandedform: p1: \" + p1 + \" p2: \" + p2);\n    }\n    if (polyVar = isunivarpolyfactoredorexpandedform(p1)) {\n      if (isunivarpolyfactoredorexpandedform(p2, polyVar)) {\n        return polyVar;\n      }\n    }\n    return false;\n  };\n\n  gcd_polys = function(polyVar) {\n    if (DEBUG) {\n      console.log(\"gcd_polys: p1: \" + p1 + \" polyVar: \" + polyVar);\n    }\n    // gcd of factors\n    push(p1);\n    push(polyVar);\n    factorpoly();\n    p1 = pop();\n    push(p2);\n    push(polyVar);\n    factorpoly();\n    p2 = pop();\n    if (DEBUG) {\n      console.log(\"GCD: factored polys:\");\n    }\n    if (DEBUG) {\n      console.log(\"  p1:\" + p1.toString());\n    }\n    if (DEBUG) {\n      console.log(\"  p2:\" + p2.toString());\n    }\n    // In case one of two polynomials can be factored,\n    // (and only in that case), then\n    // we'll need to run gcd_factors on the two polynomials.\n    // (In case neither of them can be factored there is no gcd).\n    // However, gcd_factors expects two _products_ , and\n    // in case _one_ of the polynomials can't be factored it will look\n    // like a sum instead of a product.\n    // So, we'll have to make that sum to look like a factor:\n    // let's just turn it into a product with 1.\n\n    // in case one of the two polys has been factored...\n    if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {\n      // then make sure that if one of them is a single\n      // factor, we take the sum and wrap it into a\n      // multiplication by 1\n      if (car(p1) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push(one);\n        list(3);\n        p1 = pop();\n      }\n      if (car(p2) !== symbol(MULTIPLY)) {\n        push_symbol(MULTIPLY);\n        push(p2);\n        push(one);\n        list(3);\n        p2 = pop();\n      }\n    }\n    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {\n      gcd_product_product();\n      return;\n    }\n    gcd_powers_with_same_base();\n    return true;\n  };\n\n  gcd_product_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      p4 = cdr(p2);\n      while (iscons(p4)) {\n        push(car(p3));\n        push(car(p4));\n        gcd();\n        multiply();\n        p4 = cdr(p4);\n      }\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_powers_with_same_base = function() {\n    if (car(p1) === symbol(POWER)) {\n      p3 = caddr(p1); // exponent\n      p1 = cadr(p1); // base\n    } else {\n      p3 = one;\n    }\n    if (car(p2) === symbol(POWER)) {\n      p4 = caddr(p2); // exponent\n      p2 = cadr(p2); // base\n    } else {\n      p4 = one;\n    }\n    if (!equal(p1, p2)) {\n      push(one);\n      return;\n    }\n    // are both exponents numerical?\n    if (isNumericAtom(p3) && isNumericAtom(p4)) {\n      push(p1);\n      if (lessp(p3, p4)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    // are the exponents multiples of eah other?\n    push(p3);\n    push(p4);\n    divide();\n    p5 = pop();\n    if (isNumericAtom(p5)) {\n      push(p1);\n      // choose the smallest exponent\n      if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {\n        p5 = cadr(p3);\n      } else {\n        p5 = one;\n      }\n      if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {\n        p6 = cadr(p4);\n      } else {\n        p6 = one;\n      }\n      if (lessp(p5, p6)) {\n        push(p3);\n      } else {\n        push(p4);\n      }\n      power();\n      return;\n    }\n    push(p3);\n    push(p4);\n    subtract();\n    p5 = pop();\n    if (!isNumericAtom(p5)) {\n      push(one);\n      return;\n    }\n    // can't be equal because of test near beginning\n    push(p1);\n    if (isnegativenumber(p5)) {\n      push(p3);\n    } else {\n      push(p4);\n    }\n    return power();\n  };\n\n  // in this case gcd is used as a composite function, i.e. gcd(gcd(gcd...\n  gcd_sum_sum = function() {\n    if (length(p1) !== length(p2)) {\n      push(one);\n      return;\n    }\n    p3 = cdr(p1);\n    push(car(p3));\n    p3 = cdr(p3);\n    while (iscons(p3)) {\n      push(car(p3));\n      gcd();\n      p3 = cdr(p3);\n    }\n    p3 = pop();\n    p4 = cdr(p2);\n    push(car(p4));\n    p4 = cdr(p4);\n    while (iscons(p4)) {\n      push(car(p4));\n      gcd();\n      p4 = cdr(p4);\n    }\n    p4 = pop();\n    push(p1);\n    push(p3);\n    divide();\n    p5 = pop();\n    push(p2);\n    push(p4);\n    divide();\n    p6 = pop();\n    if (equal(p5, p6)) {\n      push(p5);\n      push(p3);\n      push(p4);\n      gcd();\n      return multiply();\n    } else {\n      return push(one);\n    }\n  };\n\n  gcd_sum = function(p) {\n    var results;\n    p = cdr(p);\n    push(car(p));\n    p = cdr(p);\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      gcd();\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  gcd_sum_product = function() {\n    var results;\n    push(one);\n    p3 = cdr(p1);\n    results = [];\n    while (iscons(p3)) {\n      push(car(p3));\n      push(p2);\n      gcd();\n      multiply();\n      results.push(p3 = cdr(p3));\n    }\n    return results;\n  };\n\n  gcd_product_sum = function() {\n    var results;\n    push(one);\n    p4 = cdr(p2);\n    results = [];\n    while (iscons(p4)) {\n      push(p1);\n      push(car(p4));\n      gcd();\n      multiply();\n      results.push(p4 = cdr(p4));\n    }\n    return results;\n  };\n\n  // Guess which symbol to use for derivative, integral, etc.\n  guess = function() {\n    var p;\n    p = pop();\n    push(p);\n    if (Find(p, symbol(SYMBOL_X))) {\n      return push_symbol(SYMBOL_X);\n    } else if (Find(p, symbol(SYMBOL_Y))) {\n      return push_symbol(SYMBOL_Y);\n    } else if (Find(p, symbol(SYMBOL_Z))) {\n      return push_symbol(SYMBOL_Z);\n    } else if (Find(p, symbol(SYMBOL_T))) {\n      return push_symbol(SYMBOL_T);\n    } else if (Find(p, symbol(SYMBOL_S))) {\n      return push_symbol(SYMBOL_S);\n    } else {\n      return push_symbol(SYMBOL_X);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Hermite polynomial\n\n  //  Input:    tos-2    x  (can be a symbol or expr)\n\n  //      tos-1    n\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  hermite = function() {\n    save();\n    yyhermite();\n    return restore();\n  };\n\n  // uses the recurrence relation H(x,n+1)=2*x*H(x,n)-2*n*H(x,n-1)\n\n  //define X p1\n  //define N p2\n  //define Y p3\n  //define Y1 p4\n  //define Y0 p5\n  yyhermite = function() {\n    var n;\n    n = 0;\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(HERMITE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (issymbol(p1)) {\n      return yyhermite2(n);\n    } else {\n      p3 = p1;\n      p1 = symbol(SECRETX);\n      yyhermite2(n);\n      p1 = p3;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      return Eval();\n    }\n  };\n\n  yyhermite2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p4 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p4;\n      p4 = pop();\n      push(p1);\n      push(p4);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(2);\n      results.push(multiply());\n    }\n    return results;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Create a Hilbert matrix\n\n  //  Input:    Dimension on stack\n\n  //  Output:    Hilbert matrix on stack\n\n  //  Example:\n\n  //  > hilbert(5)\n  //  ((1,1/2,1/3,1/4),(1/2,1/3,1/4,1/5),(1/3,1/4,1/5,1/6),(1/4,1/5,1/6,1/7))\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define N p2\n\n  //define AELEM(i, j) A->u.tensor->elem[i * n + j]\n  hilbert = function() {\n    var i, i1, j, n, o, ref, ref1;\n    i = 0;\n    j = 0;\n    n = 0;\n    save();\n    p2 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 2) {\n      push_symbol(HILBERT);\n      push(p2);\n      list(2);\n      restore();\n      return;\n    }\n    push_zero_matrix(n, n);\n    p1 = pop();\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        push_integer(i + j + 1);\n        inverse();\n        p1.tensor.elem[i * n + j] = pop();\n      }\n    }\n    push(p1);\n    return restore();\n  };\n\n  DEBUG_IMAG = false;\n\n  Eval_imag = function() {\n    push(cadr(p1));\n    Eval();\n    return imag();\n  };\n\n  imag = function() {\n    save();\n    rect();\n    p1 = pop();\n    if (DEBUG_IMAG) {\n      console.log(\"IMAGE of \" + p1);\n    }\n    push(p1);\n    push(p1);\n    conjugate();\n    if (DEBUG_IMAG) {\n      console.log(\" image: conjugate result: \" + stack[tos - 1]);\n    }\n    subtract();\n    push_integer(2);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 1st divide result: \" + stack[tos - 1]);\n    }\n    push(imaginaryunit);\n    divide();\n    if (DEBUG_IMAG) {\n      console.log(\" image: 2nd divide result: \" + stack[tos - 1]);\n    }\n    return restore();\n  };\n\n  // n is the total number of things on the stack. The first thing on the stack\n  // is the object to be indexed, followed by the indices themselves.\n\n  // called by Eval_index\n  index_function = function(n) {\n    var i, i1, j1, k, l1, m, m1, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    save();\n    s = tos - n;\n    p1 = stack[s];\n    ndim = p1.tensor.ndim;\n    m = n - 1;\n    if (m > ndim) {\n      stop(\"too many indices for tensor\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 1]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"index out of range\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    if (ndim === m) {\n      moveTos(tos - n);\n      push(p1.tensor.elem[k]);\n      restore();\n      return;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    nelem = 1;\n    for (i = j1 = ref3 = m, ref4 = ndim; (ref3 <= ref4 ? j1 < ref4 : j1 > ref4); i = ref3 <= ref4 ? ++j1 : --j1) {\n      nelem *= p1.tensor.dim[i];\n    }\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim - m;\n    for (i = l1 = ref5 = m, ref6 = ndim; (ref5 <= ref6 ? l1 < ref6 : l1 > ref6); i = ref5 <= ref6 ? ++l1 : --l1) {\n      p2.tensor.dim[i - m] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref7 = nelem; (0 <= ref7 ? m1 < ref7 : m1 > ref7); i = 0 <= ref7 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[k + i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n    Number of args on stack\n\n  //      tos-n    Right-hand value\n\n  //      tos-n+1    Left-hand value\n\n  //      tos-n+2    First index\n\n  //      .\n  //      .\n  //      .\n\n  //      tos-1    Last index\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define LVALUE p1\n  //define RVALUE p2\n  //define TMP p3\n  set_component = function(n) {\n    var i, i1, j1, k, l1, m, m1, n1, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;\n    i = 0;\n    k = 0;\n    m = 0;\n    ndim = 0;\n    t = 0;\n    save();\n    if (n < 3) {\n      stop(\"error in indexed assign\");\n    }\n    s = tos - n;\n    p2 = stack[s];\n    p1 = stack[s + 1];\n    if (!istensor(p1)) { // p1 is LVALUE\n      stop(\"error in indexed assign: assigning to something that is not a tensor\");\n    }\n    ndim = p1.tensor.ndim;\n    m = n - 2;\n    if (m > ndim) {\n      stop(\"error in indexed assign\");\n    }\n    k = 0;\n    for (i = o = 0, ref = m; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      push(stack[s + i + 2]);\n      t = pop_integer();\n      if (t < 1 || t > p1.tensor.dim[i]) {\n        stop(\"error in indexed assign\\n\");\n      }\n      k = k * p1.tensor.dim[i] + t - 1;\n    }\n    for (i = i1 = ref1 = m, ref2 = ndim; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n      k = k * p1.tensor.dim[i] + 0;\n    }\n    // copy\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = j1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? j1 < ref3 : j1 > ref3); i = 0 <= ref3 ? ++j1 : --j1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = l1 = 0, ref4 = p1.tensor.nelem; (0 <= ref4 ? l1 < ref4 : l1 > ref4); i = 0 <= ref4 ? ++l1 : --l1) {\n      p3.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p3);\n    p1 = p3;\n    if (ndim === m) {\n      if (istensor(p2)) { // p2 is RVALUE\n        stop(\"error in indexed assign\");\n      }\n      p1.tensor.elem[k] = p2;\n      check_tensor_dimensions(p1);\n      moveTos(tos - n);\n      push(p1);\n      restore();\n      return;\n    }\n    if (!istensor(p2)) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n    if (ndim - m !== p2.tensor.ndim) { // p2 is RVALUE\n      stop(\"error in indexed assign\");\n    }\n// p2 is RVALUE\n    for (i = m1 = 0, ref5 = p2.tensor.ndim; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {\n        stop(\"error in indexed assign\");\n      }\n    }\n// p2 is RVALUE\n// copy rvalue\n    for (i = n1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? n1 < ref6 : n1 > ref6); i = 0 <= ref6 ? ++n1 : --n1) {\n      p1.tensor.elem[k + i] = p2.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p1);\n    return restore();\n  };\n\n  Eval_inner = function() {\n    var difference, i, i1, j1, l1, moretheArguments, o, operands, ref, ref1, ref2, ref3, refinedOperands, results, secondArgument, shift, theArguments;\n    \n    // if there are more than two arguments then\n    // reduce it to a more standard version\n    // of two arguments, which means we need to\n    // transform the arguments into a tree of\n    // inner products e.g.\n    // inner(a,b,c) becomes inner(a,inner(b,c))\n    // this is so we can get to a standard binary-tree\n    // version that is simpler to manipulate.\n    theArguments = [];\n    theArguments.push(car(cdr(p1)));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    moretheArguments = cdr(cdr(p1));\n    while (moretheArguments !== symbol(NIL)) {\n      theArguments.push(car(moretheArguments));\n      moretheArguments = cdr(moretheArguments);\n    }\n    // make it so e.g. inner(a,b,c) becomes inner(a,inner(b,c))\n    if (theArguments.length > 2) {\n      push_symbol(INNER);\n      push(theArguments[theArguments.length - 2]);\n      push(theArguments[theArguments.length - 1]);\n      list(3);\n      for (i = o = 2, ref = theArguments.length; (2 <= ref ? o < ref : o > ref); i = 2 <= ref ? ++o : --o) {\n        push_symbol(INNER);\n        swap();\n        push(theArguments[theArguments.length - i - 1]);\n        swap();\n        list(3);\n      }\n      p1 = pop();\n      Eval_inner();\n      return;\n    }\n    // TODO we have to take a look at the whole\n    // sequence of operands and make simplifications\n    // on that...\n    operands = [];\n    get_innerprod_factors(p1, operands);\n    //console.log \"printing operands --------\"\n    //for i in [0...operands.length]\n    //  console.log \"operand \" + i + \" : \" + operands[i]\n    refinedOperands = [];\n// removing all identity matrices\n    for (i = i1 = 0, ref1 = operands.length; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      if (operands[i] === symbol(SYMBOL_IDENTITY_MATRIX)) {\n        continue;\n      } else {\n        refinedOperands.push(operands[i]);\n      }\n    }\n    operands = refinedOperands;\n    refinedOperands = [];\n    if (operands.length > 1) {\n      // removing all consecutive pairs of inverses\n      // so we can answer that inv(a)a results in the\n      // identity matrix. We want to catch symbolic inverses\n      // not numeric inverses, those will just take care\n      // of themselves when multiplied\n      shift = 0;\n      for (i = j1 = 0, ref2 = operands.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        //console.log \"comparing if \" + operands[i+shift] + \" and \" + operands[i+shift+1] + \" are inverses of each other\"\n        if ((i + shift + 1) <= (operands.length - 1)) {\n          if (!(isNumericAtomOrTensor(operands[i + shift]) || isNumericAtomOrTensor(operands[i + shift + 1]))) {\n            push(operands[i + shift]);\n            Eval();\n            inv();\n            push(operands[i + shift + 1]);\n            Eval();\n            subtract();\n            difference = pop();\n            //console.log \"result: \" + difference\n            if (isZeroAtomOrTensor(difference)) {\n              shift += 1;\n            } else {\n              refinedOperands.push(operands[i + shift]);\n            }\n          } else {\n            refinedOperands.push(operands[i + shift]);\n          }\n        } else {\n          break;\n        }\n        //console.log \"i: \" + i + \" shift: \" + shift + \" operands.length: \" + operands.length\n        if (i + shift === operands.length - 2) {\n          //console.log \"adding last operand 2 \"\n          refinedOperands.push(operands[operands.length - 1]);\n        }\n        if (i + shift >= operands.length - 1) {\n          break;\n        }\n      }\n      operands = refinedOperands;\n    }\n    //console.log \"refined operands --------\"\n    //for i in [0...refinedOperands.length]\n    //  console.log \"refined operand \" + i + \" : \" + refinedOperands[i]\n\n    //console.log \"stack[tos-1]: \" + stack[tos-1]\n\n    // now rebuild the arguments, just using the\n    // refined operands\n    push(symbol(INNER));\n    //console.log \"rebuilding the argument ----\"\n    if (operands.length > 0) {\n      for (i = l1 = 0, ref3 = operands.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        //console.log \"pushing \" + operands[i]\n        push(operands[i]);\n      }\n    } else {\n      pop();\n      push(symbol(SYMBOL_IDENTITY_MATRIX));\n      return;\n    }\n    //console.log \"list(operands.length): \" + (operands.length+1)\n    list(operands.length + 1);\n    p1 = pop();\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      inner();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // inner definition\n  inner = function() {\n    var arg1, arg2, arg3, subtractionResult;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // more in general, when a and b are scalars,\n    // inner(a*M1, b*M2) is equal to\n    // a*b*inner(M1,M2), but of course we can only\n    // \"bring out\" in a and b the scalars, because\n    // it's the only commutative part.\n    // that's going to be trickier to do in general\n    // but let's start with just the signs.\n    if (isnegativeterm(p2) && isnegativeterm(p1)) {\n      push(p2);\n      negate();\n      p2 = pop();\n      push(p1);\n      negate();\n      p1 = pop();\n    }\n    // since inner is associative,\n    // put it in a canonical form i.e.\n    // inner(inner(a,b),c) ->\n    // inner(a,inner(b,c))\n    // so that we can recognise when they\n    // are equal.\n    if (isinnerordot(p1)) {\n      arg1 = car(cdr(p1)); //a\n      arg2 = car(cdr(cdr(p1))); //b\n      arg3 = p2;\n      p1 = arg1;\n      push(arg2);\n      push(arg3);\n      inner();\n      p2 = pop();\n    }\n    // Check if one of the operands is the identity matrix\n    // we could maybe use Eval_testeq here but\n    // this seems to suffice?\n    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p2);\n      restore();\n      return;\n    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      inner_f();\n    } else {\n      if (!(isNumericAtomOrTensor(p1) || isNumericAtomOrTensor(p2))) {\n        push(p1);\n        push(p2);\n        inv();\n        subtract();\n        subtractionResult = pop();\n        if (isZeroAtomOrTensor(subtractionResult)) {\n          push_symbol(SYMBOL_IDENTITY_MATRIX);\n          restore();\n          return;\n        }\n      }\n      // if either operand is a sum then distribute\n      // (if we are in expanding mode)\n      if (expanding && isadd(p1)) {\n        p1 = cdr(p1);\n        push(zero);\n        while (iscons(p1)) {\n          push(car(p1));\n          push(p2);\n          inner();\n          add();\n          p1 = cdr(p1);\n        }\n        restore();\n        return;\n      }\n      if (expanding && isadd(p2)) {\n        p2 = cdr(p2);\n        push(zero);\n        while (iscons(p2)) {\n          push(p1);\n          push(car(p2));\n          inner();\n          add();\n          p2 = cdr(p2);\n        }\n        restore();\n        return;\n      }\n      push(p1);\n      push(p2);\n      // there are 8 remaining cases here, since each of the\n      // two arguments can only be a scalar/tensor/unknown\n      // and the tensor - tensor case was caught\n      // upper in the code\n      if (istensor(p1) && isNumericAtom(p2)) {\n        // one case covered by this branch:\n        //   tensor - scalar\n        tensor_times_scalar();\n      } else if (isNumericAtom(p1) && istensor(p2)) {\n        // one case covered by this branch:\n        //   scalar - tensor\n        scalar_times_tensor();\n      } else {\n        if (isNumericAtom(p1) || isNumericAtom(p2)) {\n          // three cases covered by this branch:\n          //   unknown - scalar\n          //   scalar - unknown\n          //   scalar  - scalar\n          // in these cases a normal multiplication\n          // will be OK\n          multiply();\n        } else {\n          // three cases covered by this branch:\n          //   unknown - unknown\n          //   unknown - tensor\n          //   tensor  - unknown\n          // in this case we can't use normal\n          // multiplication.\n          pop();\n          pop();\n          push_symbol(INNER);\n          push(p1);\n          push(p2);\n          list(3);\n          restore();\n          return;\n        }\n      }\n    }\n    return restore();\n  };\n\n  // inner product of tensors p1 and p2\n  inner_f = function() {\n    var a, ak, b, bk, c, i, i1, j, j1, k, l1, m1, n, n1, ndim, o, o1, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    n = p1.tensor.dim[p1.tensor.ndim - 1];\n    if (n !== p2.tensor.dim[0]) {\n      debugger;\n      stop(\"inner: tensor dimension check\");\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;\n    if (ndim > MAXDIM) {\n      stop(\"inner: rank of result exceeds maximum\");\n    }\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    //---------------------------------------------------------------------\n\n    //  ak is the number of rows in tensor A\n\n    //  bk is the number of columns in tensor B\n\n    //  Example:\n\n    //  A[3][3][4] B[4][4][3]\n\n    //    3  3        ak = 3 * 3 = 9\n\n    //                  4  3    bk = 4 * 3 = 12\n\n    //---------------------------------------------------------------------\n    ak = 1;\n    for (i = o = 0, ref = p1.tensor.ndim - 1; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      ak *= p1.tensor.dim[i];\n    }\n    bk = 1;\n    for (i = i1 = 1, ref1 = p2.tensor.ndim; (1 <= ref1 ? i1 < ref1 : i1 > ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      bk *= p2.tensor.dim[i];\n    }\n    p3 = alloc_tensor(ak * bk);\n    c = p3.tensor.elem;\n// new method copied from ginac http://www.ginac.de/\n    for (i = j1 = 0, ref2 = ak; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      for (j = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n        if (isZeroAtomOrTensor(a[i * n + j])) {\n          continue;\n        }\n        for (k = m1 = 0, ref4 = bk; (0 <= ref4 ? m1 < ref4 : m1 > ref4); k = 0 <= ref4 ? ++m1 : --m1) {\n          push(a[i * n + j]);\n          push(b[j * bk + k]);\n          multiply();\n          push(c[i * bk + k]);\n          add();\n          c[i * bk + k] = pop();\n        }\n      }\n    }\n    //---------------------------------------------------------------------\n\n    //  Note on understanding \"k * bk + j\"\n\n    //  k * bk because each element of a column is bk locations apart\n\n    //  + j because the beginnings of all columns are in the first bk \n    //  locations\n\n    //  Example: n = 2, bk = 6\n\n    //  b111  <- 1st element of 1st column\n    //  b112  <- 1st element of 2nd column\n    //  b113  <- 1st element of 3rd column\n    //  b121  <- 1st element of 4th column\n    //  b122  <- 1st element of 5th column\n    //  b123  <- 1st element of 6th column\n\n    //  b211  <- 2nd element of 1st column\n    //  b212  <- 2nd element of 2nd column\n    //  b213  <- 2nd element of 3rd column\n    //  b221  <- 2nd element of 4th column\n    //  b222  <- 2nd element of 5th column\n    //  b223  <- 2nd element of 6th column\n\n    //---------------------------------------------------------------------\n    if (ndim === 0) {\n      return push(p3.tensor.elem[0]);\n    } else {\n      p3.tensor.ndim = ndim;\n      j = 0;\n      for (i = n1 = 0, ref5 = p1.tensor.ndim - 1; (0 <= ref5 ? n1 < ref5 : n1 > ref5); i = 0 <= ref5 ? ++n1 : --n1) {\n        p3.tensor.dim[i] = p1.tensor.dim[i];\n      }\n      j = p1.tensor.ndim - 1;\n      for (i = o1 = 0, ref6 = p2.tensor.ndim - 1; (0 <= ref6 ? o1 < ref6 : o1 > ref6); i = 0 <= ref6 ? ++o1 : --o1) {\n        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];\n      }\n      return push(p3);\n    }\n  };\n\n  // Algebrite.run('c(b+a)inv((a+b))d').toString();\n  // Algebrite.run('c*(b+a)inv((a+b))d').toString();\n  // Algebrite.run('(c(b+a))(inv((a+b))d)').toString();\n  get_innerprod_factors = function(tree, factors_accumulator) {\n    if (!iscons(tree)) {\n      add_factor_to_accumulator(tree, factors_accumulator);\n      return;\n    }\n    if (cdr(tree) === symbol(NIL)) {\n      tree = get_innerprod_factors(car(tree), factors_accumulator);\n      return;\n    }\n    if (isinnerordot(tree)) {\n      // console.log \"there is inner at top, recursing on the operands\"\n      get_innerprod_factors(car(cdr(tree)), factors_accumulator);\n      get_innerprod_factors(cdr(cdr(tree)), factors_accumulator);\n      return;\n    }\n    return add_factor_to_accumulator(tree, factors_accumulator);\n  };\n\n  add_factor_to_accumulator = function(tree, factors_accumulator) {\n    if (tree !== symbol(NIL)) {\n      // console.log \">> adding to factors_accumulator: \" + tree\n      return factors_accumulator.push(tree);\n    }\n  };\n\n  itab = [\n    // 1\n    \"f(a,a*x)\",\n    // 9 (need a caveat for 7 so we can put 9 after 7)\n    \"f(1/x,log(x))\",\n    // 7\n    \"f(x^a,x^(a+1)/(a+1))\",\n    // five specialisations of case 7 for speed.\n    // Covers often-occurring exponents: each of\n    // these case ends up in a dedicated entry, so we\n    // only have to do one sure-shot match.\n    \"f(x^(-2),-x^(-1))\",\n    \"f(x^(-1/2),2*x^(1/2))\",\n    \"f(x^(1/2),2/3*x^(3/2))\",\n    \"f(x,x^2/2)\",\n    \"f(x^2,x^3/3)\",\n    // 12\n    \"f(exp(a*x),1/a*exp(a*x))\",\n    \"f(exp(a*x+b),1/a*exp(a*x+b))\",\n    \"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\",\n    \"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\",\n    // 14\n    \"f(log(a*x),x*log(a*x)-x)\",\n    // 15\n    \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\",\n    // 16\n    \"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\",\n    // 17\n    \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\",\n    // 19\n    \"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\",\n    // 20\n    \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\",\n    // 27\n    \"f(1/(a+b*x),1/b*log(a+b*x))\",\n    // 28\n    \"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\",\n    // 29\n    \"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\",\n    // 30\n    \"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\",\n    // 31\n    \"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\",\n    // 33\n    \"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\",\n    // 34\n    \"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\",\n    // 35\n    \"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\",\n    // 37\n    \"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\",\n    // 38\n    \"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\",\n    // 39\n    \"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\",\n    // 40\n    \"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\",\n    // 41\n    \"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\",\n    // 42\n    \"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\",\n    // 60\n    \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\",\n    // 61\n    \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\",\n    // 62 is the same as 60\n    // 63\n    \"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\",\n    //64\n    \"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\",\n    //65\n    \"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\",\n    //66 is covered by 61\n    //70\n    \"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\",\n    //71\n    \"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\",\n    //74\n    \"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\",\n    //76\n    \"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\",\n    // float(defint(1/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //77\n    //\"f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //78\n    //\"f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //79\n    \"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\",\n    //80\n    \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\",\n    // float(defint(X^2/(2+3*X^4),X,0,pi)) gave wrong result.\n    // Also, the tests related to the indefinite integral\n    // fail since we rationalise expressions \"better\", so I'm thinking\n    // to take this out completely as it seemed to give the\n    // wrong results in the first place.\n    //81\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))\",\n    //82\n    //\"f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))\",\n    //83\n    \"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\",\n    //124\n    \"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\",\n    //125\n    \"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\",\n    //126\n    \"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\",\n    //128\n    \"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //129\n    \"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\",\n    //131\n    \"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\",\n    //132\n    \"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\",\n    //133\n    \"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\",\n    //135\n    \"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\",\n    //136\n    \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\",\n    //137\n    \"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\",\n    //156\n    \"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\",\n    //157\n    \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\",\n    //158\n    \"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\",\n    //159\n    \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //160\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\",\n    //161\n    \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\",\n    //162\n    \"f(x/sqrt(x^2+a),sqrt(x^2+a))\",\n    //163\n    \"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\",\n    //164 need an unexpanded version?\n    \"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\",\n    // match doesn't work for the following\n    \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\",\n    //165\n    \"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\",\n    //166\n    \"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\",\n    //167\n    \"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\",\n    //168\n    \"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\",\n    //169\n    \"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\",\n    //170\n    \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\",\n    //171\n    \"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\",\n    //172\n    \"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\",\n    //173\n    \"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\",\n    //174\n    \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\",\n    //175\n    \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\",\n    //176+\n    \"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\",\n    //176-\n    \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\",\n    //177+\n    \"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\",\n    //177-\n    \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\",\n    //196\n    \"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\",\n    //197\n    \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\",\n    //200+\n    \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\",\n    //201    (seems to be handled somewhere else)\n    //202\n    \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //203\n    \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\",\n    //204\n    \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\",\n    //205\n    \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\",\n    //210\n    \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\",\n    //211\n    \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\",\n    //214\n    \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //215\n    \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\",\n    //216\n    \"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\",\n    //217\n    \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\",\n    //218\n    \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\",\n    // 273\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\",\n    // 274\n    \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\",\n    // 290\n    \"f(sin(a*x),-cos(a*x)/a)\",\n    // 291\n    \"f(cos(a*x),sin(a*x)/a)\",\n    // 292\n    \"f(tan(a*x),-log(cos(a*x))/a)\",\n    // 293\n    \"f(1/tan(a*x),log(sin(a*x))/a)\",\n    // 294\n    \"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\",\n    // 295\n    \"f(1/sin(a*x),log(tan(a*x/2))/a)\",\n    // 296\n    \"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\",\n    // 297\n    \"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\",\n    // 298\n    \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 302\n    \"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\",\n    // 303\n    \"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\",\n    // 304\n    \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\",\n    // 308\n    \"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\",\n    // 312\n    \"f(1/cos(a*x)^2,tan(a*x)/a)\",\n    // 318\n    \"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\",\n    // 320\n    \"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\",\n    // 326\n    \"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\",\n    // 327\n    \"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\",\n    // 328\n    \"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\",\n    // 329\n    \"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\",\n    // 330\n    \"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\",\n    // 331\n    \"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\",\n    // 333\n    \"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\",\n    // 335\n    \"f(sin(a+b*x),-cos(a+b*x)/b)\",\n    // 336\n    \"f(cos(a+b*x),sin(a+b*x)/b)\",\n    // 337+ (with the addition of b)\n    \"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\",\n    // 337- (with the addition of b)\n    \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\",\n    // 338 (with the addition of b)\n    \"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\",\n    // 339 (with the addition of b)\n    \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\",\n    // 340\n    \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 341\n    \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\", // check that b^2-a^2 is not zero\n    // 389\n    \"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\",\n    // 390\n    \"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\",\n    // 393\n    \"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\",\n    // 394\n    \"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\",\n    // 441\n    \"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\",\n    // 442\n    \"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\",\n    // 443\n    \"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\",\n    // 485 (with addition of a)\n    // however commenting out since it's a duplicate of 14\n    // \"f(log(a*x),x*log(a*x)-x)\",\n    // 486 (with addition of a)\n    \"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\",\n    // 487 (with addition of a)\n    \"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\",\n    // 489\n    \"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\",\n    // 493 (with addition of a)\n    \"f(1/x*1/(a+log(x)),log(a+log(x)))\",\n    // 499\n    \"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\",\n    // 500\n    \"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\",\n    // 554\n    \"f(sinh(x),cosh(x))\",\n    // 555\n    \"f(cosh(x),sinh(x))\",\n    // 556\n    \"f(tanh(x),log(cosh(x)))\",\n    // 560\n    \"f(x*sinh(x),x*cosh(x)-sinh(x))\",\n    // 562\n    \"f(x*cosh(x),x*sinh(x)-cosh(x))\",\n    // 566\n    \"f(sinh(x)^2,sinh(2*x)/4-x/2)\",\n    // 569\n    \"f(tanh(x)^2,x-tanh(x))\",\n    // 572\n    \"f(cosh(x)^2,sinh(2*x)/4+x/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\",\n    // ?\n    \"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\",\n    // ?\n    \"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\",\n    // these are needed for the surface integral in the manual\n    \"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\",\n    \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\",\n    \"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\",\n    \"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\",\n    \"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\",\n    \"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\",\n    \"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\",\n    \"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\",\n    0\n  ];\n\n  //define F p3\n  //define X p4\n  //define N p5\n  Eval_integral = function() {\n    var doNothing, i, i1, n, o, ref, ref1;\n    i = 0;\n    n = 0;\n    // evaluate 1st arg to get function F\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // evaluate 2nd arg and then...\n\n    // example    result of 2nd arg  what to do\n\n    // integral(f)    nil      guess X, N = nil\n    // integral(f,2)  2      guess X, N = 2\n    // integral(f,x)  x      X = x, N = nil\n    // integral(f,x,2)  x      X = x, N = 2\n    // integral(f,x,y)  x      X = x, N = y\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n      push(symbol(NIL));\n    } else if (isNumericAtom(p2)) {\n      guess();\n      push(p2);\n    } else {\n      push(p2);\n      p1 = cdr(p1);\n      push(car(p1));\n      Eval();\n    }\n    p5 = pop();\n    p4 = pop();\n    p3 = pop();\n    while (1) {\n      // N might be a symbol instead of a number\n      if (isNumericAtom(p5)) {\n        push(p5);\n        n = pop_integer();\n        if (isNaN(n)) {\n          stop(\"nth integral: check n\");\n        }\n      } else {\n        n = 1;\n      }\n      push(p3);\n      if (n >= 0) {\n        for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n          push(p4);\n          integral();\n        }\n      } else {\n        n = -n;\n        for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n          push(p4);\n          derivative();\n        }\n      }\n      p3 = pop();\n      // if N is nil then arglist is exhausted\n      if (p5 === symbol(NIL)) {\n        break;\n      }\n      // otherwise...\n\n      // N    arg1    what to do\n\n      // number  nil    break\n      // number  number    N = arg1, continue\n      // number  symbol    X = arg1, N = arg2, continue\n\n      // symbol  nil    X = N, N = nil, continue\n      // symbol  number    X = N, N = arg1, continue\n      // symbol  symbol    X = N, N = arg1, continue\n      if (isNumericAtom(p5)) {\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop();\n        if (p5 === symbol(NIL)) {\n          break; // arglist exhausted\n        }\n        if (isNumericAtom(p5)) {\n          doNothing = 1; // N = arg1\n        } else {\n          p4 = p5;\n          p1 = cdr(p1);\n          push(car(p1));\n          Eval();\n          p5 = pop(); // N = arg2\n        }\n      } else {\n        p4 = p5;\n        p1 = cdr(p1);\n        push(car(p1));\n        Eval();\n        p5 = pop(); // N = arg1\n      }\n    }\n    return push(p3); // final result\n  };\n\n  integral = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      integral_of_sum();\n    } else if (car(p1) === symbol(MULTIPLY)) {\n      integral_of_product();\n    } else {\n      integral_of_form();\n    }\n    p1 = pop();\n    if (Find(p1, symbol(INTEGRAL))) {\n      stop(\"integral: sorry, could not find a solution\");\n    }\n    push(p1);\n    simplify();\n    Eval();\n    return restore();\n  };\n\n  integral_of_sum = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    push(p2);\n    integral();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      push(p2);\n      integral();\n      add();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  integral_of_product = function() {\n    push(p1);\n    push(p2);\n    partition();\n    p1 = pop();\n    integral_of_form();\n    return multiply(); // multiply constant part\n  };\n\n  integral_of_form = function() {\n    var hc, tab;\n    hc = italu_hashcode(p1, p2).toFixed(6);\n    tab = hashed_itab[hc];\n    if (!tab) {\n      // debugger\n      // italu_hashcode(p1, p2)\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p1); // free variable\n    push(p2); // input expression\n    transform(tab, false);\n    p3 = pop();\n    if (p3 === symbol(NIL)) {\n      push_symbol(INTEGRAL);\n      push(p1);\n      push(p2);\n      return list(3);\n    } else {\n      return push(p3);\n    }\n  };\n\n  // Implementation of hash codes based on ITALU (An Integral Table Look-Up)\n  // https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680004891.pdf\n  // see Appendix A, page 153\n\n  // The first two values are from the ITALU paper.\n  // The others are just arbitrary constants.\n  hashcode_values = {\n    'x': 0.95532,\n    'constexp': 1.43762,\n    'constant': 1.14416593629414332,\n    'constbase': 1.20364122304218824,\n    'sin': 1.73305482518303221,\n    'arcsin': 1.6483368529465804,\n    'cos': 1.058672123686340116,\n    'arccos': 1.8405225918106694,\n    'tan': 1.12249437762925064,\n    'arctan': 1.1297397925394962,\n    'sinh': 1.8176164926060078,\n    'cosh': 1.9404934661708022,\n    'tanh': 1.6421307715103121,\n    'log': 1.47744370135492387,\n    'erf': 1.0825269225702916\n  };\n\n  italu_hashcode = function(u, x) {\n    var half;\n    if (issymbol(u)) {\n      if (equal(u, x)) {\n        return hashcode_values.x;\n      } else {\n        return hashcode_values.constant;\n      }\n    } else if (iscons(u)) {\n      switch (symnum(car(u))) {\n        case ADD:\n          return hash_addition(cdr(u), x);\n        case MULTIPLY:\n          return hash_multiplication(cdr(u), x);\n        case POWER:\n          return hash_power(cadr(u), caddr(u), x);\n        case EXP:\n          return hash_power(symbol(E), cadr(u), x);\n        case SQRT:\n          push_double(0.5);\n          half = pop();\n          return hash_power(cadr(u), half, x);\n        default:\n          return hash_function(u, x);\n      }\n    }\n    return hashcode_values.constant;\n  };\n\n  hash_function = function(u, x) {\n    var arg_hash, base, name;\n    if (!Find(cadr(u), x)) {\n      return hashcode_values.constant;\n    }\n    name = car(u);\n    arg_hash = italu_hashcode(cadr(u), x);\n    base = hashcode_values[name.printname];\n    if (!base) {\n      throw new Error('Unsupported function ' + name.printname);\n    }\n    return Math.pow(base, arg_hash);\n  };\n\n  hash_addition = function(terms, x) {\n    var k, sum, term, term_hash, term_set, v;\n    term_set = {};\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      term_hash = 0;\n      if (Find(term, x)) {\n        term_hash = italu_hashcode(term, x);\n      } else {\n        // The original algorithm would skip this,\n        // but recording that it was present helps\n        // prevent collisions.\n        term_hash = hashcode_values.constant;\n      }\n      term_set[term_hash.toFixed(6)] = true;\n    }\n    sum = 0;\n    for (k in term_set) {\n      if (!hasProp.call(term_set, k)) continue;\n      v = term_set[k];\n      sum = sum + parseFloat(k, 10);\n    }\n    return sum;\n  };\n\n  hash_multiplication = function(terms, x) {\n    var product, term;\n    product = 1;\n    while (iscons(terms)) {\n      term = car(terms);\n      terms = cdr(terms);\n      if (Find(term, x)) {\n        product = product * italu_hashcode(term, x);\n      }\n    }\n    return product;\n  };\n\n  hash_power = function(base, power, x) {\n    var base_hash, exp_hash;\n    base_hash = hashcode_values.constant;\n    exp_hash = hashcode_values.constexp;\n    if (Find(base, x)) {\n      base_hash = italu_hashcode(base, x);\n    }\n    if (Find(power, x)) {\n      exp_hash = italu_hashcode(power, x);\n    } else {\n      // constant to constant = constant\n      if (base_hash === hashcode_values.constant) {\n        return hashcode_values.constant;\n      }\n      if (isminusone(power)) {\n        exp_hash = -1;\n      } else if (isoneovertwo(power)) {\n        exp_hash = 0.5;\n      } else if (isminusoneovertwo(power)) {\n        exp_hash = -0.5;\n      } else if (equalq(power, 2, 1)) {\n        exp_hash = 2;\n      } else if (equalq(power, -2, 1)) {\n        exp_hash = -2;\n      }\n    }\n    return Math.pow(base_hash, exp_hash);\n  };\n\n  make_hashed_itab = function() {\n    var f, h, key, len, o, s, tab, u;\n    tab = {};\n    for (o = 0, len = itab.length; o < len; o++) {\n      s = itab[o];\n      if (!s) {\n        break;\n      }\n      scan_meta(s);\n      f = pop();\n      u = cadr(f);\n      h = italu_hashcode(u, symbol(METAX));\n      key = h.toFixed(6);\n      if (!tab[key]) {\n        tab[key] = [];\n      }\n      tab[key].push(s);\n    }\n    console.log('hashed_itab = ' + JSON.stringify(tab, null, 2));\n    return tab;\n  };\n\n  $.make_hashed_itab = make_hashed_itab;\n\n  // pre-calculated hashed integral table.\n  // in case the integral table is changed, use this\n  //   Algebrite.make_hashed_itab()\n  // and copy the resulting JSON in here.\n  hashed_itab = {\n    \"1.144166\": [\"f(a,a*x)\"],\n    \"1.046770\": [\"f(1/x,log(x))\"],\n    \"0.936400\": [\"f(x^a,x^(a+1)/(a+1))\"],\n    \"1.095727\": [\"f(x^(-2),-x^(-1))\"],\n    \"1.023118\": [\"f(x^(-1/2),2*x^(1/2))\"],\n    \"0.977405\": [\"f(x^(1/2),2/3*x^(3/2))\"],\n    \"0.955320\": [\"f(x,x^2/2)\"],\n    \"0.912636\": [\"f(x^2,x^3/3)\"],\n    \"1.137302\": [\"f(exp(a*x),1/a*exp(a*x))\", \"f(a^x,a^x/log(a),or(not(number(a)),a>0))\"],\n    \"1.326774\": [\"f(exp(a*x+b),1/a*exp(a*x+b))\"],\n    \"1.080259\": [\"f(x*exp(a*x^2),exp(a*x^2)/(2*a))\"],\n    \"1.260228\": [\"f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))\"],\n    \"1.451902\": [\"f(log(a*x),x*log(a*x)-x)\"],\n    \"0.486192\": [\"f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))\", \"f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))\", \"f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))\", \"f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.697274\": [\"f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))\", \"f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))\", \"f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))\"],\n    \"0.476307\": [\"f(1/(a+b*x),1/b*log(a+b*x))\"],\n    \"0.226868\": [\"f(1/(a+b*x)^2,-1/(b*(a+b*x)))\"],\n    \"2.904531\": [\"f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)\"],\n    \"0.455026\": [\"f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)\"],\n    \"0.216732\": [\"f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))\"],\n    \"0.434695\": [\"f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))\"],\n    \"0.207048\": [\"f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))\"],\n    \"2.650781\": [\"f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))\"],\n    \"0.498584\": [\"f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))\"],\n    \"0.237479\": [\"f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))\"],\n    \"3.040375\": [\"f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))\"],\n    \"0.521902\": [\"f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))\"],\n    \"0.446014\": [\"f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))\"],\n    \"0.248586\": [\"f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))\"],\n    \"0.464469\": [\"f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))\"],\n    \"0.443716\": [\"f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))\"],\n    \"0.236382\": [\"f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))\"],\n    \"0.508931\": [\"f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))\"],\n    \"0.532733\": [\"f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))\"],\n    \"0.480638\": [\"f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))\"],\n    \"0.438648\": [\"f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))\"],\n    \"0.459164\": [\"f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))\", \"f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))\"],\n    \"0.450070\": [\"f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))\"],\n    \"1.448960\": [\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\"],\n    \"1.384221\": [\"f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)\"],\n    \"1.322374\": [\"f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)\"],\n    \"1.516728\": [\"f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.587665\": [\"f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"0.690150\": [\"f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)\"],\n    \"0.659314\": [\"f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)\"],\n    \"0.629856\": [\"f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)\"],\n    \"0.722428\": [\"f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))\"],\n    \"0.756216\": [\"f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))\"],\n    \"1.434156\": [\"f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))\", \"f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))\", \"f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))\"],\n    \"0.729886\": [\"f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))\", \"f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"1.501230\": [\"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))\", \"f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))\", \"f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))\"],\n    \"0.666120\": [\"f(x/sqrt(x^2+a),sqrt(x^2+a))\", \"f(x/sqrt(a-x^2),-sqrt(a-x^2))\"],\n    \"1.370077\": [\"f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))\", \"f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))\"],\n    \"1.730087\": [\"f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))\", \"f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))\"],\n    \"0.578006\": [\"f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))\"],\n    \"0.552180\": [\"f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))\"],\n    \"1.652787\": [\"f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))\"],\n    \"1.308862\": [\"f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))\", \"f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))\"],\n    \"1.342944\": [\"f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))\", \"f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))\", \"f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))\", \"f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))\"],\n    \"0.636358\": [\"f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))\", \"f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"0.652928\": [\"f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))\", \"f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))\", \"f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))\"],\n    \"0.764022\": [\"f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)\", \"f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))\"],\n    \"1.578940\": [\"f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))\", \"f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))\"],\n    \"1.620055\": [\"f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))\", \"f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))\"],\n    \"0.332117\": [\"f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))\", \"f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))\"],\n    \"1.571443\": [\"f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))\"],\n    \"1.690994\": [\"f(sin(a*x),-cos(a*x)/a)\"],\n    \"1.055979\": [\"f(cos(a*x),sin(a*x)/a)\"],\n    \"1.116714\": [\"f(tan(a*x),-log(cos(a*x))/a)\"],\n    \"0.895484\": [\"f(1/tan(a*x),log(sin(a*x))/a)\"],\n    \"0.946989\": [\"f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)\"],\n    \"0.591368\": [\"f(1/sin(a*x),log(tan(a*x/2))/a)\"],\n    \"2.859462\": [\"f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))\"],\n    \"2.128050\": [\"f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))\", \"f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"1.115091\": [\"f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))\"],\n    \"1.081452\": [\"f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))\", \"f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))\"],\n    \"0.349716\": [\"f(1/sin(a*x)^2,-1/(a*tan(a*x)))\"],\n    \"0.896788\": [\"f(1/cos(a*x)^2,tan(a*x)/a)\"],\n    \"1.785654\": [\"f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))\"],\n    \"3.188560\": [\"f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)\"],\n    \"1.516463\": [\"f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))\"],\n    \"2.707879\": [\"f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)\"],\n    \"0.369293\": [\"f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))\"],\n    \"0.560019\": [\"f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)\"],\n    \"0.530332\": [\"f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)\"],\n    \"0.331177\": [\"f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)\"],\n    \"0.313621\": [\"f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))\"],\n    \"3.172365\": [\"f(sin(a+b*x),-cos(a+b*x)/b)\"],\n    \"1.127162\": [\"f(cos(a+b*x),sin(a+b*x)/b)\"],\n    \"0.352714\": [\"f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)\", \"f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)\", \"f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)\"],\n    \"0.454515\": [\"f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)\", \"f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)\", \"f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)\"],\n    \"1.615441\": [\"f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)\"],\n    \"1.543263\": [\"f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)\"],\n    \"1.008798\": [\"f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)\"],\n    \"0.963724\": [\"f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)\"],\n    \"1.611938\": [\"f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)\"],\n    \"1.791033\": [\"f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)\"],\n    \"1.123599\": [\"f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)\"],\n    \"1.387031\": [\"f(x*log(a*x),x^2*log(a*x)/2-x^2/4)\"],\n    \"1.325058\": [\"f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)\"],\n    \"2.108018\": [\"f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)\"],\n    \"0.403214\": [\"f(1/x*1/(a+log(x)),log(a+log(x)))\"],\n    \"2.269268\": [\"f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)\"],\n    \"2.486498\": [\"f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)\"],\n    \"1.769733\": [\"f(sinh(x),cosh(x))\"],\n    \"1.883858\": [\"f(cosh(x),sinh(x))\"],\n    \"1.606140\": [\"f(tanh(x),log(cosh(x)))\"],\n    \"1.690661\": [\"f(x*sinh(x),x*cosh(x)-sinh(x))\"],\n    \"1.799688\": [\"f(x*cosh(x),x*sinh(x)-cosh(x))\"],\n    \"3.131954\": [\"f(sinh(x)^2,sinh(2*x)/4-x/2)\"],\n    \"2.579685\": [\"f(tanh(x)^2,x-tanh(x))\"],\n    \"3.548923\": [\"f(cosh(x)^2,sinh(2*x)/4+x/2)\"],\n    \"1.058866\": [\"f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)\"],\n    \"1.235270\": [\"f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)\"],\n    \"1.130783\": [\"f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)\"],\n    \"1.078698\": [\"f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))\"],\n    \"2.573650\": [\"f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)\", \"f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)\"],\n    \"2.640666\": [\"f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)\"],\n    \"1.086487\": [\"f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))\"],\n    \"1.267493\": [\"f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))\"],\n    \"1.037943\": [\"f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.210862\": [\"f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))\"],\n    \"1.064970\": [\"f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))\"],\n    \"1.242392\": [\"f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))\"]\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    Matrix on stack (must have two dimensions but\n  //        it can be non-numerical)\n\n  //  Output:    Inverse on stack\n\n  //  Example:\n\n  //  > inv(((1,2),(3,4))\n  //  ((-2,1),(3/2,-1/2))\n\n  //  > inv(((a,b),(c,d))\n  //  ((d / (a d - b c),-b / (a d - b c)),(-c / (a d - b c),a / (a d - b c)))\n\n  //  Note:\n\n  //  THIS IS DIFFERENT FROM INVERSE OF AN EXPRESSION (inv)\n  //   Uses Gaussian elimination for numerical matrices.\n\n  //-----------------------------------------------------------------------------\n  INV_check_arg = function() {\n    if (!istensor(p1)) {\n      return 0;\n    } else if (p1.tensor.ndim !== 2) {\n      return 0;\n    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  inv = function() {\n    var accumulator, eachEntry, i, n, o, ref;\n    i = 0;\n    n = 0;\n    //U **a\n    save();\n    p1 = pop();\n    // an inv just goes away when\n    // applied to another inv\n    if (isinv(p1)) {\n      push(car(cdr(p1)));\n      restore();\n      return;\n    }\n    // inverse goes away in case\n    // of identity matrix\n    if (isidentitymatrix(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // distribute the inverse of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push(car(p1));\n        p1 = cdr(p1);\n      }\n      for (eachEntry = o = ref = accumulator.length - 1; (ref <= 0 ? o <= 0 : o >= 0); eachEntry = ref <= 0 ? ++o : --o) {\n        push(accumulator[eachEntry]);\n        inv();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (INV_check_arg() === 0) {\n      push_symbol(INV);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    if (isNumericAtomOrTensor(p1)) {\n      yyinvg();\n    } else {\n      push(p1);\n      adj();\n      push(p1);\n      det();\n      p2 = pop();\n      if (isZeroAtomOrTensor(p2)) {\n        stop(\"inverse of singular matrix\");\n      }\n      push(p2);\n      divide();\n    }\n    return restore();\n  };\n\n  invg = function() {\n    save();\n    p1 = pop();\n    if (INV_check_arg() === 0) {\n      push_symbol(INVG);\n      push(p1);\n      list(2);\n      restore();\n      return;\n    }\n    yyinvg();\n    return restore();\n  };\n\n  // inverse using gaussian elimination\n  yyinvg = function() {\n    var h, i, i1, j, j1, l1, n, o, ref, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    j = 0;\n    n = 0;\n    n = p1.tensor.dim[0];\n    h = tos;\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      for (j = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        if (i === j) {\n          push(one);\n        } else {\n          push(zero);\n        }\n      }\n    }\n    for (i = j1 = 0, ref2 = n * n; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      push(p1.tensor.elem[i]);\n    }\n    INV_decomp(n);\n    p1 = alloc_tensor(n * n);\n    p1.tensor.ndim = 2;\n    p1.tensor.dim[0] = n;\n    p1.tensor.dim[1] = n;\n    for (i = l1 = 0, ref3 = n * n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(tos - 2 * n * n);\n    return push(p1);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    n * n unit matrix on stack\n\n  //      n * n operand on stack\n\n  //  Output:    n * n inverse matrix on stack\n\n  //      n * n garbage on stack\n\n  //      p2 mangled\n\n  //-----------------------------------------------------------------------------\n\n  //define A(i, j) stack[a + n * (i) + (j)]\n  //define U(i, j) stack[u + n * (i) + (j)]\n  INV_decomp = function(n) {\n    var a, d, i, i1, j, j1, l1, o, ref, ref1, ref2, ref3, ref4, results, u;\n    a = 0;\n    d = 0;\n    i = 0;\n    j = 0;\n    u = 0;\n    a = tos - n * n;\n    u = a - n * n;\n    results = [];\n    for (d = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); d = 0 <= ref ? ++o : --o) {\n      // diagonal element zero?\n      if (equal(stack[a + n * d + d], zero)) {\n// find a new row\n        for (i = i1 = ref1 = d + 1, ref2 = n; (ref1 <= ref2 ? i1 < ref2 : i1 > ref2); i = ref1 <= ref2 ? ++i1 : --i1) {\n          if (!equal(stack[a + n * i + d], zero)) {\n            break;\n          }\n        }\n        if (i === n) {\n          stop(\"inverse of singular matrix\");\n        }\n// exchange rows\n        for (j = j1 = 0, ref3 = n; (0 <= ref3 ? j1 < ref3 : j1 > ref3); j = 0 <= ref3 ? ++j1 : --j1) {\n          p2 = stack[a + n * d + j];\n          stack[a + n * d + j] = stack[a + n * i + j];\n          stack[a + n * i + j] = p2;\n          p2 = stack[u + n * d + j];\n          stack[u + n * d + j] = stack[u + n * i + j];\n          stack[u + n * i + j] = p2;\n        }\n      }\n      // multiply the pivot row by 1 / pivot\n      p2 = stack[a + n * d + d];\n      for (j = l1 = 0, ref4 = n; (0 <= ref4 ? l1 < ref4 : l1 > ref4); j = 0 <= ref4 ? ++l1 : --l1) {\n        if (j > d) {\n          push(stack[a + n * d + j]);\n          push(p2);\n          divide();\n          stack[a + n * d + j] = pop();\n        }\n        push(stack[u + n * d + j]);\n        push(p2);\n        divide();\n        stack[u + n * d + j] = pop();\n      }\n      results.push((function() {\n        var m1, ref5, results1;\n// clear out the column above and below the pivot\n        results1 = [];\n        for (i = m1 = 0, ref5 = n; (0 <= ref5 ? m1 < ref5 : m1 > ref5); i = 0 <= ref5 ? ++m1 : --m1) {\n          if (i === d) {\n            continue;\n          }\n          // multiplier\n          p2 = stack[a + n * i + d];\n          results1.push((function() {\n            var n1, ref6, results2;\n// add pivot row to i-th row\n            results2 = [];\n            for (j = n1 = 0, ref6 = n; (0 <= ref6 ? n1 < ref6 : n1 > ref6); j = 0 <= ref6 ? ++n1 : --n1) {\n              if (j > d) {\n                push(stack[a + n * i + j]);\n                push(stack[a + n * d + j]);\n                push(p2);\n                multiply();\n                subtract();\n                stack[a + n * i + j] = pop();\n              }\n              push(stack[u + n * i + j]);\n              push(stack[u + n * d + j]);\n              push(p2);\n              multiply();\n              subtract();\n              results2.push(stack[u + n * i + j] = pop());\n            }\n            return results2;\n          })());\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  DEBUG_IS = false;\n\n  // jsBoolToToInt = (p) ->\n  //   if p then 1 else 0\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtom = function(p) {\n    switch (p.k) {\n      case NUM:\n        return MZERO(p.q.a);\n      case DOUBLE:\n        return p.d === 0.0;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroTensor = function(p) {\n    var i, o, ref;\n    if (p.k !== TENSOR) {\n      return 0;\n    }\n    for (i = o = 0, ref = p.tensor.nelem; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      if (!isZeroAtomOrTensor(p.tensor.elem[i])) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // p is a U\n  // this routine is a simple check on whether we have\n  // a basic zero in our hands. It doesn't perform any\n  // calculations or simplifications.\n  isZeroAtomOrTensor = function(p) {\n    return isZeroAtom(p) || isZeroTensor(p);\n  };\n\n  // This is a key routine to try to determine whether\n  // the argument looks like zero/false, or non-zero/true,\n  // or undetermined.\n  // This is useful in two instances:\n  //  * to determine if a predicate is true/false\n  //  * to determine if particular quantity is zero\n  // Note that if one wants to check if we have a simple\n  // zero atom or tensor in our hands, then the isZeroAtomOrTensor\n  // routine is sufficient.\n  isZeroLikeOrNonZeroLikeOrUndetermined = function(valueOrPredicate) {\n    var evalledArgument;\n    // push the argument\n    push(valueOrPredicate);\n    // just like Eval but turns assignments into\n    // equality checks\n    Eval_predicate();\n    evalledArgument = pop();\n    // OK first check if we already have\n    // a simple zero (or simple zero tensor)\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    // also check if we have a simple numeric value, or a tensor\n    // full of simple numeric values (i.e. straight doubles or fractions).\n    // In such cases, since we\n    // just excluded they are zero, then we take it as\n    // a \"true\"\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // if we are here we are in the case of value that\n    // is not a zero and not a simple numeric value.\n    // e.g. stuff like\n    // 'sqrt(2)', or 'sin(45)' or '1+i', or 'a'\n    // so in such cases let's try to do a float()\n    // so we might get down to a simple numeric value\n    // in some of those cases\n    push(evalledArgument);\n    zzfloat();\n    evalledArgument = pop();\n    // anything that could be calculated down to a simple\n    // numeric value is now indeed either a \n    // double OR a double with an imaginary component\n    // e.g. 2.0 or 2.4 + i*5.6\n    // (Everything else are things that don't have a numeric\n    // value e.g. 'a+b')\n\n    // So, let's take care of the case where we have\n    // a simple numeric value with NO imaginary component,\n    // things like sqrt(2) or sin(PI)\n    // by doing the simple numeric\n    // values checks again\n    if (isZeroAtomOrTensor(evalledArgument)) {\n      return 0;\n    }\n    if (isNumericAtomOrTensor(evalledArgument)) {\n      return 1;\n    }\n    // here we still have cases of simple numeric values\n    // WITH an imaginary component e.g. '1+i',\n    // or things that don't have a numeric value e.g. 'a'\n\n    // so now let's take care of the imaginary numbers:\n    // since we JUST have to spot \"zeros\" we can just\n    // calculate the absolute value and re-do all the checks\n    // we just did\n    if (Find(evalledArgument, imaginaryunit)) {\n      push(evalledArgument);\n      absValFloat();\n      Eval_predicate();\n      evalledArgument = pop();\n      // re-do the simple-number checks...\n      if (isZeroAtomOrTensor(evalledArgument)) {\n        return 0;\n      }\n      if (isNumericAtomOrTensor(evalledArgument)) {\n        return 1;\n      }\n    }\n    // here we have stuff that is not reconducible to any\n    // numeric value (or tensor with numeric values) e.g.\n    // 'a+b', so it just means that we just don't know the\n    // truth value, so we have\n    // to leave the whole thing unevalled\n    return null;\n  };\n\n  // p is a U\n  isnegativenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === -1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d < 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  ispositivenumber = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MSIGN(p.q.a) === 1) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d > 0.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplustwo = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 2.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  // p is a U\n  isplusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === 1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isminusone = function(p) {\n    switch (p.k) {\n      case NUM:\n        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {\n          return 1;\n        }\n        break;\n      case DOUBLE:\n        if (p.d === -1.0) {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  isone = function(p) {\n    return isplusone(p) || isminusone(p);\n  };\n\n  isinteger = function(p) {\n    if (p.k === NUM && MEQUAL(p.q.b, 1)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isintegerorintegerfloat = function(p) {\n    if (p.k === DOUBLE) {\n      if (p.d === Math.round(p.d)) {\n        return 1;\n      }\n      return 0;\n    }\n    return isinteger(p);\n  };\n\n  isnonnegativeinteger = function(p) {\n    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isposint = function(p) {\n    if (isinteger(p) && MSIGN(p.q.a) === 1) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  isunivarpolyfactoredorexpandedform = function(p, x) {\n    if (DEBUG) {\n      console.log(\"isunivarpolyfactoredorexpandedform: p: \" + p + \" x: \" + x);\n    }\n    if (x == null) {\n      push(p);\n      guess();\n      x = pop();\n      pop();\n    }\n    if (ispolyfactoredorexpandedform(p, x) && (Find(p, symbol(SYMBOL_X)) + Find(p, symbol(SYMBOL_Y)) + Find(p, symbol(SYMBOL_Z)) === 1)) {\n      return x;\n    } else {\n      return 0;\n    }\n  };\n\n  // --------------------------------------\n  // sometimes we want to check if we have a poly in our\n  // hands, however it's in factored form and we don't\n  // want to expand it.\n  ispolyfactoredorexpandedform = function(p, x) {\n    return ispolyfactoredorexpandedform_factor(p, x);\n  };\n\n  ispolyfactoredorexpandedform_factor = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (DEBUG) {\n          console.log(\"ispolyfactoredorexpandedform_factor testing \" + car(p));\n        }\n        if (!ispolyfactoredorexpandedform_power(car(p), x)) {\n          if (DEBUG) {\n            console.log(\"... tested negative:\" + car(p));\n          }\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyfactoredorexpandedform_power(p, x);\n    }\n  };\n\n  ispolyfactoredorexpandedform_power = function(p, x) {\n    if (car(p) === symbol(POWER)) {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power (isposint(caddr(p)) \" + (isposint(caddr(p)), DEBUG ? console.log(\"ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) \" + ispolyexpandedform_expr(cadr(p), x)) : void 0));\n      }\n      return isposint(caddr(p)) && ispolyexpandedform_expr(cadr(p), x);\n    } else {\n      if (DEBUG) {\n        console.log(\"ispolyfactoredorexpandedform_power not a power, testing if this is exp form: \" + p);\n      }\n      return ispolyexpandedform_expr(p, x);\n    }\n  };\n\n  // --------------------------------------\n  ispolyexpandedform = function(p, x) {\n    if (Find(p, x)) {\n      return ispolyexpandedform_expr(p, x);\n    } else {\n      return 0;\n    }\n  };\n\n  ispolyexpandedform_expr = function(p, x) {\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_term(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_term(p, x);\n    }\n  };\n\n  ispolyexpandedform_term = function(p, x) {\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      while (iscons(p)) {\n        if (!ispolyexpandedform_factor(car(p), x)) {\n          return 0;\n        }\n        p = cdr(p);\n      }\n      return 1;\n    } else {\n      return ispolyexpandedform_factor(p, x);\n    }\n  };\n\n  ispolyexpandedform_factor = function(p, x) {\n    if (equal(p, x)) {\n      return 1;\n    }\n    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {\n      if (isposint(caddr(p))) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    if (Find(p, x)) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  // --------------------------------------\n  isnegativeterm = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  hasNegativeRationalExponent = function(p) {\n    if (car(p) === symbol(POWER) && isrational(car(cdr(cdr(p)))) && isnegativenumber(car(cdr(p)))) {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has imaginary component\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"hasNegativeRationalExponent: \" + p.toString() + \" has NO imaginary component\");\n      }\n      return 0;\n    }\n  };\n\n  isimaginarynumberdouble = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && hasNegativeRationalExponent(caddr(p))) || equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isimaginarynumber = function(p) {\n    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isNumericAtom(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit) || hasNegativeRationalExponent(caddr(p))) {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG_IS) {\n        console.log(\"isimaginarynumber: \" + p.toString() + \" isn't an imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iscomplexnumberdouble = function(p) {\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p))) || isimaginarynumberdouble(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  iscomplexnumber = function(p) {\n    if (DEBUG_IS) {\n      debugger;\n    }\n    if ((car(p) === symbol(ADD) && length(p) === 3 && isNumericAtom(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 1;\n    } else {\n      if (DEBUG) {\n        console.log(\"iscomplexnumber: \" + p.toString() + \" is imaginary number\");\n      }\n      return 0;\n    }\n  };\n\n  iseveninteger = function(p) {\n    if (isinteger(p) && p.q.a.isEven()) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  isnegative = function(p) {\n    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {\n      return 1;\n    } else if (isnegativeterm(p)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // returns 1 if there's a symbol somewhere.\n  // not used anywhere.\n  // NOTE: PI and POWER are symbols,\n  // so for example 2^3 would be symbolic\n  // while -1^(1/2) i.e. 'i' is not, so this can\n  // be tricky to use.\n  issymbolic = function(p) {\n    if (issymbol(p)) {\n      return 1;\n    } else {\n      while (iscons(p)) {\n        if (issymbolic(car(p))) {\n          return 1;\n        }\n        p = cdr(p);\n      }\n      return 0;\n    }\n  };\n\n  // i.e. 2, 2^3, etc.\n  isintegerfactor = function(p) {\n    return isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p));\n  };\n\n  isNumberOneOverSomething = function(p) {\n    return isfraction(p) && MEQUAL(p.q.a.abs(), 1);\n  };\n\n  isoneover = function(p) {\n    return car(p) === symbol(POWER) && isminusone(caddr(p));\n  };\n\n  isfraction = function(p) {\n    return p.k === NUM && !MEQUAL(p.q.b, 1);\n  };\n\n  // p is a U, n an int\n  equaln = function(p, n) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1);\n      case DOUBLE:\n        return p.d === n;\n      default:\n        return false;\n    }\n  };\n\n  // p is a U, a and b ints\n  equalq = function(p, a, b) {\n    switch (p.k) {\n      case NUM:\n        return MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b);\n      case DOUBLE:\n        return p.d === a / b;\n      default:\n        return false;\n    }\n  };\n\n  // 1/2 ?\n  isoneovertwo = function(p) {\n    return equalq(p, 1, 2);\n  };\n\n  // -1/2 ?\n  isminusoneovertwo = function(p) {\n    return equalq(p, -1, 2);\n  };\n\n  // 1/sqrt(2) ?\n  isoneoversqrttwo = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2);\n  };\n\n  // -1/sqrt(2) ?\n  isminusoneoversqrttwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3;\n  };\n\n  // sqrt(3)/2 ?\n  issqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // -sqrt(3)/2 ?\n  isminussqrtthreeovertwo = function(p) {\n    return car(p) === symbol(MULTIPLY) && isminusoneovertwo(cadr(p)) && issqrtthree(caddr(p)) && length(p) === 3;\n  };\n\n  // p == sqrt(3) ?\n  issqrtthree = function(p) {\n    return car(p) === symbol(POWER) && equaln(cadr(p), 3) && isoneovertwo(caddr(p));\n  };\n\n  isfloating = function(p) {\n    if (p.k === DOUBLE || p === symbol(FLOATF)) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isfloating(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  isimaginaryunit = function(p) {\n    if (equal(p, imaginaryunit)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // n/2 * i * pi ?\n\n  // return value:\n\n  //  0  no\n\n  //  1  1\n\n  //  2  -1\n\n  //  3  i\n\n  //  4  -i\n  isquarterturn = function(p) {\n    var minussign, n;\n    n = 0;\n    minussign = 0;\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (equal(cadr(p), imaginaryunit)) {\n      if (caddr(p) !== symbol(PI)) {\n        return 0;\n      }\n      if (length(p) !== 3) {\n        return 0;\n      }\n      return 2;\n    }\n    if (!isNumericAtom(cadr(p))) {\n      return 0;\n    }\n    if (!equal(caddr(p), imaginaryunit)) {\n      return 0;\n    }\n    if (cadddr(p) !== symbol(PI)) {\n      return 0;\n    }\n    if (length(p) !== 4) {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 1) {\n      minussign = 1;\n      n = -n;\n    }\n    switch (n % 4) {\n      case 0:\n        n = 1;\n        break;\n      case 1:\n        if (minussign) {\n          n = 4;\n        } else {\n          n = 3;\n        }\n        break;\n      case 2:\n        n = 2;\n        break;\n      case 3:\n        if (minussign) {\n          n = 3;\n        } else {\n          n = 4;\n        }\n    }\n    return n;\n  };\n\n  // special multiple of pi?\n\n  // returns for the following multiples of pi...\n\n  //  -4/2  -3/2  -2/2  -1/2  1/2  2/2  3/2  4/2\n\n  //  4  1  2  3  1  2  3  4\n  isnpi = function(p) {\n    var doNothing, n;\n    n = 0;\n    if (p === symbol(PI)) {\n      return 2;\n    }\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {\n      doNothing = 0;\n    } else {\n      return 0;\n    }\n    push(cadr(p));\n    push_integer(2);\n    multiply();\n    n = pop_integer();\n    if (isNaN(n)) {\n      return 0;\n    }\n    if (n < 0) {\n      n = 4 - (-n) % 4;\n    } else {\n      n = 1 + (n - 1) % 4;\n    }\n    return n;\n  };\n\n  $.isZeroAtomOrTensor = isZeroAtomOrTensor;\n\n  $.isnegativenumber = isnegativenumber;\n\n  $.isplusone = isplusone;\n\n  $.isminusone = isminusone;\n\n  $.isinteger = isinteger;\n\n  $.isnonnegativeinteger = isnonnegativeinteger;\n\n  $.isposint = isposint;\n\n  $.isnegativeterm = isnegativeterm;\n\n  $.isimaginarynumber = isimaginarynumber;\n\n  $.iscomplexnumber = iscomplexnumber;\n\n  $.iseveninteger = iseveninteger;\n\n  $.isnegative = isnegative;\n\n  $.issymbolic = issymbolic;\n\n  $.isintegerfactor = isintegerfactor;\n\n  $.isoneover = isoneover;\n\n  $.isfraction = isfraction;\n\n  $.isoneoversqrttwo = isoneoversqrttwo;\n\n  $.isminusoneoversqrttwo = isminusoneoversqrttwo;\n\n  $.isfloating = isfloating;\n\n  $.isimaginaryunit = isimaginaryunit;\n\n  $.isquarterturn = isquarterturn;\n\n  $.isnpi = isnpi;\n\n  Eval_isprime = function() {\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_laguerre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return laguerre();\n  };\n\n  //define X p1\n  //define N p2\n  //define K p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  laguerre = function() {\n    var n;\n    n = 0;\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    if (n < 0 || isNaN(n)) {\n      push_symbol(LAGUERRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      restore();\n      return;\n    }\n    if (issymbol(p1)) {\n      laguerre2(n);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      laguerre2(n);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return restore();\n  };\n\n  laguerre2 = function(n) {\n    var i, o, ref, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n    results = [];\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      subtract();\n      push(p3);\n      add();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p3);\n      add();\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      results.push(divide());\n    }\n    return results;\n  };\n\n  // Find the least common multiple of two expressions.\n  Eval_lcm = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      lcm();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  lcm = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    save();\n    yylcm();\n    restore();\n    return expanding = prev_expanding;\n  };\n\n  yylcm = function() {\n    expanding = 1;\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    gcd();\n    push(p1);\n    divide();\n    push(p2);\n    divide();\n    return inverse();\n  };\n\n  Eval_leading = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p1);\n    }\n    return leading();\n  };\n\n  //define P p1\n  //define X p2\n  //define N p3\n  leading = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p1); // N = degree of P\n    push(p2);\n    degree();\n    p3 = pop();\n    push(p1); // divide through by X ^ N\n    push(p2);\n    push(p3);\n    power();\n    divide();\n    push(p2); // remove terms that depend on X\n    filter();\n    return restore();\n  };\n\n  Eval_legendre = function() {\n    // 1st arg\n    push(cadr(p1));\n    Eval();\n    // 2nd arg\n    push(caddr(p1));\n    Eval();\n    // 3rd arg (optional)\n    push(cadddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0);\n    } else {\n      push(p2);\n    }\n    return legendre();\n  };\n\n  //define X p1\n  //define N p2\n  //define M p3\n  //define Y p4\n  //define Y0 p5\n  //define Y1 p6\n  legendre = function() {\n    save();\n    __legendre();\n    return restore();\n  };\n\n  __legendre = function() {\n    var m, n;\n    m = 0;\n    n = 0;\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    n = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (n < 0 || isNaN(n) || m < 0 || isNaN(m)) {\n      push_symbol(LEGENDRE);\n      push(p1);\n      push(p2);\n      push(p3);\n      list(4);\n      return;\n    }\n    if (issymbol(p1)) {\n      __legendre2(n, m);\n    } else {\n      p4 = p1;\n      p1 = symbol(SECRETX);\n      __legendre2(n, m);\n      p1 = p4;\n      push(symbol(SECRETX));\n      push(p1);\n      subst();\n      Eval();\n    }\n    return __legendre3(m);\n  };\n\n  __legendre2 = function(n, m) {\n    var i, i1, o, ref, ref1, results;\n    i = 0;\n    push_integer(1);\n    push_integer(0);\n    p6 = pop();\n//  i=1  p5 = 0 \n//    p6 = 1 \n//    ((2*i+1)*x*p6 - i*p5) / i = x\n\n//  i=2  p5 = 1\n//    p6 = x\n//    ((2*i+1)*x*p6 - i*p5) / i = -1/2 + 3/2*x^2\n\n//  i=3  p5 = x\n//    p6 = -1/2 + 3/2*x^2\n//    ((2*i+1)*x*p6 - i*p5) / i = -3/2*x + 5/2*x^3\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      p5 = p6;\n      p6 = pop();\n      push_integer(2 * i + 1);\n      push(p1);\n      multiply();\n      push(p6);\n      multiply();\n      push_integer(i);\n      push(p5);\n      multiply();\n      subtract();\n      push_integer(i + 1);\n      divide();\n    }\n    results = [];\n    for (i = i1 = 0, ref1 = m; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(p1);\n      results.push(derivative());\n    }\n    return results;\n  };\n\n  // moveTos tos * (-1)^m * (1-x^2)^(m/2)\n  __legendre3 = function(m) {\n    if (m === 0) {\n      return;\n    }\n    if (car(p1) === symbol(COS)) {\n      push(cadr(p1));\n      sine();\n      square();\n    } else if (car(p1) === symbol(SIN)) {\n      push(cadr(p1));\n      cosine();\n      square();\n    } else {\n      push_integer(1);\n      push(p1);\n      square();\n      subtract();\n    }\n    push_integer(m);\n    push_rational(1, 2);\n    multiply();\n    power();\n    multiply();\n    if (m % 2) {\n      return negate();\n    }\n  };\n\n  // Create a list from n things on the stack.\n\n  // n is an integer\n  list = function(n) {\n    var listIterator, o, ref, results;\n    listIterator = 0;\n    push(symbol(NIL));\n    results = [];\n    for (listIterator = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); listIterator = 0 <= ref ? ++o : --o) {\n      results.push(cons());\n    }\n    return results;\n  };\n\n  // Natural logarithm.\n\n  // Note that we use the mathematics / Javascript / Mathematica\n  // convention that \"log\" is indeed the natural logarithm.\n\n  // In engineering, biology, astronomy, \"log\" can stand instead\n  // for the \"common\" logarithm i.e. base 10. Also note that Google\n  // calculations use log for the common logarithm.\n  Eval_log = function() {\n    push(cadr(p1));\n    Eval();\n    return logarithm();\n  };\n\n  logarithm = function() {\n    save();\n    yylog();\n    return restore();\n  };\n\n  yylog = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (p1 === symbol(E)) {\n      push_integer(1);\n      return;\n    }\n    if (equaln(p1, 1)) {\n      push_integer(0);\n      return;\n    }\n    if (isnegativenumber(p1)) {\n      push(p1);\n      negate();\n      logarithm();\n      push(imaginaryunit);\n      if (evaluatingAsFloats) {\n        push_double(Math.PI);\n      } else {\n        push_symbol(PI);\n      }\n      multiply();\n      add();\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.log(p1.d);\n      push_double(d);\n      return;\n    }\n    // rational number and not an integer?\n    if (isfraction(p1)) {\n      push(p1);\n      numerator();\n      logarithm();\n      push(p1);\n      denominator();\n      logarithm();\n      subtract();\n      return;\n    }\n    // log(a ^ b) --> b log(a)\n    if (car(p1) === symbol(POWER)) {\n      push(caddr(p1));\n      push(cadr(p1));\n      logarithm();\n      multiply();\n      return;\n    }\n    // log(a * b) --> log(a) + log(b)\n    if (car(p1) === symbol(MULTIPLY)) {\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        logarithm();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    push_symbol(LOG);\n    push(p1);\n    return list(2);\n  };\n\n  // now this might be a little confusing, so a\n  // clarification is in order.\n  // First off, at the scripting level most things\n  // as they are handled get evalled.\n  // That means that they are recursively \"calculated\"\n  // as much as possible, i.e. variables are recursively\n  // looked up for their values, operators are applied,\n  // functions are ivoked, etc.\n  // I.e. while scripting, most things are\n  // evalled all the times.\n  // e.g. if I type\n  //   x = 1+1\n  // then x is actually assigned 2, not 1+1\n  // Something that helps a little is \"quote\", e.g.\n  // If I assign\n  //   x = quote(1+1)\n  // then x actually contains 1+1, not 2.\n  // But then x is evaluated as soon as I type\n  //   x // gives \"2\" as x is evaluated\n\n  // Evaluation is great, but sometimes one wants\n  // to look at the actual structure of an expression\n  // or a content of a variable, without those\n  // being evaluated first.\n\n  // for example I might type\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // and from this point on printing the actual\n  // structure of x is impossible, because from\n  // now on any evaluation of x will give \"3\"\n  // You might say \"but you have x defined up there,\n  // what's the point of printing it out?\", to which\n  // the answer is that one might do further\n  // substitutions or transformations of special kind\n  // to x. One might want to look at the structure\n  // and it might be complex or impossible.\n\n  // So this function does that.\n  // If it's passed a variable, then it\n  // DOES NOT eval the variable, RATHER\n  // it prints the content of the variable without\n  // evaluating it.\n  // In the other cases it works like \"quote\" e.g.\n  // it just gives the argument as is, again without\n  // evaluating it.\n\n  // In the following examples, for brevity, I just\n  // use\n  //   x = quote(1+2)\n  // instead of this:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // to put a structure in x that is easy to see whether\n  // it's avaulated or not.\n\n  // So lookup allows this:\n  //   x = quote(1+2)\n  //   print(lookup(x)) # gives 1+2\n\n  // Note that there would be potentially a way\n  // to achieve a similar result, you could do:\n  //   x = quote(quote(1+2))\n  //   print(x)\n  // but you can't always control x to contain\n  // two quotes like that...\n  // note how two \"quotes\" are needed because\n  // if you just put one, then\n  // x would indeed contain 1+2 instead of 3,\n  // but then print would evaluate that to 3:\n  //   x = quote(1+2) # now x contains 1+2, not 3\n  //   print(x) # but x evaluated here to 3\n\n  // Other workarounds would not work:\n  //   x = quote(1+2)\n  //   print(quote(x))\n  // would not work because quote(x) literally means 'x'\n  // so 'x' is printed instead of its content.\n\n  // Note also that lookup allows you to copy\n  // the structure of a variable to another:\n  //   x = a + b\n  //   a = 1\n  //   b = 2\n  // now:\n  //   y = x # y contains the number 3 and prints to 3\n  //   y = lookup(x) # y contains \"a+b\" and prints to 3\n  //   y = quote(x) # y contains \"x\" and prints to 3\n  // note that in the first and second case y is\n  // independent from x, i.e. changing x doesn't change y\n  // while in the last case it is.\n\n  // Another similar simple example is when doing something\n  // like this:\n  //    x = y\n  //    y = z\n  //    x\n  //       => gives z\n  //    lookup(x)\n  //       => gives y\n  //          i.e. lookup allows you to see the immediate\n  //          content of x, rather than the evaluation which\n  //          would end up in x -> y -> z\n  // Note that if you invert the order of the assignments i.e.\n  //    y = z\n  //    x = y\n  // Then at this point x immediately contains z, since the\n  // assignment x = y is not quoted, hence y is evaluated to z\n  // when assigned to x.\n  //    lookup(x)\n  //       => gives z\n  Eval_lookup = function() {\n    p1 = cadr(p1);\n    if (!iscons(p1) && cadr(p1).k === SYM) {\n      p1 = get_binding(p1);\n    }\n    return push(p1); // Bignum addition and subtraction\n  };\n\n  \n  //static unsigned int *addf(unsigned int *, unsigned int *)\n  //static unsigned int *subf(unsigned int *, unsigned int *)\n  //static int ucmp(unsigned int *, unsigned int *)\n  madd = function(a, b) {\n    return a.add(b);\n  };\n\n  msub = function(a, b) {\n    return a.subtract(b);\n  };\n\n  addf = function(a, b) {\n    return a.add(b);\n  };\n\n  subf = function(a, b) {\n    return a.subtract(b);\n  };\n\n  // unsigned compare\n  ucmp = function(a, b) {\n    return a.compareAbs(b);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum GCD\n\n  //  Uses the binary GCD algorithm.\n\n  //  See \"The Art of Computer Programming\" p. 338.\n\n  //  mgcd always returns a positive value\n\n  //  mgcd(0, 0) = 0\n\n  //  mgcd(u, 0) = |u|\n\n  //  mgcd(0, v) = |v|\n\n  //-----------------------------------------------------------------------------\n  mgcd = function(u, v) {\n    return bigInt.gcd(u, v);\n  };\n\n  //if SELFTEST\n\n  // s is a string\n  new_string = function(s) {\n    var theNewString;\n    theNewString = new U();\n    theNewString.k = STR;\n    theNewString.str = s;\n    return theNewString;\n  };\n\n  out_of_memory = function() {\n    return stop(\"out of memory\");\n  };\n\n  // both ints\n  push_zero_matrix = function(i, j) {\n    push(alloc_tensor(i * j));\n    stack[tos - 1].tensor.ndim = 2;\n    stack[tos - 1].tensor.dim[0] = i;\n    return stack[tos - 1].tensor.dim[1] = j;\n  };\n\n  push_identity_matrix = function(n) {\n    var i, o, ref;\n    push_zero_matrix(n, n);\n    for (i = o = 0, ref = n; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      stack[tos - 1].tensor.elem[i * n + i] = one;\n    }\n    return check_tensor_dimensions(stack[tos - 1]);\n  };\n\n  push_cars = function(p) {\n    var results;\n    results = [];\n    while (iscons(p)) {\n      push(car(p));\n      results.push(p = cdr(p));\n    }\n    return results;\n  };\n\n  // see cmp_expr definition, this\n  // function alone just does simple structure comparison\n  // or compares numbers (either rationals or integers or doubles)\n  // but can't be used alone to test\n  // more complex mathematical equalities...\n  equal = function(p1, p2) {\n    if (cmp_expr(p1, p2) === 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  lessp = function(p1, p2) {\n    if (cmp_expr(p1, p2) < 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  sign = function(n) {\n    if (n < 0) {\n      return -1;\n    } else if (n > 0) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // compares whether two expressions\n  // have the same structure.\n  // For example this method alone\n  // would compare \"1+1\" and \"2\"\n  // as different.\n  // It just so happens though that one oftens\n  // evaluates the two sides before passing them\n  // to this function, so chances are that the two\n  // sides have the same normal form.\n  // Even a simple evaluation might not cut it\n  // though... a simplification of both sides\n  // would then help. And even that might not\n  // cut it in some cases...\n  cmp_expr = function(p1, p2) {\n    var n;\n    n = 0;\n    if (p1 === p2) {\n      return 0;\n    }\n    if (p1 === symbol(NIL)) {\n      return -1;\n    }\n    if (p2 === symbol(NIL)) {\n      return 1;\n    }\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      return sign(compare_numbers(p1, p2));\n    }\n    if (isNumericAtom(p1)) {\n      return -1;\n    }\n    if (isNumericAtom(p2)) {\n      return 1;\n    }\n    if (isstr(p1) && isstr(p2)) {\n      return sign(strcmp(p1.str, p2.str));\n    }\n    if (isstr(p1)) {\n      return -1;\n    }\n    if (isstr(p2)) {\n      return 1;\n    }\n    if (issymbol(p1) && issymbol(p2)) {\n      return sign(strcmp(get_printname(p1), get_printname(p2)));\n    }\n    if (issymbol(p1)) {\n      return -1;\n    }\n    if (issymbol(p2)) {\n      return 1;\n    }\n    if (istensor(p1) && istensor(p2)) {\n      return compare_tensors(p1, p2);\n    }\n    if (istensor(p1)) {\n      return -1;\n    }\n    if (istensor(p2)) {\n      return 1;\n    }\n    // recursion here\n    while (iscons(p1) && iscons(p2)) {\n      n = cmp_expr(car(p1), car(p2));\n      if (n !== 0) {\n        return n;\n      }\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    if (iscons(p2)) {\n      return -1;\n    }\n    if (iscons(p1)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  length = function(p) {\n    var n;\n    n = 0;\n    while (iscons(p)) {\n      p = cdr(p);\n      n++;\n    }\n    return n;\n  };\n\n  unique = function(p) {\n    save();\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    unique_f(p);\n    if (p2 !== symbol(NIL)) {\n      p1 = symbol(NIL);\n    }\n    p = p1;\n    restore();\n    return p;\n  };\n\n  unique_f = function(p) {\n    if (isstr(p)) {\n      if (p1 === symbol(NIL)) {\n        p1 = p;\n      } else if (p !== p1) {\n        p2 = p;\n      }\n      return;\n    }\n    while (iscons(p)) {\n      unique_f(car(p));\n      if (p2 !== symbol(NIL)) {\n        return;\n      }\n      p = cdr(p);\n    }\n  };\n\n  ssqrt = function() {\n    push_rational(1, 2);\n    return power();\n  };\n\n  yyexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    Eval();\n    return expanding = prev_expanding;\n  };\n\n  exponential = function() {\n    push_symbol(E);\n    swap();\n    return power();\n  };\n\n  square = function() {\n    push_integer(2);\n    return power();\n  };\n\n  //__cmp = (p1, p2) ->\n  //  return cmp_expr(p1, p2)\n\n  // n an integer\n  sort_stack = function(n) {\n    var h, subsetOfStack;\n    //qsort(stack + tos - n, n, sizeof (U *), __cmp)\n    h = tos - n;\n    subsetOfStack = stack.slice(h, h + n);\n    subsetOfStack.sort(cmp_expr);\n    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));\n  };\n\n  $.equal = equal;\n\n  $.length = length;\n\n  // Bignum multiplication and division\n  mmul = function(a, b) {\n    return a.multiply(b);\n  };\n\n  mdiv = function(a, b) {\n    return a.divide(b);\n  };\n\n  // a = a + b\n  /*\n  static void\n  addf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # can be signed or unsigned \n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] + b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = a - b\n\n  static void\n  subf(unsigned int *a, unsigned int *b, int len)\n  {\n    int i\n    long long t = 0; # must be signed\n    for (i = 0; i < len; i++) {\n      t += (long long) a[i] - b[i]\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n  }\n\n  // a = b * c\n\n  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000\n\n  static void\n  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)\n  {\n    int i\n    unsigned long long t = 0; # must be unsigned\n    for (i = 0; i < len; i++) {\n      t += (unsigned long long) b[i] * c\n      a[i] = (unsigned int) t\n      t >>= 32\n    }\n    a[i] = (unsigned int) t\n  }\n  */\n  mmod = function(a, b) {\n    return a.mod(b);\n  };\n\n  // return both quotient and remainder of a/b\n  // we'd have this method as divmod(number)\n  // but obviously doesn't change the passed parameters\n  mdivrem = function(a, b) {\n    var toReturn;\n    toReturn = a.divmod(b);\n    return [toReturn.quotient, toReturn.remainder];\n  };\n\n  //if SELFTEST\n\n  // small integer tests\n  Eval_mod = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return mod();\n  };\n\n  mod = function() {\n    var n;\n    n = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (isZeroAtomOrTensor(p2)) {\n      stop(\"mod function: divide by zero\");\n    }\n    if (!isNumericAtom(p1) || !isNumericAtom(p2)) {\n      push_symbol(MOD);\n      push(p1);\n      push(p2);\n      list(3);\n      restore();\n      return;\n    }\n    if (isdouble(p1)) {\n      push(p1);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p1 = pop();\n    }\n    if (isdouble(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (isNaN(n)) {\n        stop(\"mod function: cannot convert float value to integer\");\n      }\n      push_integer(n);\n      p2 = pop();\n    }\n    if (!isinteger(p1) || !isinteger(p2)) {\n      stop(\"mod function: integer arguments expected\");\n    }\n    p3 = new U();\n    p3.k = NUM;\n    p3.q.a = mmod(p1.q.a, p2.q.a);\n    p3.q.b = mint(1);\n    push(p3);\n    return restore();\n  };\n\n  // Bignum power\n\n  // a is a bigint, n is a small normal int\n  mpow = function(a, n) {\n    return a.pow(n);\n  };\n\n  //if SELFTEST\n\n  // Bignum prime test (returns 1 if prime, 0 if not)\n\n  // Uses Algorithm P (probabilistic primality test) from p. 395 of\n  // \"The Art of Computer Programming, Volume 2\" by Donald E. Knuth.\n  mprime = function(n) {\n    return n.isProbablePrime();\n  };\n\n  //if SELFTEST\n\n  //-----------------------------------------------------------------------------\n\n  //  Bignum root\n\n  //  Returns null pointer if not perfect root.\n\n  //  The sign of the radicand is ignored.\n\n  //-----------------------------------------------------------------------------\n  mroot = function(n, index) {\n    var i, j, k, o, ref, x, y;\n    // this doesn't quite work\n    //return n.pow(1/index +  0.0000000000000001)\n\n    // sign of radicand ignored\n    n = n.abs();\n    i = 0;\n    j = 0;\n    k = 0;\n    if (index === 0) {\n      stop(\"root index is zero\");\n    }\n    // count number of bits\n    k = 0;\n    while (n.shiftRight(k) > 0) {\n      k++;\n    }\n    if (k === 0) {\n      return mint(0);\n    }\n    // initial guess\n    k = Math.floor((k - 1) / index);\n    j = Math.floor(k / 32 + 1);\n    x = bigInt(j);\n    for (i = o = 0, ref = j; (0 <= ref ? o < ref : o > ref); i = 0 <= ref ? ++o : --o) {\n      // zero-out the ith bit\n      x = x.and(bigInt(1).shiftLeft(i).not());\n    }\n    while (k >= 0) {\n      // set the kth bit\n      x = x.or(bigInt(1).shiftLeft(k));\n      y = mpow(x, index);\n      switch (mcmp(y, n)) {\n        case 0:\n          return x;\n        case 1:\n          //mp_clr_bit(x, k)\n          // clear the kth bit\n          x = x.and(bigInt(1).shiftLeft(k).not());\n      }\n      k--;\n    }\n    return 0;\n  };\n\n  //if SELFTEST\n\n  // Symbolic multiplication\n\n  // multiplication is commutative, so it can't be used\n  // e.g. on two matrices.\n  // But it can be used, say, on a scalar and a matrix.,\n  // so the output of a multiplication is not\n  // always a scalar.\n\n  //extern void append(void)\n  //static void parse_p1(void)\n  //static void parse_p2(void)\n  //static void __normalize_radical_factors(int)\n  DEBUG_MULTIPLY = false;\n\n  Eval_multiply = function() {\n    var results;\n    push(cadr(p1));\n    Eval();\n    p1 = cddr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      multiply();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  // this one doesn't eval the factors,\n  // so you pass i*(-1)^(1/2), it wouldnt't\n  // give -1, because i is not evalled\n  multiply = function() {\n    if (esc_flag) {\n      stop(\"escape key stop\");\n    }\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply_numbers();\n    } else {\n      save();\n      yymultiply();\n      return restore();\n    }\n  };\n\n  yymultiply = function() {\n    var h, i, n, o, ref, ref1;\n    h = 0;\n    i = 0;\n    n = 0;\n    // pop operands\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    // is either operand zero?\n    if (isZeroAtom(p1) || isZeroAtom(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      return;\n    }\n    // is either operand a sum?\n\n    //console.log(\"yymultiply: expanding: \" + expanding)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        multiply();\n        add();\n        p1 = cdr(p1);\n      }\n      return;\n    }\n    if (expanding && isadd(p2)) {\n      p2 = cdr(p2);\n      if (evaluatingAsFloats) {\n        push_double(0.0);\n      } else {\n        push(zero);\n      }\n      while (iscons(p2)) {\n        push(p1);\n        push(car(p2));\n        multiply();\n        add();\n        p2 = cdr(p2);\n      }\n      return;\n    }\n    if (!istensor(p1) && istensor(p2)) {\n      push(p1);\n      push(p2);\n      scalar_times_tensor();\n      return;\n    }\n    // tensor times scalar?\n    if (istensor(p1) && !istensor(p2)) {\n      push(p1);\n      push(p2);\n      tensor_times_scalar();\n      return;\n    }\n    // adjust operands\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n    } else {\n      push(p1);\n      list(1);\n      p1 = pop();\n    }\n    if (car(p2) === symbol(MULTIPLY)) {\n      p2 = cdr(p2);\n    } else {\n      push(p2);\n      list(1);\n      p2 = pop();\n    }\n    // handle numerical coefficients\n    if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {\n      push(car(p1));\n      push(car(p2));\n      multiply_numbers();\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    } else if (isNumericAtom(car(p1))) {\n      push(car(p1));\n      p1 = cdr(p1);\n    } else if (isNumericAtom(car(p2))) {\n      push(car(p2));\n      p2 = cdr(p2);\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n    }\n    parse_p1();\n    parse_p2();\n    while (iscons(p1) && iscons(p2)) {\n      //    if (car(p1)->gamma && car(p2)->gamma) {\n      //      combine_gammas(h)\n      //      p1 = cdr(p1)\n      //      p2 = cdr(p2)\n      //      parse_p1()\n      //      parse_p2()\n      //      continue\n      //    }\n      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {\n        push_symbol(OPERATOR);\n        push(cdar(p1));\n        push(cdar(p2));\n        append();\n        cons();\n        p1 = cdr(p1);\n        p2 = cdr(p2);\n        parse_p1();\n        parse_p2();\n        continue;\n      }\n      switch (cmp_expr(p3, p4)) {\n        case -1:\n          push(car(p1));\n          p1 = cdr(p1);\n          parse_p1();\n          break;\n        case 1:\n          push(car(p2));\n          p2 = cdr(p2);\n          parse_p2();\n          break;\n        case 0:\n          combine_factors(h);\n          p1 = cdr(p1);\n          p2 = cdr(p2);\n          parse_p1();\n          parse_p2();\n          break;\n        default:\n          stop(\"internal error 2\");\n      }\n    }\n    // push remaining factors, if any\n    while (iscons(p1)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    while (iscons(p2)) {\n      push(car(p2));\n      p2 = cdr(p2);\n    }\n    // normalize radical factors\n\n    // example: 2*2(-1/2) -> 2^(1/2)\n\n    // must be done after merge because merge may produce radical\n\n    // example: 2^(1/2-a)*2^a -> 2^(1/2)\n    __normalize_radical_factors(h);\n    // this hack should not be necessary, unless power returns a multiply\n\n    //for (i = h; i < tos; i++) {\n    //  if (car(stack[i]) == symbol(MULTIPLY)) {\n    //    multiply_all(tos - h)\n    //    return\n    //  }\n    //}\n    if (expanding) {\n      for (i = o = ref = h, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n        if (isadd(stack[i])) {\n          multiply_all(tos - h);\n          return;\n        }\n      }\n    }\n    // n is the number of result factors on the stack\n    n = tos - h;\n    if (n === 1) {\n      return;\n    }\n    // discard integer 1\n    if (isrational(stack[h]) && equaln(stack[h], 1)) {\n      if (n === 2) {\n        p7 = pop();\n        pop();\n        push(p7);\n      } else {\n        stack[h] = symbol(MULTIPLY);\n        list(n);\n      }\n      return;\n    }\n    list(n);\n    p7 = pop();\n    push_symbol(MULTIPLY);\n    push(p7);\n    return cons();\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p1)    factor\n\n  // output:  p3    factor's base\n\n  //    p5    factor's power (possibly 1)\n  parse_p1 = function() {\n    p3 = car(p1);\n    p5 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p3) === symbol(POWER)) {\n      p5 = caddr(p3);\n      return p3 = cadr(p3);\n    }\n  };\n\n  // Decompose a factor into base and power.\n\n  // input:  car(p2)    factor\n\n  // output:  p4    factor's base\n\n  //    p6    factor's power (possibly 1)\n  parse_p2 = function() {\n    p4 = car(p2);\n    p6 = evaluatingAsFloats ? one_as_double : one;\n    if (car(p4) === symbol(POWER)) {\n      p6 = caddr(p4);\n      return p4 = cadr(p4);\n    }\n  };\n\n  // h an integer\n  combine_factors = function(h) {\n    push(p4);\n    push(p5);\n    push(p6);\n    add();\n    power();\n    p7 = pop();\n    if (isNumericAtom(p7)) {\n      push(stack[h]);\n      push(p7);\n      multiply_numbers();\n      return stack[h] = pop();\n    } else if (car(p7) === symbol(MULTIPLY)) {\n      // power can return number * factor (i.e. -1 * i)\n      if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {\n        push(stack[h]);\n        push(cadr(p7));\n        multiply_numbers();\n        stack[h] = pop();\n        return push(caddr(p7));\n      } else {\n        return push(p7);\n      }\n    } else {\n      return push(p7);\n    }\n  };\n\n  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];\n\n  //if 0\n\n  // h an int\n  combine_gammas = function(h) {\n    var n;\n    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];\n    if (n < 0) {\n      n = -n;\n      push(stack[h]);\n      negate();\n      stack[h] = pop();\n    }\n    if (n > 1) {\n      return push(_gamma[n]);\n    }\n  };\n\n  // this is useful for example when you are just adding/removing\n  // factors from an already factored quantity.\n  // e.g. if you factored x^2 + 3x + 2 into (x+1)(x+2)\n  // and you want to divide by (x+1) , i.e. you multiply by (x-1)^-1,\n  // then there is no need to expand.\n  multiply_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply();\n    return expanding = prev_expanding;\n  };\n\n  // multiply n factors on stack\n\n  // n an integer\n  multiply_all = function(n) {\n    var h, i, o, ref;\n    i = 0;\n    if (n === 1) {\n      return;\n    }\n    if (n === 0) {\n      push(evaluatingAsFloats ? one_as_double : one);\n      return;\n    }\n    h = tos - n;\n    push(stack[h]);\n    for (i = o = 1, ref = n; (1 <= ref ? o < ref : o > ref); i = 1 <= ref ? ++o : --o) {\n      push(stack[h + i]);\n      multiply();\n    }\n    stack[h] = pop();\n    return moveTos(h + 1);\n  };\n\n  // n an integer\n  multiply_all_noexpand = function(n) {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    multiply_all(n);\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Symbolic division, or numeric division if doubles are found.\n\n  //  Input:    Dividend and divisor on stack\n\n  //  Output:    Quotient on stack\n\n  //-----------------------------------------------------------------------------\n  divide = function() {\n    if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return divide_numbers();\n    } else {\n      inverse();\n      return multiply();\n    }\n  };\n\n  // this is different from inverse of a matrix (inv)!\n  inverse = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return invert_number();\n    } else {\n      push_integer(-1);\n      return power();\n    }\n  };\n\n  reciprocate = function() {\n    return inverse();\n  };\n\n  negate = function() {\n    if (isNumericAtom(stack[tos - 1])) {\n      return negate_number();\n    } else {\n      if (evaluatingAsFloats) {\n        push_double(-1.0);\n      } else {\n        push_integer(-1);\n      }\n      return multiply();\n    }\n  };\n\n  negate_expand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 1;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  negate_noexpand = function() {\n    var prev_expanding;\n    prev_expanding = expanding;\n    expanding = 0;\n    negate();\n    return expanding = prev_expanding;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize radical factors\n\n  //  Input:    stack[h]  Coefficient factor, possibly 1\n\n  //      stack[h + 1]  Second factor\n\n  //      stack[tos - 1]  Last factor\n\n  //  Output:    Reduced coefficent and normalized radicals (maybe)\n\n  //  Example:  2*2^(-1/2) -> 2^(1/2)\n\n  //  (power number number) is guaranteed to have the following properties:\n\n  //  1. Base is an integer\n\n  //  2. Absolute value of exponent < 1\n\n  //  These properties are assured by the power function.\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define B p2\n\n  //define BASE p3\n  //define EXPO p4\n\n  //define TMP p5\n\n  // h is an int\n  __normalize_radical_factors = function(h) {\n    var i, i1, j1, o, ref, ref1, ref2, ref3, ref4, ref5;\n    i = 0;\n    // if coeff is 1 or floating then don't bother\n    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {\n      return;\n    }\n// if no radicals then don't bother\n    for (i = o = ref = h + 1, ref1 = tos; (ref <= ref1 ? o < ref1 : o > ref1); i = ref <= ref1 ? ++o : --o) {\n      if (__is_radical_number(stack[i])) {\n        break;\n      }\n    }\n    if (i === tos) {\n      return;\n    }\n    // ok, try to simplify\n    save();\n    // numerator\n    push(stack[h]);\n    mp_numerator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors numerator: \" + stack[tos - 1]);\n    }\n    p1 = pop();\n    for (i = i1 = ref2 = h + 1, ref3 = tos; (ref2 <= ref3 ? i1 < ref3 : i1 > ref3); i = ref2 <= ref3 ? ++i1 : --i1) {\n      if (isplusone(p1) || isminusone(p1)) { // p1 is A\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (!isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // numerator divisible by p3 (base)?\n      push(p1);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      // reduce numerator\n      p1 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(evaluatingAsFloats ? one_as_double : one);\n      push(p4);\n      add();\n      list(3);\n      stack[i] = pop();\n    }\n    // denominator\n    push(stack[h]);\n    mp_denominator();\n    if (DEBUG_MULTIPLY) {\n      console.log(\"__normalize_radical_factors denominator: \" + stack[tos - 1]);\n    }\n    p2 = pop();\n    for (i = j1 = ref4 = h + 1, ref5 = tos; (ref4 <= ref5 ? j1 < ref5 : j1 > ref5); i = ref4 <= ref5 ? ++j1 : --j1) {\n      if (isplusone(p2)) { // p2 is B\n        break;\n      }\n      if (!__is_radical_number(stack[i])) {\n        continue;\n      }\n      p3 = cadr(stack[i]);\n      p4 = caddr(stack[i]);\n      if (isnegativenumber(p4)) { //p4 is EXPO\n        continue;\n      }\n      // denominator divisible by p3? #p3 is BASE\n      push(p2);\n      push(p3);\n      divide();\n      p5 = pop();\n      if (!isinteger(p5)) { //p5 is TMP\n        continue;\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p5: \" + p5.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical top stack: \" + stack[tos - 1]);\n      }\n      // reduce denominator\n      p2 = p5;\n      push_symbol(POWER);\n      push(p3);\n      push(p4);\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p3: \" + p3.toString());\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical p4: \" + p4.toString());\n      }\n      push(one);\n      subtract();\n      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {\n        if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {\n          // bail out,\n          // we want to avoid going ahead with the subtraction of\n          // the exponents, because that would turn a perfectly good\n          // integer exponent in the denominator into a fractional one\n          // i.e. a radical.\n          // Note that this only prevents new radicals ending up\n          // in the denominator, it doesn't fix existing ones.\n          pop();\n          pop();\n          pop();\n          push(p1);\n          push(p3);\n          divide();\n          p1 = pop();\n          break;\n        }\n      }\n      if (DEBUG_MULTIPLY) {\n        console.log(\"__new radical exponent: \" + stack[tos - 1]);\n      }\n      list(3);\n      stack[i] = pop();\n    }\n    // reconstitute the coefficient\n    push(p1);\n    push(p2);\n    divide();\n    stack[h] = pop();\n    return restore();\n  };\n\n  // don't include i\n  // p is a U\n  // TODO should this be in is.coffee ?\n  __is_radical_number = function(p) {\n    // don't use i\n    return car(p) === symbol(POWER) && isNumericAtom(cadr(p)) && isfraction(caddr(p)) && !isminusone(cadr(p));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  > a*hilbert(2)\n  //  ((a,1/2*a),(1/2*a,1/3*a))\n\n  //  Note that \"a\" is presumed to be a scalar. Is this correct?\n\n  //  Yes, because \"*\" has no meaning if \"a\" is a tensor.\n  //  To multiply tensors, \"dot\" or \"outer\" should be used.\n\n  //  > dot(a,hilbert(2))\n  //  dot(a,((1,1/2),(1/2,1/3)))\n\n  //  In this case \"a\" could be a scalar or tensor so the result is not\n  //  expanded.\n\n  //-----------------------------------------------------------------------------\n\n  // find the roots of a polynomial numerically\n  NROOTS_YMAX = 101;\n\n  NROOTS_DELTA = 1.0e-6;\n\n  NROOTS_EPSILON = 1.0e-9;\n\n  NROOTS_ABS = function(z) {\n    return Math.sqrt(z.r * z.r + z.i * z.i);\n  };\n\n  // random between -2 and 2\n  theRandom = 0.0;\n\n  NROOTS_RANDOM = function() {\n    //theRandom += 0.2\n    //return theRandom\n    return 4.0 * Math.random() - 2.0;\n  };\n\n  numericRootOfPolynomial = (function() {\n    class numericRootOfPolynomial {};\n\n    numericRootOfPolynomial.prototype.r = 0.0;\n\n    numericRootOfPolynomial.prototype.i = 0.0;\n\n    return numericRootOfPolynomial;\n\n  }).call(this);\n\n  nroots_a = new numericRootOfPolynomial();\n\n  nroots_b = new numericRootOfPolynomial();\n\n  nroots_x = new numericRootOfPolynomial();\n\n  nroots_y = new numericRootOfPolynomial();\n\n  nroots_fa = new numericRootOfPolynomial();\n\n  nroots_fb = new numericRootOfPolynomial();\n\n  nroots_dx = new numericRootOfPolynomial();\n\n  nroots_df = new numericRootOfPolynomial();\n\n  nroots_c = [];\n\n  for (initNRoots = o = 0, ref = NROOTS_YMAX; (0 <= ref ? o < ref : o > ref); initNRoots = 0 <= ref ? ++o : --o) {\n    nroots_c[initNRoots] = new numericRootOfPolynomial();\n  }\n\n  Eval_nroots = function() {\n    var h, i, i1, j1, k, l1, n, ref1, ref2, ref3;\n    h = 0;\n    i = 0;\n    k = 0;\n    n = 0;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"nroots: polynomial?\");\n    }\n    // mark the stack\n    h = tos;\n    // get the coefficients\n    n = coeff(p2, p1);\n    if (n > NROOTS_YMAX) {\n      stop(\"nroots: degree?\");\n    }\n// convert the coefficients to real and imaginary doubles\n    for (i = i1 = 0, ref1 = n; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      push(stack[h + i]);\n      real();\n      yyfloat();\n      Eval();\n      p1 = pop();\n      push(stack[h + i]);\n      imag();\n      yyfloat();\n      Eval();\n      p2 = pop();\n      if (!isdouble(p1) || !isdouble(p2)) {\n        stop(\"nroots: coefficients?\");\n      }\n      nroots_c[i].r = p1.d;\n      nroots_c[i].i = p2.d;\n    }\n    // pop the coefficients\n    moveTos(h);\n    // n is the number of coefficients, n = deg(p) + 1\n    monic(n);\n    for (k = j1 = ref2 = n; j1 > 1; k = j1 += -1) {\n      findroot(k);\n      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {\n        nroots_a.r = 0.0;\n      }\n      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {\n        nroots_a.i = 0.0;\n      }\n      push_double(nroots_a.r);\n      push_double(nroots_a.i);\n      push(imaginaryunit);\n      multiply();\n      add();\n      NROOTS_divpoly(k);\n    }\n    // now make n equal to the number of roots\n    n = tos - h;\n    if (n > 1) {\n      sort_stack(n);\n      p1 = alloc_tensor(n);\n      p1.tensor.ndim = 1;\n      p1.tensor.dim[0] = n;\n      for (i = l1 = 0, ref3 = n; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n        p1.tensor.elem[i] = stack[h + i];\n      }\n      moveTos(h);\n      return push(p1);\n    }\n  };\n\n  // divide the polynomial by its leading coefficient\n  monic = function(n) {\n    var i1, k, ref1, t;\n    k = 0;\n    t = 0.0;\n    nroots_y.r = nroots_c[n - 1].r;\n    nroots_y.i = nroots_c[n - 1].i;\n    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;\n    for (k = i1 = 0, ref1 = n - 1; (0 <= ref1 ? i1 < ref1 : i1 > ref1); k = 0 <= ref1 ? ++i1 : --i1) {\n      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;\n      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;\n    }\n    nroots_c[n - 1].r = 1.0;\n    return nroots_c[n - 1].i = 0.0;\n  };\n\n  // uses the secant method\n  findroot = function(n) {\n    var i1, j, j1, k, nrabs, t;\n    j = 0;\n    k = 0;\n    t = 0.0;\n    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {\n      nroots_a.r = 0.0;\n      nroots_a.i = 0.0;\n      return;\n    }\n    for (j = i1 = 0; i1 < 100; j = ++i1) {\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      compute_fa(n);\n      nroots_b.r = nroots_a.r;\n      nroots_b.i = nroots_a.i;\n      nroots_fb.r = nroots_fa.r;\n      nroots_fb.i = nroots_fa.i;\n      nroots_a.r = NROOTS_RANDOM();\n      nroots_a.i = NROOTS_RANDOM();\n      for (k = j1 = 0; j1 < 1000; k = ++j1) {\n        compute_fa(n);\n        nrabs = NROOTS_ABS(nroots_fa);\n        if (DEBUG) {\n          console.log(\"nrabs: \" + nrabs);\n        }\n        if (nrabs < NROOTS_EPSILON) {\n          return;\n        }\n        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {\n          nroots_x.r = nroots_a.r;\n          nroots_x.i = nroots_a.i;\n          nroots_a.r = nroots_b.r;\n          nroots_a.i = nroots_b.i;\n          nroots_b.r = nroots_x.r;\n          nroots_b.i = nroots_x.i;\n          nroots_x.r = nroots_fa.r;\n          nroots_x.i = nroots_fa.i;\n          nroots_fa.r = nroots_fb.r;\n          nroots_fa.i = nroots_fb.i;\n          nroots_fb.r = nroots_x.r;\n          nroots_fb.i = nroots_x.i;\n        }\n        // dx = nroots_b - nroots_a\n        nroots_dx.r = nroots_b.r - nroots_a.r;\n        nroots_dx.i = nroots_b.i - nroots_a.i;\n        // df = fb - fa\n        nroots_df.r = nroots_fb.r - nroots_fa.r;\n        nroots_df.i = nroots_fb.i - nroots_fa.i;\n        // y = dx / df\n        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;\n        if (t === 0.0) {\n          break;\n        }\n        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;\n        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;\n        // a = b - y * fb\n        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);\n        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);\n      }\n    }\n    return stop(\"nroots: convergence error\");\n  };\n\n  compute_fa = function(n) {\n    var i1, k, ref1, results, t;\n    k = 0;\n    t = 0.0;\n    // x = a\n    nroots_x.r = nroots_a.r;\n    nroots_x.i = nroots_a.i;\n    // fa = c0 + c1 * x\n    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;\n    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;\n    results = [];\n    for (k = i1 = 2, ref1 = n; (2 <= ref1 ? i1 < ref1 : i1 > ref1); k = 2 <= ref1 ? ++i1 : --i1) {\n      // x = a * x\n      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;\n      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;\n      nroots_x.r = t;\n      // fa += c[k] * x\n      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;\n      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);\n    }\n    return results;\n  };\n\n  // divide the polynomial by x - a\n  NROOTS_divpoly = function(n) {\n    var i1, j1, k, ref1, ref2, results;\n    k = 0;\n    for (k = i1 = ref1 = n - 1; (ref1 <= 0 ? i1 < 0 : i1 > 0); k = ref1 <= 0 ? ++i1 : --i1) {\n      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;\n      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;\n    }\n    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {\n      stop(\"nroots: residual error\");\n    }\n    results = [];\n    for (k = j1 = 0, ref2 = n - 1; (0 <= ref2 ? j1 < ref2 : j1 > ref2); k = 0 <= ref2 ? ++j1 : --j1) {\n      nroots_c[k].r = nroots_c[k + 1].r;\n      results.push(nroots_c[k].i = nroots_c[k + 1].i);\n    }\n    return results;\n  };\n\n  Eval_numerator = function() {\n    push(cadr(p1));\n    Eval();\n    return numerator();\n  };\n\n  numerator = function() {\n    var h, theArgument;\n    h = 0;\n    theArgument = pop();\n    if (car(theArgument) === symbol(ADD)) {\n      push(theArgument);\n      //console.trace \"rationalising \"\n      rationalize();\n      theArgument = pop();\n    }\n    //console.log \"rationalised: \" + theArgument\n    if (car(theArgument) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument)))) {\n      h = tos;\n      theArgument = cdr(theArgument);\n      //console.log \"theArgument inside multiply: \" + theArgument\n      //console.log \"first term: \" + car(theArgument)\n      while (iscons(theArgument)) {\n        push(car(theArgument));\n        numerator();\n        theArgument = cdr(theArgument);\n      }\n      return multiply_all(tos - h);\n    } else if (isrational(theArgument)) {\n      push(theArgument);\n      return mp_numerator();\n    } else if (car(theArgument) === symbol(POWER) && isnegativeterm(caddr(theArgument))) {\n      return push(one);\n    } else {\n      return push(theArgument);\n    }\n  };\n\n  // Outer product of tensors\n  Eval_outer = function() {\n    var results;\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p1 = cdr(p1);\n    results = [];\n    while (iscons(p1)) {\n      push(car(p1));\n      Eval();\n      outer();\n      results.push(p1 = cdr(p1));\n    }\n    return results;\n  };\n\n  outer = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1) && istensor(p2)) {\n      yyouter();\n    } else {\n      push(p1);\n      push(p2);\n      if (istensor(p1)) {\n        tensor_times_scalar();\n      } else if (istensor(p2)) {\n        scalar_times_tensor();\n      } else {\n        multiply();\n      }\n    }\n    return restore();\n  };\n\n  yyouter = function() {\n    var i, i1, j, j1, k, l1, m1, ndim, nelem, ref1, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    k = 0;\n    ndim = 0;\n    nelem = 0;\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"outer: rank of result exceeds maximum\");\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = i1 = 0, ref1 = p1.tensor.ndim; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    j = i;\n    for (i = j1 = 0, ref2 = p2.tensor.ndim; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      p3.tensor.dim[j + i] = p2.tensor.dim[i];\n    }\n    k = 0;\n    for (i = l1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      for (j = m1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? m1 < ref4 : m1 > ref4); j = 0 <= ref4 ? ++m1 : --m1) {\n        push(p1.tensor.elem[i]);\n        push(p2.tensor.elem[j]);\n        multiply();\n        p3.tensor.elem[k++] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  partition = function() {\n    save();\n    p2 = pop();\n    p1 = pop();\n    push_integer(1);\n    p3 = pop();\n    p4 = p3;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      if (Find(car(p1), p2)) {\n        push(p4);\n        push(car(p1));\n        multiply();\n        p4 = pop();\n      } else {\n        push(p3);\n        push(car(p1));\n        multiply();\n        p3 = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push(p3);\n    push(p4);\n    return restore();\n  };\n\n  /*\n    Add a pattern i.e. a substitution rule.\n    Substitution rule needs a template as first argument\n    and what to transform it to as second argument.\n    Optional third argument is a boolean test which\n    adds conditions to when the rule is applied.\n  */\n  // same as Eval_pattern but only leaves\n  // NIL on stack at return, hence gives no\n  // printout\n  Eval_silentpattern = function() {\n    Eval_pattern();\n    pop();\n    return push_symbol(NIL);\n  };\n\n  Eval_pattern = function() {\n    var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;\n    if (!iscons(cdr(p1))) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    firstArgument = car(cdr(p1));\n    secondArgument = car(cdr(cdr(p1)));\n    if (secondArgument === symbol(NIL)) {\n      stop(\"pattern needs at least a template and a transformed version\");\n    }\n    if (!iscons(cdr(cdr(p1)))) {\n      thirdArgument = symbol(NIL);\n    } else {\n      thirdArgument = car(cdr(cdr(cdr(p1))));\n    }\n    if (equal(firstArgument, secondArgument)) {\n      stop(\"recursive pattern\");\n    }\n    // console.log \"Eval_pattern of \" + cdr(p1)\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    stringKey = \"template: \" + print_list(firstArgument);\n    stringKey += \" tests: \" + print_list(thirdArgument);\n    if (DEBUG) {\n      console.log(\"pattern stringkey: \" + stringKey);\n    }\n    patternPosition = userSimplificationsInStringForm.indexOf(stringKey);\n    // if pattern is not there yet, add it, otherwise replace it\n    if (patternPosition === -1) {\n      //console.log \"adding pattern because it doesn't exist: \" + cdr(p1)\n      userSimplificationsInStringForm.push(stringKey);\n      userSimplificationsInListForm.push(cdr(p1));\n    } else {\n      if (DEBUG) {\n        console.log(\"pattern already exists, replacing. \" + cdr(p1));\n      }\n      userSimplificationsInStringForm[patternPosition] = stringKey;\n      userSimplificationsInListForm[patternPosition] = cdr(p1);\n    }\n    // return the pattern node itself so we can\n    // give some printout feedback\n    push_symbol(PATTERN);\n    push(cdr(p1));\n    return list(2);\n  };\n\n  do_clearPatterns = function() {\n    userSimplificationsInListForm = [];\n    return userSimplificationsInStringForm = [];\n  };\n\n  Eval_clearpatterns = function() {\n    // this is likely to create garbage collection\n    // problems in the C version as it's an\n    // untracked reference\n    do_clearPatterns();\n    \n    // return nothing\n    return push_symbol(NIL);\n  };\n\n  Eval_patternsinfo = function() {\n    var patternsinfoToBePrinted;\n    patternsinfoToBePrinted = patternsinfo();\n    if (patternsinfoToBePrinted !== \"\") {\n      return push(new_string(patternsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  patternsinfo = function() {\n    var i, i1, len, patternsinfoToBePrinted;\n    patternsinfoToBePrinted = \"\";\n    for (i1 = 0, len = userSimplificationsInListForm.length; i1 < len; i1++) {\n      i = userSimplificationsInListForm[i1];\n      patternsinfoToBePrinted += userSimplificationsInListForm + \"\\n\";\n    }\n    return patternsinfoToBePrinted;\n  };\n\n  Eval_polar = function() {\n    push(cadr(p1));\n    Eval();\n    return polar();\n  };\n\n  polar = function() {\n    // there are points where we turn polar\n    // representations into rect, we set a \"stack flag\"\n    // here to avoid that, so we don't undo the\n    // work that we are trying to do.\n    evaluatingPolar++;\n    save();\n    p1 = pop();\n    push(p1);\n    abs();\n    push(imaginaryunit);\n    push(p1);\n    arg();\n    multiply();\n    exponential();\n    multiply();\n    evaluatingPolar--;\n    return restore();\n  };\n\n  // Factor using the Pollard rho method\n  n_factor_number = 0;\n\n  factor_number = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    // 0 or 1?\n    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    n_factor_number = p1.q.a;\n    h = tos;\n    factor_a();\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      cons();\n    }\n    return restore();\n  };\n\n  // factor using table look-up, then switch to rho method if necessary\n\n  // From TAOCP Vol. 2 by Knuth, p. 380 (Algorithm A)\n  factor_a = function() {\n    var i1, k;\n    k = 0;\n    if (n_factor_number.isNegative()) {\n      n_factor_number = setSignTo(n_factor_number, 1);\n      push_integer(-1);\n    }\n    for (k = i1 = 0; i1 < 10000; k = ++i1) {\n      try_kth_prime(k);\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        return;\n      }\n    }\n    return factor_b();\n  };\n\n  try_kth_prime = function(k) {\n    var count, d, q, r;\n    count = 0;\n    d = mint(primetab[k]);\n    count = 0;\n    while (1) {\n      // if n_factor_number is 1 then we're done\n      if (n_factor_number.compare(1) === 0) {\n        if (count) {\n          push_factor(d, count);\n        }\n        return;\n      }\n      [q, r] = mdivrem(n_factor_number, d);\n      // continue looping while remainder is zero\n      if (r.isZero()) {\n        count++;\n        n_factor_number = q;\n      } else {\n        break;\n      }\n    }\n    if (count) {\n      push_factor(d, count);\n    }\n    // q = n_factor_number/d, hence if q < d then\n    // n_factor_number < d^2 so n_factor_number is prime\n    if (mcmp(q, d) === -1) {\n      push_factor(n_factor_number, 1);\n      return n_factor_number = mint(1);\n    }\n  };\n\n  // From TAOCP Vol. 2 by Knuth, p. 385 (Algorithm B)\n  factor_b = function() {\n    var bigint_one, g, k, l, t, x, xprime;\n    k = 0;\n    l = 0;\n    bigint_one = mint(1);\n    x = mint(5);\n    xprime = mint(2);\n    k = 1;\n    l = 1;\n    while (1) {\n      if (mprime(n_factor_number)) {\n        push_factor(n_factor_number, 1);\n        return 0;\n      }\n      while (1) {\n        if (esc_flag) {\n          stop(\"esc\");\n        }\n        // g = gcd(x' - x, n_factor_number)\n        t = msub(xprime, x);\n        t = setSignTo(t, 1);\n        g = mgcd(t, n_factor_number);\n        if (MEQUAL(g, 1)) {\n          if (--k === 0) {\n            xprime = x;\n            l *= 2;\n            k = l;\n          }\n          // x = (x ^ 2 + 1) mod n_factor_number\n          t = mmul(x, x);\n          x = madd(t, bigint_one);\n          t = mmod(x, n_factor_number);\n          x = t;\n          continue;\n        }\n        push_factor(g, 1);\n        if (mcmp(g, n_factor_number) === 0) {\n          return -1;\n        }\n        // n_factor_number = n_factor_number / g\n        t = mdiv(n_factor_number, g);\n        n_factor_number = t;\n        // x = x mod n_factor_number\n        t = mmod(x, n_factor_number);\n        x = t;\n        // xprime = xprime mod n_factor_number\n        t = mmod(xprime, n_factor_number);\n        xprime = t;\n        break;\n      }\n    }\n  };\n\n  push_factor = function(d, count) {\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = d;\n    p1.q.b = mint(1);\n    push(p1);\n    if (count > 1) {\n      push_symbol(POWER);\n      swap();\n      p1 = new U();\n      p1.k = NUM;\n      p1.q.a = mint(count);\n      p1.q.b = mint(1);\n      push(p1);\n      return list(3);\n    }\n  };\n\n  DEBUG_POWER = false;\n\n  Eval_power = function() {\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    return power();\n  };\n\n  power = function() {\n    save();\n    yypower();\n    return restore();\n  };\n\n  yypower = function() {\n    var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n;\n    if (DEBUG_POWER) {\n      debugger;\n    }\n    n = 0;\n    p2 = pop(); // exponent\n    p1 = pop(); // base\n    inputExp = p2;\n    inputBase = p1;\n    //debugger\n    if (DEBUG_POWER) {\n      console.log(\"POWER: \" + p1 + \" ^ \" + p2);\n    }\n    // first, some very basic simplifications right away\n\n    //  1 ^ a    ->  1\n    //  a ^ 0    ->  1\n    if (equal(p1, one) || isZeroAtomOrTensor(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  a ^ 1    ->  a\n    if (equal(p2, one)) {\n      push(p1);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1    ->  -1\n    if (isminusone(p1) && isminusone(p2)) {\n      if (evaluatingAsFloats) {\n        push_double(1.0);\n      } else {\n        push(one);\n      }\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ 1/2  ->  i\n    if (isminusone(p1) && (isoneovertwo(p2))) {\n      push(imaginaryunit);\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ -1/2  ->  -i\n    if (isminusone(p1) && isminusoneovertwo(p2)) {\n      push(imaginaryunit);\n      negate();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //   -1 ^ rational\n    if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: -1 ^ rational\");\n      }\n      if (DEBUG_POWER) {\n        console.log(\" trick: p2.q.a , p2.q.b \" + p2.q.a + \" , \" + p2.q.b);\n      }\n      if (p2.q.a < p2.q.b) {\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n      } else {\n        push_symbol(MULTIPLY);\n        push(p1);\n        push_symbol(POWER);\n        push(p1);\n        push_rational(p2.q.a.mod(p2.q.b), p2.q.b);\n        list(3);\n        list(3);\n        if (DEBUG_POWER) {\n          console.log(\" trick applied : \" + stack[tos - 1]);\n        }\n      }\n      // evaluates clock form into\n      // rectangular form. This seems to give\n      // slightly better form to some test results.\n      rect();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are rational numbers?\n    if (isrational(p1) && isrational(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: isrational(p1) && isrational(p2)\");\n      }\n      push(p1);\n      push(p2);\n      qpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // both base and exponent are either rational or double?\n    if (isNumericAtom(p1) && isNumericAtom(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: both base and exponent are either rational or double \");\n      }\n      if (DEBUG_POWER) {\n        console.log(\"POWER - isNumericAtom(p1) && isNumericAtom(p2)\");\n      }\n      push(p1);\n      push(p2);\n      dpow();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    if (istensor(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: istensor(p1) \");\n      }\n      power_tensor();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // if we only assume variables to be real, then |a|^2 = a^2\n    // (if x is complex this doesn't hold e.g. i, which makes 1 and -1\n    if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: even power of absolute of real value \");\n      }\n      push(cadr(p1));\n      push(p2);\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^log(...)\n    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {\n      push(cadr(p2));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // e^some_float\n    if (p1 === symbol(E) && isdouble(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: p1 == symbol(E) && isdouble(p2) \");\n      }\n      push_double(Math.exp(p2.d));\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number in exponential form, get it to rectangular\n    // but only if we are not in the process of calculating a polar form,\n    // otherwise we'd just undo the work we want to do\n    if (p1 === symbol(E) && Find(p2, imaginaryunit) !== 0 && Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      if (DEBUG_POWER) {\n        console.log(\"   power: turning complex exponential to rect: \" + stack[tos - 1]);\n      }\n      rect();\n      hopefullySimplified = pop();\n      if (Find(hopefullySimplified, symbol(PI)) === 0) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: turned complex exponential to rect: \" + hopefullySimplified);\n        }\n        push(hopefullySimplified);\n        return;\n      }\n    }\n    //  (a * b) ^ c  ->  (a ^ c) * (b ^ c)\n    // note that we can't in general do this, for example\n    // sqrt(x*y) != x^(1/2) y^(1/2) (counterexample\" x = -1 and y = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n    if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) \");\n      }\n      p1 = cdr(p1);\n      push(car(p1));\n      push(p2);\n      power();\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        power();\n        multiply();\n        p1 = cdr(p1);\n      }\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // (a ^ b) ^ c  ->  a ^ (b * c)\n    // note that we can't in general do this, for example\n    // sqrt(x^y) !=  x^(1/2 y) (counterexample x = -1)\n    // BUT we can carve-out here some cases where this\n    // transformation is correct\n\n    // simple numeric check to see if a is a number > 0\n    is_a_moreThanZero = false;\n    if (isNumericAtom(cadr(p1))) {\n      is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));\n    }\n    if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) { // when a is >= 0\n      push(cadr(p1));\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    b_isEven_and_c_isItsInverse = false;\n    if (iseveninteger(caddr(p1))) {\n      push(caddr(p1));\n      push(p2);\n      multiply();\n      isThisOne = pop();\n      if (isone(isThisOne)) {\n        b_isEven_and_c_isItsInverse = true;\n      }\n    }\n    if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse \");\n      }\n      push(cadr(p1));\n      abs();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  when expanding,\n    //  (a + b) ^ n  ->  (a + b) * (a + b) ...\n    if (expanding && isadd(p1) && isNumericAtom(p2)) {\n      push(p2);\n      n = pop_integer();\n      if (n > 1 && !isNaN(n)) {\n        if (DEBUG_POWER) {\n          console.log(\"   power: expanding && isadd(p1) && isNumericAtom(p2) \");\n        }\n        power_sum(n);\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    //  sin(x) ^ 2n -> (1 - cos(x) ^ 2) ^ n\n    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      cosine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    //  cos(x) ^ 2n -> (1 - sin(x) ^ 2) ^ n\n    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) \");\n      }\n      push_integer(1);\n      push(cadr(p1));\n      sine();\n      push_integer(2);\n      power();\n      subtract();\n      push(p2);\n      push_rational(1, 2);\n      multiply();\n      power();\n      if (DEBUG_POWER) {\n        console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n      }\n      return;\n    }\n    // complex number? (just number, not expression)\n    if (iscomplexnumber(p1)) {\n      if (DEBUG_POWER) {\n        console.log(\" power - handling the case (a + ib) ^ n\");\n      }\n      // integer power?\n\n      // n will be negative here, positive n already handled\n      if (isinteger(p2)) {\n        //               /        \\  n\n        //         -n   |  a - ib  |\n        // (a + ib)   = | -------- |\n        //              |   2   2  |\n        //               \\ a + b  /\n        push(p1);\n        conjugate();\n        p3 = pop();\n        push(p3);\n        // gets the denominator\n        push(p3);\n        push(p1);\n        multiply();\n        divide();\n        if (!isone(p2)) {\n          push(p2);\n          negate();\n          power();\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n      // noninteger or floating power?\n      if (isNumericAtom(p2)) {\n        push(p1);\n        abs();\n        push(p2);\n        power();\n        push_integer(-1);\n        push(p1);\n        arg();\n        push(p2);\n        multiply();\n        if (evaluatingAsFloats || (iscomplexnumberdouble(p1) && isdouble(p2))) {\n          // remember that the \"double\" type is\n          // toxic, i.e. it propagates, so we do\n          // need to evaluate PI to its actual double\n          // value\n          push_double(Math.PI);\n        } else {\n          //console.log(\"power pushing PI when p1 is: \" + p1 + \" and p2 is:\" + p2)\n          push(symbol(PI));\n        }\n        divide();\n        power();\n        multiply();\n        // if we calculate the power making use of arctan:\n        //  * it prevents nested radicals from being simplified\n        //  * results become really hard to manipulate afterwards\n        //  * we can't go back to other forms.\n        // so leave the power as it is.\n        if (avoidCalculatingPowersIntoArctans) {\n          if (Find(stack[tos - 1], symbol(ARCTAN))) {\n            pop();\n            push_symbol(POWER);\n            push(p1);\n            push(p2);\n            list(3);\n          }\n        }\n        if (DEBUG_POWER) {\n          console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n        }\n        return;\n      }\n    }\n    \n    //push(p1)\n    //abs()\n    //push(p2)\n    //power()\n    //push(symbol(E))\n    //push(p1)\n    //arg()\n    //push(p2)\n    //multiply()\n    //push(imaginaryunit)\n    //multiply()\n    //power()\n    //multiply()\n\n    if (simplify_polar()) {\n      if (DEBUG_POWER) {\n        console.log(\"   power: using simplify_polar\");\n      }\n      return;\n    }\n    if (DEBUG_POWER) {\n      console.log(\"   power: nothing can be done \");\n    }\n    push_symbol(POWER);\n    push(p1);\n    push(p2);\n    list(3);\n    if (DEBUG_POWER) {\n      return console.log(\"   power of \" + inputBase + \" ^ \" + inputExp + \": \" + stack[tos - 1]);\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute the power of a sum\n\n  //  Input:    p1  sum\n\n  //      n  exponent\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses the multinomial series (see Math World)\n\n  //                          n              n!          n1   n2       nk\n  //  (a1 + a2 + ... + ak)  = sum (--------------- a1   a2   ... ak  )\n  //                               n1! n2! ... nk!\n\n  //  The sum is over all n1 ... nk such that n1 + n2 + ... + nk = n.\n\n  //-----------------------------------------------------------------------------\n\n  // first index is the term number 0..k-1, second index is the exponent 0..n\n\n  //define A(i, j) frame[(i) * (n + 1) + (j)]\n  power_sum = function(n) {\n    var a, i, i1, j, j1, k, l1, ref1, ref2, ref3;\n    a = [];\n    i = 0;\n    j = 0;\n    k = 0;\n    // number of terms in the sum\n    k = length(p1) - 1;\n    // local frame\n    push_frame(k * (n + 1));\n    // array of powers\n    p1 = cdr(p1);\n    for (i = i1 = 0, ref1 = k; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n      for (j = j1 = 0, ref2 = n; (0 <= ref2 ? j1 <= ref2 : j1 >= ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n        push(car(p1));\n        push_integer(j);\n        power();\n        stack[frame + i * (n + 1) + j] = pop();\n      }\n      p1 = cdr(p1);\n    }\n    push_integer(n);\n    factorial();\n    p1 = pop();\n    for (i = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n      a[i] = 0;\n    }\n    push(zero);\n    multinomial_sum(k, n, a, 0, n);\n    return pop_frame(k * (n + 1));\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Compute multinomial sum\n\n  //  Input:    k  number of factors\n\n  //      n  overall exponent\n\n  //      a  partition array\n\n  //      i  partition array index\n\n  //      m  partition remainder\n\n  //      p1  n!\n\n  //      A  factor array\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  Uses recursive descent to fill the partition array.\n\n  //-----------------------------------------------------------------------------\n\n  //int k, int n, int *a, int i, int m\n  multinomial_sum = function(k, n, a, i, m) {\n    var i1, j, j1, l1, ref1, ref2, ref3;\n    j = 0;\n    if (i < k - 1) {\n      for (j = i1 = 0, ref1 = m; (0 <= ref1 ? i1 <= ref1 : i1 >= ref1); j = 0 <= ref1 ? ++i1 : --i1) {\n        a[i] = j;\n        multinomial_sum(k, n, a, i + 1, m - j);\n      }\n      return;\n    }\n    a[i] = m;\n    // coefficient\n    push(p1);\n    for (j = j1 = 0, ref2 = k; (0 <= ref2 ? j1 < ref2 : j1 > ref2); j = 0 <= ref2 ? ++j1 : --j1) {\n      push_integer(a[j]);\n      factorial();\n      divide();\n    }\n// factors\n    for (j = l1 = 0, ref3 = k; (0 <= ref3 ? l1 < ref3 : l1 > ref3); j = 0 <= ref3 ? ++l1 : --l1) {\n      push(stack[frame + j * (n + 1) + a[j]]);\n      multiply();\n    }\n    return add();\n  };\n\n  // exp(n/2 i pi) ?\n\n  // p2 is the exponent expression\n\n  // clobbers p3\n  simplify_polar = function() {\n    var doNothing, n;\n    n = 0;\n    n = isquarterturn(p2);\n    switch (n) {\n      case 0:\n        doNothing = 1;\n        break;\n      case 1:\n        push_integer(1);\n        return 1;\n      case 2:\n        push_integer(-1);\n        return 1;\n      case 3:\n        push(imaginaryunit);\n        return 1;\n      case 4:\n        push(imaginaryunit);\n        negate();\n        return 1;\n    }\n    if (car(p2) === symbol(ADD)) {\n      p3 = cdr(p2);\n      while (iscons(p3)) {\n        n = isquarterturn(car(p3));\n        if (n) {\n          break;\n        }\n        p3 = cdr(p3);\n      }\n      switch (n) {\n        case 0:\n          return 0;\n        case 1:\n          push_integer(1);\n          break;\n        case 2:\n          push_integer(-1);\n          break;\n        case 3:\n          push(imaginaryunit);\n          break;\n        case 4:\n          push(imaginaryunit);\n          negate();\n      }\n      push(p2);\n      push(car(p3));\n      subtract();\n      exponential();\n      multiply();\n      return 1;\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Look up the nth prime\n\n  //  Input:    n on stack (0 < n < 10001)\n\n  //  Output:    nth prime on stack\n\n  //-----------------------------------------------------------------------------\n  Eval_prime = function() {\n    push(cadr(p1));\n    Eval();\n    return prime();\n  };\n\n  prime = function() {\n    var n;\n    n = 0;\n    n = pop_integer();\n    if (n < 1 || n > MAXPRIMETAB) {\n      stop(\"prime: Argument out of range.\");\n    }\n    n = primetab[n - 1];\n    return push_integer(n);\n  };\n\n  power_str = \"^\";\n\n  codeGen = false;\n\n  // this is only invoked when user invokes\n  // \"print\" explicitly\n  Eval_print = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"print2dascii\" explicitly\n  Eval_print2dascii = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printcomputer\" explicitly\n  Eval_printcomputer = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlatex\" explicitly\n  Eval_printlatex = function() {\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printhuman\" explicitly\n  Eval_printhuman = function() {\n    var original_test_flag;\n    // test flag needs to be suspended\n    // because otherwise \"printcomputer\" mode\n    // will happen.\n    original_test_flag = test_flag;\n    test_flag = 0;\n    stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);\n    test_flag = original_test_flag;\n    return push(symbol(NIL));\n  };\n\n  // this is only invoked when user invokes\n  // \"printlist\" explicitly\n  Eval_printlist = function() {\n    var beenPrinted;\n    beenPrinted = _print(cdr(p1), PRINTMODE_LIST);\n    stringsEmittedByUserPrintouts += beenPrinted;\n    return push(symbol(NIL));\n  };\n\n  _print = function(p, passedPrintMode) {\n    var accumulator, origPrintMode;\n    accumulator = \"\";\n    while (iscons(p)) {\n      push(car(p));\n      Eval();\n      p2 = pop();\n      origPrintMode = printMode;\n      if (passedPrintMode === PRINTMODE_COMPUTER) {\n        printMode = PRINTMODE_COMPUTER;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_FULL_PRINT);\n      } else if (passedPrintMode === PRINTMODE_HUMAN) {\n        printMode = PRINTMODE_HUMAN;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_PLAIN_PRINT);\n      } else if (passedPrintMode === PRINTMODE_2DASCII) {\n        printMode = PRINTMODE_2DASCII;\n        accumulator = print2dascii(p2);\n        rememberPrint(accumulator, LAST_2DASCII_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LATEX) {\n        printMode = PRINTMODE_LATEX;\n        accumulator = printline(p2);\n        rememberPrint(accumulator, LAST_LATEX_PRINT);\n      } else if (passedPrintMode === PRINTMODE_LIST) {\n        printMode = PRINTMODE_LIST;\n        accumulator = print_list(p2);\n        rememberPrint(accumulator, LAST_LIST_PRINT);\n      }\n      printMode = origPrintMode;\n      p = cdr(p);\n    }\n    if (DEBUG) {\n      console.log(\"emttedString from display: \" + stringsEmittedByUserPrintouts);\n    }\n    return accumulator;\n  };\n\n  rememberPrint = function(theString, theTypeOfPrint) {\n    var parsedString;\n    scan('\"' + theString + '\"');\n    parsedString = pop();\n    return set_binding(symbol(theTypeOfPrint), parsedString);\n  };\n\n  print_str = function(s) {\n    if (DEBUG) {\n      console.log(\"emttedString from print_str: \" + stringsEmittedByUserPrintouts);\n    }\n    return s;\n  };\n\n  print_char = function(c) {\n    return c;\n  };\n\n  collectLatexStringFromReturnValue = function(p) {\n    var origPrintMode, originalCodeGen, returnedString;\n    origPrintMode = printMode;\n    printMode = PRINTMODE_LATEX;\n    originalCodeGen = codeGen;\n    codeGen = false;\n    returnedString = print_expr(p);\n    // some variables might contain underscores, escape those\n    returnedString = returnedString.replace(/_/g, \"\\\\_\");\n    printMode = origPrintMode;\n    codeGen = originalCodeGen;\n    if (DEBUG) {\n      console.log(\"emttedString from collectLatexStringFromReturnValue: \" + stringsEmittedByUserPrintouts);\n    }\n    return returnedString;\n  };\n\n  printline = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(p);\n    return accumulator;\n  };\n\n  print_base_of_denom = function(p1) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) { // p1 is BASE\n      accumulator += print_char('(');\n      accumulator += print_expr(p1);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p1); // p1 is BASE\n    }\n    return accumulator;\n  };\n\n  print_expo_of_denom = function(p2) {\n    var accumulator;\n    accumulator = \"\";\n    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) { // p2 is EXPO\n      accumulator += print_char('(');\n      accumulator += print_expr(p2);\n      accumulator += print_char(')');\n    } else {\n      accumulator += print_expr(p2); // p2 is EXPO\n    }\n    return accumulator;\n  };\n\n  // prints stuff after the divide symbol \"/\"\n\n  // d is the number of denominators\n\n  //define BASE p1\n  //define EXPO p2\n  print_denom = function(p, d) {\n    var accumulator;\n    accumulator = \"\";\n    save();\n    p1 = cadr(p);\n    p2 = caddr(p);\n    if (isminusone(p2)) { // p2 is EXPO\n      accumulator += print_base_of_denom(p1);\n      restore();\n      return accumulator;\n    }\n    if (d === 1) { // p2 is EXPO\n      accumulator += print_char('(');\n    }\n    // prepare the exponent\n    // (needs to be negated)\n    // before printing it out\n    push(p2);\n    negate();\n    p2 = pop();\n    accumulator += print_power(p1, p2);\n    if (d === 1) {\n      accumulator += print_char(')');\n    }\n    restore();\n    return accumulator;\n  };\n\n  //define A p3\n  //define B p4\n  print_a_over_b = function(p) {\n    var accumulator, d, doNothing, n;\n    accumulator = \"\";\n    flag = 0;\n    n = 0;\n    d = 0;\n    save();\n    // count numerators and denominators\n    n = 0;\n    d = 0;\n    p1 = cdr(p);\n    p2 = car(p1);\n    if (isrational(p2)) {\n      push(p2);\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(p2);\n      mp_denominator();\n      p4 = pop();\n      if (!isplusone(p3)) { // p3 is A\n        n++;\n      }\n      if (!isplusone(p4)) { // p4 is B\n        d++;\n      }\n      p1 = cdr(p1);\n    } else {\n      p3 = one;\n      p4 = one; // p4 is B\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        d++;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    //debugger\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('\\\\frac{');\n    }\n    if (n === 0) {\n      accumulator += print_char('1');\n    } else {\n      flag = 0;\n      p1 = cdr(p);\n      if (isrational(car(p1))) {\n        p1 = cdr(p1);\n      }\n      if (!isplusone(p3)) { // p3 is A\n        accumulator += print_factor(p3);\n        flag = 1;\n      }\n      while (iscons(p1)) {\n        p2 = car(p1);\n        if (is_denominator(p2)) {\n          doNothing = 1;\n        } else {\n          if (flag) {\n            accumulator += print_multiply_sign();\n          }\n          accumulator += print_factor(p2);\n          flag = 1;\n        }\n        p1 = cdr(p1);\n      }\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}{');\n    } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n      accumulator += print_str(\" / \");\n    } else {\n      accumulator += print_str(\"/\");\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char('(');\n    }\n    flag = 0;\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    if (!isplusone(p4)) { // p4 is B\n      accumulator += print_factor(p4);\n      flag = 1;\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (is_denominator(p2)) {\n        if (flag) {\n          accumulator += print_multiply_sign();\n        }\n        accumulator += print_denom(p2, d);\n        flag = 1;\n      }\n      p1 = cdr(p1);\n    }\n    if (d > 1 && printMode !== PRINTMODE_LATEX) {\n      accumulator += print_char(')');\n    }\n    if (printMode === PRINTMODE_LATEX) {\n      accumulator += print_str('}');\n    }\n    restore();\n    return accumulator;\n  };\n\n  print_expr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(p)) {\n      p = cdr(p);\n      if (sign_of_term(car(p)) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (sign_of_term(car(p)) === '+') {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" + \");\n          } else {\n            accumulator += print_str(\"+\");\n          }\n        } else {\n          if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\" - \");\n          } else {\n            accumulator += print_str(\"-\");\n          }\n        }\n        accumulator += print_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (sign_of_term(p) === '-') {\n        accumulator += print_str(\"-\");\n      }\n      accumulator += print_term(p);\n    }\n    return accumulator;\n  };\n\n  sign_of_term = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && isNumericAtom(cadr(p)) && lessp(cadr(p), zero)) {\n      accumulator += '-';\n    } else if (isNumericAtom(p) && lessp(p, zero)) {\n      accumulator += '-';\n    } else {\n      accumulator += '+';\n    }\n    return accumulator;\n  };\n\n  print_term = function(p) {\n    var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;\n    accumulator = \"\";\n    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {\n      accumulator += print_a_over_b(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      // coeff -1?\n      if (isminusone(car(p))) {\n        //      print_char('-')\n        p = cdr(p);\n      }\n      previousFactorWasANumber = false;\n      // print the first factor ------------\n      if (isNumericAtom(car(p))) {\n        previousFactorWasANumber = true;\n      }\n      // this numberOneOverSomething thing is so that\n      // we show things of the form\n      //   numericFractionOfForm1/something * somethingElse\n      // as\n      //   somethingElse / something\n      // so for example 1/2 * sqrt(2) is rendered as\n      //   sqrt(2)/2\n      // rather than the first form, which looks confusing.\n      // NOTE that you might want to avoid this\n      // when printing polynomials, as it could be nicer\n      // to show the numeric coefficients well separated from\n      // the variable, but we'll see when we'll\n      // come to it if it's an issue.\n      numberOneOverSomething = false;\n      if (printMode === PRINTMODE_LATEX && iscons(cdr(p)) && isNumberOneOverSomething(car(p))) {\n        numberOneOverSomething = true;\n        denom = car(p).q.b.toString();\n      }\n      if (numberOneOverSomething) {\n        origAccumulator = accumulator;\n        accumulator = \"\";\n      } else {\n        accumulator += print_factor(car(p));\n      }\n      p = cdr(p);\n      // print all the other factors -------\n      while (iscons(p)) {\n        // check if we end up having a case where two numbers\n        // are next to each other. In those cases, latex needs\n        // to insert a \\cdot otherwise they end up\n        // right next to each other and read like one big number\n        if (printMode === PRINTMODE_LATEX) {\n          if (previousFactorWasANumber) {\n            // if what comes next is a power and the base\n            // is a number, then we are in the case\n            // of consecutive numbers.\n            // Note that sqrt() i.e when exponent is 1/2\n            // doesn't count because the radical gives\n            // a nice graphical separation already.\n            if (caar(p) === symbol(POWER)) {\n              if (isNumericAtom(car(cdr(car(p))))) {\n                if (!isfraction(car(cdr(cdr(car(p)))))) {\n                  accumulator += \" \\\\cdot \";\n                }\n              }\n            }\n          }\n        }\n        accumulator += print_multiply_sign();\n        accumulator += print_factor(car(p), false, true);\n        previousFactorWasANumber = false;\n        if (isNumericAtom(car(p))) {\n          previousFactorWasANumber = true;\n        }\n        p = cdr(p);\n      }\n      if (numberOneOverSomething) {\n        accumulator = origAccumulator + \"\\\\frac{\" + accumulator + \"}{\" + denom + \"}\";\n      }\n    } else {\n      accumulator += print_factor(p);\n    }\n    return accumulator;\n  };\n\n  print_subexpr = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_char('(');\n    accumulator += print_expr(p);\n    accumulator += print_char(')');\n    return accumulator;\n  };\n\n  print_factorial_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(p);\n    } else {\n      accumulator += print_expr(p);\n    }\n    accumulator += print_char('!');\n    return accumulator;\n  };\n\n  print_ABS_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\left |\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\right |\");\n    return accumulator;\n  };\n\n  print_BINOMIAL_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\binom{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"}{\");\n    accumulator += print_expr(caddr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_DOT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\" \\\\cdot \");\n    accumulator += print_expr(caddr(p));\n    return accumulator;\n  };\n\n  print_DOT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"dot(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \", \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.sin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_COS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.cos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_TAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.tan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCSIN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.asin(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCCOS_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.acos(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_ARCTAN_codegen = function(p) {\n    var accumulator;\n    accumulator = \"Math.atan(\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \")\";\n    return accumulator;\n  };\n\n  print_SQRT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"\\\\sqrt{\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(\"} \");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^T\");\n    return accumulator;\n  };\n\n  print_TRANSPOSE_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"transpose(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_UNIT_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"identity(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_INV_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"{\");\n    if (iscons(cadr(p))) {\n      accumulator += print_str('(');\n    }\n    accumulator += print_expr(cadr(p));\n    if (iscons(cadr(p))) {\n      accumulator += print_str(')');\n    }\n    accumulator += print_str(\"}\");\n    accumulator += print_str(\"^{-1}\");\n    return accumulator;\n  };\n\n  print_INV_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_str(\"inv(\");\n    accumulator += print_expr(cadr(p));\n    accumulator += print_str(')');\n    return accumulator;\n  };\n\n  print_DEFINT_latex = function(p) {\n    var accumulator, functionBody, i, i1, numberOfIntegrals, originalIntegral, ref1, theIntegral, theVariable;\n    accumulator = \"\";\n    functionBody = car(cdr(p));\n    p = cdr(p);\n    originalIntegral = p;\n    numberOfIntegrals = 0;\n    while (iscons(cdr(cdr(p)))) {\n      numberOfIntegrals++;\n      theIntegral = cdr(cdr(p));\n      accumulator += print_str(\"\\\\int^{\");\n      accumulator += print_expr(car(cdr(theIntegral)));\n      accumulator += print_str(\"}_{\");\n      accumulator += print_expr(car(theIntegral));\n      accumulator += print_str(\"} \\\\! \");\n      p = cdr(theIntegral);\n    }\n    accumulator += print_expr(functionBody);\n    accumulator += print_str(\" \\\\,\");\n    p = originalIntegral;\n    for (i = i1 = 1, ref1 = numberOfIntegrals; (1 <= ref1 ? i1 <= ref1 : i1 >= ref1); i = 1 <= ref1 ? ++i1 : --i1) {\n      theVariable = cdr(p);\n      accumulator += print_str(\" \\\\mathrm{d} \");\n      accumulator += print_expr(car(theVariable));\n      if (i < numberOfIntegrals) {\n        accumulator += print_str(\" \\\\, \");\n      }\n      p = cdr(cdr(theVariable));\n    }\n    return accumulator;\n  };\n\n  print_tensor = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_tensor_inner(p, 0, 0)[1];\n    return accumulator;\n  };\n\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner = function(p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    accumulator += print_str(\"[\");\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner(p, j + 1, k);\n        accumulator += retString;\n        // add separator between elements dimensions\n        // \"above\" the inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // add separator between elements in the\n        // inner-most dimension\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\",\");\n        }\n        k++;\n      }\n    }\n    accumulator += print_str(\"]\");\n    return [k, accumulator];\n  };\n\n  print_tensor_latex = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (p.tensor.ndim <= 2) {\n      accumulator += print_tensor_inner_latex(true, p, 0, 0)[1];\n    }\n    return accumulator;\n  };\n\n  // firstLevel is needed because printing a matrix\n  // is not exactly an elegant recursive procedure:\n  // the vector on the first level prints the latex\n  // \"wrap\", while the vectors that make up the\n  // rows don't. so it's a bit asymmetric and this\n  // flag helps.\n  // j scans the dimensions\n  // k is an increment for all the printed elements\n  //   since they are all together in sequence in one array\n  print_tensor_inner_latex = function(firstLevel, p, j, k) {\n    var accumulator, i, i1, j1, ref1, ref2, retString;\n    accumulator = \"\";\n    // open the outer latex wrap\n    if (firstLevel) {\n      accumulator += \"\\\\begin{bmatrix} \";\n    }\n    // only the last dimension prints the actual elements\n    // e.g. in a matrix, the first dimension contains\n    // vectors, not elements, and the second dimension\n    // actually contains the elements\n\n    // if not the last dimension, we are just printing wrappers\n    // and recursing down i.e. we print the next dimension\n    if (j < p.tensor.ndim - 1) {\n      for (i = i1 = 0, ref1 = p.tensor.dim[j]; (0 <= ref1 ? i1 < ref1 : i1 > ref1); i = 0 <= ref1 ? ++i1 : --i1) {\n        [k, retString] = print_tensor_inner_latex(0, p, j + 1, k);\n        accumulator += retString;\n        if (i !== p.tensor.dim[j] - 1) {\n          // add separator between rows\n          accumulator += print_str(\" \\\\\\\\ \");\n        }\n      }\n    } else {\n// if we reached the last dimension, we print the actual\n// elements\n      for (i = j1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n        accumulator += print_expr(p.tensor.elem[k]);\n        // separator between elements in each row\n        if (i !== p.tensor.dim[j] - 1) {\n          accumulator += print_str(\" & \");\n        }\n        k++;\n      }\n    }\n    // close the outer latex wrap\n    if (firstLevel) {\n      accumulator += \" \\\\end{bmatrix}\";\n    }\n    return [k, accumulator];\n  };\n\n  print_SUM_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\sum_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_SUM_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderSum = 0; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderSum += \" + print_expr(body) + \";\" + \" } \" + \" return holderSum;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_TEST_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\left\\\\{ \\\\begin{array}{ll}\";\n    p = cdr(p);\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"{\";\n        accumulator += print_expr(car(p));\n        accumulator += \"} & otherwise \";\n        accumulator += \" \\\\\\\\\\\\\\\\\";\n        break;\n      }\n      accumulator += \"{\";\n      accumulator += print_expr(cadr(p));\n      accumulator += \"} & if & \";\n      accumulator += print_expr(car(p));\n      accumulator += \" \\\\\\\\\\\\\\\\\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      p = cddr(p);\n    }\n    accumulator = accumulator.substring(0, accumulator.length - 4);\n    return accumulator += \"\\\\end{array} \\\\right.\";\n  };\n\n  print_TEST_codegen = function(p) {\n    var accumulator, howManyIfs;\n    accumulator = \"(function(){\";\n    p = cdr(p);\n    howManyIfs = 0;\n    while (iscons(p)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p) === symbol(NIL)) {\n        accumulator += \"else {\";\n        accumulator += \"return (\" + print_expr(car(p)) + \");\";\n        accumulator += \"}\";\n        break;\n      }\n      if (howManyIfs) {\n        accumulator += \" else \";\n      }\n      accumulator += \"if (\" + print_expr(car(p)) + \"){\";\n      accumulator += \"return (\" + print_expr(cadr(p)) + \");\";\n      accumulator += \"}\";\n      // test unsuccessful, continue to the\n      // next pair of test,value\n      howManyIfs++;\n      p = cddr(p);\n    }\n    accumulator += \"})()\";\n    return accumulator;\n  };\n\n  print_TESTLT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" < \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTLE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\leq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGT_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" > \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTGE_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" \\\\geq \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_TESTEQ_latex = function(p) {\n    var accumulator;\n    accumulator = \"{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    accumulator += \" = \";\n    accumulator += \"{\";\n    accumulator += print_expr(caddr(p));\n    return accumulator += \"}\";\n  };\n\n  print_FOR_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   \" + print_expr(body) + \" } \" + \"})()\";\n    return accumulator;\n  };\n\n  print_DO_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    while (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n    }\n    return accumulator;\n  };\n\n  print_SETQ_codegen = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \" = \";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"; \";\n    return accumulator;\n  };\n\n  print_PRODUCT_latex = function(p) {\n    var accumulator;\n    accumulator = \"\\\\prod_{\";\n    accumulator += print_expr(caddr(p));\n    accumulator += \"=\";\n    accumulator += print_expr(cadddr(p));\n    accumulator += \"}^{\";\n    accumulator += print_expr(caddddr(p));\n    accumulator += \"}{\";\n    accumulator += print_expr(cadr(p));\n    accumulator += \"}\";\n    return accumulator;\n  };\n\n  print_PRODUCT_codegen = function(p) {\n    var accumulator, body, lowerlimit, upperlimit, variable;\n    body = cadr(p);\n    variable = caddr(p);\n    lowerlimit = cadddr(p);\n    upperlimit = caddddr(p);\n    accumulator = \"(function(){\" + \" var \" + variable + \"; \" + \" var holderProduct = 1; \" + \" var lowerlimit = \" + print_expr(lowerlimit) + \"; \" + \" var upperlimit = \" + print_expr(upperlimit) + \"; \" + \" for (\" + variable + \" = lowerlimit; \" + variable + \" < upperlimit; \" + variable + \"++) { \" + \"   holderProduct *= \" + print_expr(body) + \";\" + \" } \" + \" return holderProduct;\" + \"})()\";\n    return accumulator;\n  };\n\n  print_base = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(cadr(p));\n      accumulator += print_str(')');\n    } else if (isNumericAtom(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {\n      accumulator += print_str('(');\n      accumulator += print_factor(cadr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(cadr(p));\n    }\n    return accumulator;\n  };\n\n  print_exponent = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isNumericAtom(caddr(p)) && lessp(caddr(p), zero))) {\n      accumulator += print_str('(');\n      accumulator += print_expr(caddr(p));\n      accumulator += print_str(')');\n    } else {\n      accumulator += print_factor(caddr(p));\n    }\n    return accumulator;\n  };\n\n  print_power = function(base, exponent) {\n    var accumulator, denomExponent, newExponent, numExponent;\n    accumulator = \"\";\n    //debugger\n    if (DEBUG) {\n      console.log(\"power base: \" + base + \" \" + \" exponent: \" + exponent);\n    }\n    // quick check is this is actually a square root.\n    if (isoneovertwo(exponent)) {\n      if (equaln(base, 2)) {\n        if (codeGen) {\n          accumulator += print_str(\"Math.SQRT2\");\n          return accumulator;\n        }\n      } else {\n        if (printMode === PRINTMODE_LATEX) {\n          accumulator += print_str(\"\\\\sqrt{\");\n          accumulator += print_expr(base);\n          accumulator += print_str(\"}\");\n          return accumulator;\n        } else if (codeGen) {\n          accumulator += print_str(\"Math.sqrt(\");\n          accumulator += print_expr(base);\n          accumulator += print_str(')');\n          return accumulator;\n        }\n      }\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1)) && base === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.exp(\");\n        accumulator += print_expo_of_denom(exponent);\n        accumulator += print_str(')');\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"e^{\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(\"}\");\n      } else {\n        accumulator += print_str(\"exp(\");\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (codeGen) {\n      accumulator += print_str(\"Math.pow(\");\n      accumulator += print_base_of_denom(base);\n      accumulator += print_str(\", \");\n      accumulator += print_expo_of_denom(exponent);\n      accumulator += print_str(')');\n      return accumulator;\n    }\n    if ((equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0)) || base.printname !== \"x\") {\n      // if the exponent is negative then\n      // we invert the base BUT we don't do\n      // that if the base is \"e\", because for\n      // example when trigonometric functions are\n      // expressed in terms of exponential functions\n      // that would be really confusing, one wants to\n      // keep \"e\" as the base and the negative exponent\n      if (base !== symbol(E)) {\n        if (isminusone(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_expr(base);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_expr(base);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n        if (isnegativeterm(exponent)) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"\\\\frac{1}{\");\n          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {\n            accumulator += print_str(\"1 / \");\n          } else {\n            accumulator += print_str(\"1/\");\n          }\n          push(exponent);\n          push_integer(-1);\n          multiply();\n          newExponent = pop();\n          if (iscons(base) && printMode !== PRINTMODE_LATEX) {\n            accumulator += print_str('(');\n            accumulator += print_power(base, newExponent);\n            accumulator += print_str(')');\n          } else {\n            accumulator += print_power(base, newExponent);\n          }\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\"}\");\n          }\n          return accumulator;\n        }\n      }\n      if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\sqrt\");\n        push(exponent);\n        denominator();\n        denomExponent = pop();\n        if (!isplustwo(denomExponent)) {\n          accumulator += print_str(\"[\");\n          accumulator += print_expr(denomExponent);\n          accumulator += print_str(\"]\");\n        }\n        accumulator += print_str(\"{\");\n        push(exponent);\n        numerator();\n        numExponent = pop();\n        exponent = numExponent;\n        accumulator += print_power(base, exponent);\n        accumulator += print_str(\"}\");\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {\n      // if we are in latex mode we turn many\n      // radicals into a radix sign with a power\n      // underneath, and the power is often one\n      // (e.g. square root turns into a radical\n      // with a power one underneath) so handle\n      // this case simply here, just print the base\n      accumulator += print_expr(base);\n    } else {\n      // print the base,\n      // determining if it needs to be\n      // wrapped in parentheses or not\n      if (isadd(base) || isnegativenumber(base)) {\n        accumulator += print_str('(');\n        accumulator += print_expr(base);\n        accumulator += print_str(')');\n      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str('(');\n        }\n        accumulator += print_factor(base, true);\n        if (printMode !== PRINTMODE_LATEX) {\n          accumulator += print_str(')');\n        }\n      } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {\n        accumulator += print_str('(');\n        accumulator += print_factor(base);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(base);\n      }\n      // print the power symbol\n      //debugger\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        //print_str(\" ^ \")\n        accumulator += print_str(power_str);\n      } else {\n        accumulator += print_str(\"^\");\n      }\n      // print the exponent\n      if (printMode === PRINTMODE_LATEX) {\n        // in latex mode, one can omit the curly braces\n        // wrapping the exponent if the exponent is only\n        // one character long\n        if (print_expr(exponent).length > 1) {\n          accumulator += print_str(\"{\");\n          accumulator += print_expr(exponent);\n          accumulator += print_str(\"}\");\n        } else {\n          accumulator += print_expr(exponent);\n        }\n      } else if (iscons(exponent) || isfraction(exponent) || (isNumericAtom(exponent) && lessp(exponent, zero))) {\n        accumulator += print_str('(');\n        accumulator += print_expr(exponent);\n        accumulator += print_str(')');\n      } else {\n        accumulator += print_factor(exponent);\n      }\n    }\n    return accumulator;\n  };\n\n  print_index_function = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      accumulator += print_subexpr(car(p));\n    } else {\n      accumulator += print_expr(car(p));\n    }\n    accumulator += print_str('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      accumulator += print_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        accumulator += print_str(',');\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    accumulator += print_str(']');\n    return accumulator;\n  };\n\n  print_factor = function(p, omitParens, pastFirstFactor) {\n    var accumulator, base, exponent, fbody, parameters, returned;\n    // debugger\n    accumulator = \"\";\n    if (isNumericAtom(p)) {\n      // in an evaluated term, all the numeric parts\n      // are at the beginning of the term.\n      // When printing the EXPRESSION,\n      // we peek into the first factor of the term and we\n      // look at whether it's a number less then zero.\n      // if it is, we print the \"-\" as the \"leading\" part of the\n      // print of the EXPRESSION, and then we proceed printint the factors\n      // of the term. This means that when we come here, we must\n      // skip printing the minus if the number is negative,\n      // because it's already been printed.\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += '(';\n      }\n      accumulator += print_number(p, pastFirstFactor);\n      if (pastFirstFactor && lessp(p, zero)) {\n        accumulator += ')';\n      }\n      return accumulator;\n    }\n    if (isstr(p)) {\n      accumulator += print_str(\"\\\"\");\n      accumulator += print_str(p.str);\n      accumulator += print_str(\"\\\"\");\n      return accumulator;\n    }\n    if (istensor(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_tensor_latex(p);\n      } else {\n        accumulator += print_tensor(p);\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(MULTIPLY)) {\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\left (\");\n          } else {\n            accumulator += print_str('(');\n          }\n        }\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        if (sign_of_term(p) === '-' || printMode !== PRINTMODE_LATEX) {\n          if (printMode === PRINTMODE_LATEX) {\n            accumulator += print_str(\" \\\\right ) \");\n          } else {\n            accumulator += print_str(')');\n          }\n        }\n      }\n      return accumulator;\n    } else if (isadd(p)) {\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      accumulator += print_expr(p);\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (car(p) === symbol(POWER)) {\n      base = cadr(p);\n      exponent = caddr(p);\n      accumulator += print_power(base, exponent);\n      return accumulator;\n    }\n    //  if (car(p) == _list) {\n    //    print_str(\"{\")\n    //    p = cdr(p)\n    //    if (iscons(p)) {\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    while (iscons(p)) {\n    //      print_str(\",\")\n    //      print_expr(car(p))\n    //      p = cdr(p)\n    //    }\n    //    print_str(\"}\")\n    //    return\n    //  }\n    if (car(p) === symbol(FUNCTION)) {\n      fbody = cadr(p);\n      if (!codeGen) {\n        parameters = caddr(p);\n        accumulator += print_str(\"function \");\n        if (DEBUG) {\n          console.log(\"emittedString from print_factor \" + stringsEmittedByUserPrintouts);\n        }\n        returned = print_list(parameters);\n        accumulator += returned;\n        accumulator += print_str(\" -> \");\n      }\n      accumulator += print_expr(fbody);\n      return accumulator;\n    }\n    if (car(p) === symbol(PATTERN)) {\n      accumulator += print_expr(caadr(p));\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\" \\\\rightarrow \");\n      } else {\n        if (printMode === PRINTMODE_HUMAN && !test_flag) {\n          accumulator += print_str(\" -> \");\n        } else {\n          accumulator += print_str(\"->\");\n        }\n      }\n      accumulator += print_expr(car(cdr(cadr(p))));\n      return accumulator;\n    }\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      accumulator += print_index_function(p);\n      return accumulator;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      accumulator += print_factorial_function(p);\n      return accumulator;\n    } else if (car(p) === symbol(ABS) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_ABS_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {\n      //debugger\n      accumulator += print_SQRT_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(TRANSPOSE)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TRANSPOSE_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_TRANSPOSE_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(UNIT)) {\n      if (codeGen) {\n        accumulator += print_UNIT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(INV)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_INV_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_INV_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_BINOMIAL_latex(p);\n      return accumulator;\n    } else if (car(p) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {\n      accumulator += print_DEFINT_latex(p);\n      return accumulator;\n    } else if (isinnerordot(p)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_DOT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_DOT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SIN)) {\n      if (codeGen) {\n        accumulator += print_SIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(COS)) {\n      if (codeGen) {\n        accumulator += print_COS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TAN)) {\n      if (codeGen) {\n        accumulator += print_TAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCSIN)) {\n      if (codeGen) {\n        accumulator += print_ARCSIN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCCOS)) {\n      if (codeGen) {\n        accumulator += print_ARCCOS_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ARCTAN)) {\n      if (codeGen) {\n        accumulator += print_ARCTAN_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SUM)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_SUM_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_SUM_codegen(p);\n        return accumulator;\n      }\n    //else if car(p) == symbol(QUOTE)\n    //  if printMode == PRINTMODE_LATEX\n    //    print_expr(cadr(p))\n    //    return accumulator\n    } else if (car(p) === symbol(PRODUCT)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_PRODUCT_latex(p);\n        return accumulator;\n      } else if (codeGen) {\n        accumulator += print_PRODUCT_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FOR)) {\n      if (codeGen) {\n        accumulator += print_FOR_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(DO)) {\n      if (codeGen) {\n        accumulator += print_DO_codegen(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TEST)) {\n      if (codeGen) {\n        accumulator += print_TEST_codegen(p);\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TEST_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") < (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTLE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") <= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTLE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGT)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") > (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGT_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTGE)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") >= (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTGE_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(TESTEQ)) {\n      if (codeGen) {\n        accumulator += \"((\" + print_expr(cadr(p)) + \") === (\" + print_expr(caddr(p)) + \"))\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_TESTEQ_latex(p);\n        return accumulator;\n      }\n    } else if (car(p) === symbol(FLOOR)) {\n      if (codeGen) {\n        accumulator += \"Math.floor(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lfloor {\" + print_expr(cadr(p)) + \"} \\\\rfloor \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(CEILING)) {\n      if (codeGen) {\n        accumulator += \"Math.ceiling(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += \" \\\\lceil {\" + print_expr(cadr(p)) + \"} \\\\rceil \";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(ROUND)) {\n      if (codeGen) {\n        accumulator += \"Math.round(\" + print_expr(cadr(p)) + \")\";\n        return accumulator;\n      }\n    } else if (car(p) === symbol(SETQ)) {\n      if (codeGen) {\n        accumulator += print_SETQ_codegen(p);\n        return accumulator;\n      } else {\n        accumulator += print_expr(cadr(p));\n        accumulator += print_str(\"=\");\n        accumulator += print_expr(caddr(p));\n        return accumulator;\n      }\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p)->k == SYM) {\n      //  print_str(((struct symbol *) cadr(p))->name)\n      //  return\n      //}\n      accumulator += print_factor(car(p));\n      p = cdr(p);\n      if (!omitParens) {\n        accumulator += print_str('(');\n      }\n      if (iscons(p)) {\n        accumulator += print_expr(car(p));\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += print_str(\",\");\n          accumulator += print_expr(car(p));\n          p = cdr(p);\n        }\n      }\n      if (!omitParens) {\n        accumulator += print_str(')');\n      }\n      return accumulator;\n    }\n    if (p === symbol(DERIVATIVE)) {\n      accumulator += print_char('d');\n    } else if (p === symbol(E)) {\n      if (codeGen) {\n        accumulator += print_str(\"Math.E\");\n      } else {\n        accumulator += print_str(\"e\");\n      }\n    } else if (p === symbol(PI)) {\n      if (printMode === PRINTMODE_LATEX) {\n        accumulator += print_str(\"\\\\pi\");\n      } else {\n        accumulator += print_str(\"pi\");\n      }\n    } else {\n      accumulator += print_str(get_printname(p));\n    }\n    return accumulator;\n  };\n\n  print_list = function(p) {\n    var accumulator;\n    accumulator = \"\";\n    switch (p.k) {\n      case CONS:\n        accumulator += '(';\n        accumulator += print_list(car(p));\n        if (p === cdr(p) && p !== symbol(NIL)) {\n          console.log(\"oh no recursive!\");\n          debugger;\n        }\n        p = cdr(p);\n        while (iscons(p)) {\n          accumulator += \" \";\n          accumulator += print_list(car(p));\n          p = cdr(p);\n          if (p === cdr(p) && p !== symbol(NIL)) {\n            console.log(\"oh no recursive!\");\n            debugger;\n          }\n        }\n        if (p !== symbol(NIL)) {\n          accumulator += \" . \";\n          accumulator += print_list(p);\n        }\n        accumulator += ')';\n        break;\n      case STR:\n        //print_str(\"\\\"\")\n        accumulator += p.str;\n        break;\n      //print_str(\"\\\"\")\n      case NUM:\n      case DOUBLE:\n        accumulator += print_number(p, true);\n        break;\n      case SYM:\n        accumulator += get_printname(p);\n        break;\n      default:\n        accumulator += \"<tensor>\";\n    }\n    return accumulator;\n  };\n\n  print_multiply_sign = function() {\n    var accumulator;\n    accumulator = \"\";\n    if (printMode === PRINTMODE_LATEX) {\n      if (printMode === PRINTMODE_HUMAN && !test_flag) {\n        accumulator += print_str(\" \");\n      } else {\n        return accumulator;\n      }\n    }\n    if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {\n      accumulator += print_str(\" \");\n    } else {\n      accumulator += print_str(\"*\");\n    }\n    return accumulator;\n  };\n\n  is_denominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  // don't consider the leading fraction\n  // we want 2/3*a*b*c instead of 2*a*b*c/3\n  any_denominators = function(p) {\n    var q;\n    p = cdr(p);\n    //  if (isfraction(car(p)))\n    //    return 1\n    while (iscons(p)) {\n      q = car(p);\n      if (is_denominator(q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  /*\n\n  Prints in \"2d\", e.g. instead of 1/(x+1)^2 :\n\n        1\n   ----------\n           2\n    (1 + x)\n\n   Note that although this looks more natural, a) it's not parsable and\n   b) it can be occasionally be ambiguous, such as:\n\n     1\n   ----\n     2\n   x\n\n  is 1/x^2 but it also looks a little like x^(1/2)\n\n  */\n  //-----------------------------------------------------------------------------\n\n  //  Examples:\n\n  //     012345678\n  //  -2 .........\n  //  -1 .........\n  //   0 ..hello..  x=2, y=0, h=1, w=5\n  //   1 .........\n  //   2 .........\n\n  //     012345678\n  //  -2 .........\n  //  -1 ..355....\n  //   0 ..---....  x=2, y=-1, h=3, w=3\n  //   1 ..113....\n  //   2 .........\n\n  //-----------------------------------------------------------------------------\n  YMAX = 10000;\n\n  glyph = (function() {\n    class glyph {};\n\n    glyph.prototype.c = 0;\n\n    glyph.prototype.x = 0;\n\n    glyph.prototype.y = 0;\n\n    return glyph;\n\n  }).call(this);\n\n  // will contain glyphs\n  chartab = [];\n\n  for (charTabIndex = i1 = 0, ref1 = YMAX; (0 <= ref1 ? i1 < ref1 : i1 > ref1); charTabIndex = 0 <= ref1 ? ++i1 : --i1) {\n    chartab[charTabIndex] = new glyph();\n  }\n\n  yindex = 0;\n\n  level = 0;\n\n  emit_x = 0;\n\n  expr_level = 0;\n\n  display_flag = 0;\n\n  // this is not really the translated version,\n  // the original is in window.cpp and is\n  // rather more complex\n  printchar_nowrap = function(character) {\n    var accumulator;\n    accumulator = \"\";\n    accumulator += character;\n    return accumulator;\n  };\n\n  printchar = function(character) {\n    return printchar_nowrap(character);\n  };\n\n  print2dascii = function(p) {\n    var beenPrinted, h, w, y;\n    h = 0;\n    w = 0;\n    y = 0;\n    save();\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_top_expr(p);\n    // if too wide then print flat\n    [h, w, y] = get_size(0, yindex);\n    if (w > 100) {\n      printline(p);\n      restore();\n      return;\n    }\n    beenPrinted = print_glyphs();\n    restore();\n    return beenPrinted;\n  };\n\n  emit_top_expr = function(p) {\n    if (car(p) === symbol(SETQ)) {\n      emit_expr(cadr(p));\n      __emit_str(\" = \");\n      emit_expr(caddr(p));\n      return;\n    }\n    if (istensor(p)) {\n      return emit_tensor(p);\n    } else {\n      return emit_expr(p);\n    }\n  };\n\n  will_be_displayed_as_fraction = function(p) {\n    if (level > 0) {\n      return 0;\n    }\n    if (isfraction(p)) {\n      return 1;\n    }\n    if (car(p) !== symbol(MULTIPLY)) {\n      return 0;\n    }\n    if (isfraction(cadr(p))) {\n      return 1;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  emit_expr = function(p) {\n    //  if (level > 0) {\n    //    printexpr(p)\n    //    return\n    //  }\n    expr_level++;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      if (__is_negative(car(p))) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(car(p))) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (__is_negative(p)) {\n        __emit_char('-');\n        if (will_be_displayed_as_fraction(p)) {\n          __emit_char(' ');\n        }\n      }\n      emit_term(p);\n    }\n    return expr_level--;\n  };\n\n  emit_unsigned_expr = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      //    if (__is_negative(car(p)))\n      //      __emit_char('-')\n      emit_term(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        if (__is_negative(car(p))) {\n          __emit_char(' ');\n          __emit_char('-');\n          __emit_char(' ');\n        } else {\n          __emit_char(' ');\n          __emit_char('+');\n          __emit_char(' ');\n        }\n        emit_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      //    if (__is_negative(p))\n      //      __emit_char('-')\n      return emit_term(p);\n    }\n  };\n\n  __is_negative = function(p) {\n    if (isnegativenumber(p)) {\n      return 1;\n    }\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_term = function(p) {\n    var n;\n    if (car(p) === symbol(MULTIPLY)) {\n      n = count_denominators(p);\n      if (n && level === 0) {\n        return emit_fraction(p, n);\n      } else {\n        return emit_multiply(p, n);\n      }\n    } else {\n      return emit_factor(p);\n    }\n  };\n\n  isdenominator = function(p) {\n    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  count_denominators = function(p) {\n    var count, q;\n    count = 0;\n    p = cdr(p);\n    //  if (isfraction(car(p))) {\n    //    count++\n    //    p = cdr(p)\n    //  }\n    while (iscons(p)) {\n      q = car(p);\n      if (isdenominator(q)) {\n        count++;\n      }\n      p = cdr(p);\n    }\n    return count;\n  };\n\n  // n is the number of denominators, not counting a fraction like 1/2\n  emit_multiply = function(p, n) {\n    var results;\n    if (n === 0) {\n      p = cdr(p);\n      if (isplusone(car(p)) || isminusone(car(p))) {\n        p = cdr(p);\n      }\n      emit_factor(car(p));\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        __emit_char(' ');\n        emit_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      emit_numerators(p);\n      __emit_char('/');\n      // need grouping if more than one denominator\n      if (n > 1 || isfraction(cadr(p))) {\n        __emit_char('(');\n        emit_denominators(p);\n        return __emit_char(')');\n      } else {\n        return emit_denominators(p);\n      }\n    }\n  };\n\n  //define A p3\n  //define B p4\n\n  // sign of term has already been emitted\n  emit_fraction = function(p, d) {\n    var count, doNothing, k1, k2, n, x;\n    count = 0;\n    k1 = 0;\n    k2 = 0;\n    n = 0;\n    x = 0;\n    save();\n    p3 = one;\n    p4 = one;\n    if (isrational(cadr(p))) {\n      push(cadr(p));\n      mp_numerator();\n      absval();\n      p3 = pop();\n      push(cadr(p));\n      mp_denominator();\n      p4 = pop(); // p4 is B\n    }\n    if (isdouble(cadr(p))) {\n      push(cadr(p));\n      absval();\n      p3 = pop(); // p3 is A\n    }\n    \n    // count numerators\n    if (isplusone(p3)) { // p3 is A\n      n = 0;\n    } else {\n      n = 1;\n    }\n    p1 = cdr(p);\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        n++;\n      }\n      p1 = cdr(p1);\n    }\n    // emit numerators\n    x = emit_x;\n    k1 = yindex;\n    count = 0;\n    if (!isplusone(p3)) { // p3 is A\n      emit_number(p3, 0);\n      count++;\n    }\n    // skip over \"multiply\"\n    p1 = cdr(p);\n    // skip over numerical coefficient, already handled\n    if (isNumericAtom(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        doNothing = 1;\n      } else {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        if (n === 1) {\n          emit_expr(p2);\n        } else {\n          emit_factor(p2);\n        }\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    if (count === 0) {\n      __emit_char('1');\n    }\n    // emit denominators\n    k2 = yindex;\n    count = 0;\n    if (!isplusone(p4)) { // p4 is B\n      emit_number(p4, 0);\n      count++;\n      d++;\n    }\n    p1 = cdr(p);\n    if (isrational(car(p1))) {\n      p1 = cdr(p1);\n    }\n    while (iscons(p1)) {\n      p2 = car(p1);\n      if (isdenominator(p2)) {\n        if (count > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(p2, d);\n        count++;\n      }\n      p1 = cdr(p1);\n    }\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_numerators = function(p) {\n    var doNothing, n;\n    save();\n    n = 0;\n    p1 = one;\n    p = cdr(p);\n    if (isrational(car(p))) {\n      push(car(p));\n      mp_numerator();\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    } else if (isdouble(car(p))) {\n      push(car(p));\n      absval();\n      p1 = pop();\n      p = cdr(p);\n    }\n    n = 0;\n    if (!isplusone(p1)) {\n      emit_number(p1, 0);\n      n++;\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        doNothing = 1;\n      } else {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_factor(car(p));\n        n++;\n      }\n      p = cdr(p);\n    }\n    if (n === 0) {\n      __emit_char('1');\n    }\n    return restore();\n  };\n\n  // p points to a multiply\n  emit_denominators = function(p) {\n    var n;\n    save();\n    n = 0;\n    p = cdr(p);\n    if (isfraction(car(p))) {\n      push(car(p));\n      mp_denominator();\n      p1 = pop();\n      emit_number(p1, 0);\n      n++;\n      p = cdr(p);\n    }\n    while (iscons(p)) {\n      if (isdenominator(car(p))) {\n        if (n > 0) {\n          __emit_char(' ');\n        }\n        emit_denominator(car(p), 0);\n        n++;\n      }\n      p = cdr(p);\n    }\n    return restore();\n  };\n\n  emit_factor = function(p) {\n    if (istensor(p)) {\n      if (level === 0) {\n        //emit_tensor(p)\n        emit_flat_tensor(p);\n      } else {\n        emit_flat_tensor(p);\n      }\n      return;\n    }\n    if (isdouble(p)) {\n      emit_number(p, 0);\n      return;\n    }\n    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {\n      emit_subexpr(p);\n      return;\n    }\n    if (car(p) === symbol(POWER)) {\n      emit_power(p);\n      return;\n    }\n    if (iscons(p)) {\n      //if (car(p) == symbol(FORMAL) && cadr(p).k == SYM)\n      //  emit_symbol(cadr(p))\n      //else\n      emit_function(p);\n      return;\n    }\n    if (isNumericAtom(p)) {\n      if (level === 0) {\n        emit_numerical_fraction(p);\n      } else {\n        emit_number(p, 0);\n      }\n      return;\n    }\n    if (issymbol(p)) {\n      emit_symbol(p);\n      return;\n    }\n    if (isstr(p)) {\n      emit_string(p);\n    }\n  };\n\n  emit_numerical_fraction = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    save();\n    push(p);\n    mp_numerator();\n    absval();\n    p3 = pop();\n    push(p);\n    mp_denominator();\n    p4 = pop();\n    if (isplusone(p4)) { // p4 is B\n      emit_number(p3, 0);\n      restore();\n      return;\n    }\n    x = emit_x;\n    k1 = yindex;\n    emit_number(p3, 0);\n    k2 = yindex;\n    emit_number(p4, 0); // p4 is B\n    fixup_fraction(x, k1, k2);\n    return restore();\n  };\n\n  // if it's a factor then it doesn't need parens around it, i.e. 1/sin(theta)^2\n  isfactor = function(p) {\n    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {\n      return 1;\n    }\n    if (issymbol(p)) {\n      return 1;\n    }\n    if (isfraction(p)) {\n      return 0;\n    }\n    if (isnegativenumber(p)) {\n      return 0;\n    }\n    if (isNumericAtom(p)) {\n      return 1;\n    }\n    return 0;\n  };\n\n  emit_power = function(p) {\n    var k1, k2, x;\n    k1 = 0;\n    k2 = 0;\n    x = 0;\n    if (cadr(p) === symbol(E)) {\n      __emit_str(\"exp(\");\n      emit_expr(caddr(p));\n      __emit_char(')');\n      return;\n    }\n    if (level > 0) {\n      if (isminusone(caddr(p))) {\n        __emit_char('1');\n        __emit_char('/');\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n      } else {\n        if (isfactor(cadr(p))) {\n          emit_factor(cadr(p));\n        } else {\n          emit_subexpr(cadr(p));\n        }\n        __emit_char('^');\n        if (isfactor(caddr(p))) {\n          emit_factor(caddr(p));\n        } else {\n          emit_subexpr(caddr(p));\n        }\n      }\n      return;\n    }\n    // special case: 1 over something\n    if (__is_negative(caddr(p))) {\n      x = emit_x;\n      k1 = yindex;\n      __emit_char('1');\n      k2 = yindex;\n      //level++\n      emit_denominator(p, 1);\n      //level--\n      fixup_fraction(x, k1, k2);\n      return;\n    }\n    k1 = yindex;\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    level++;\n    emit_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  // if n == 1 then emit as expr (no parens)\n\n  // p is a power\n  emit_denominator = function(p, n) {\n    var k1, k2;\n    k1 = 0;\n    k2 = 0;\n    // special case: 1 over something\n    if (isminusone(caddr(p))) {\n      if (n === 1) {\n        emit_expr(cadr(p));\n      } else {\n        emit_factor(cadr(p));\n      }\n      return;\n    }\n    k1 = yindex;\n    // emit base\n    if (isfactor(cadr(p))) {\n      emit_factor(cadr(p));\n    } else {\n      emit_subexpr(cadr(p));\n    }\n    k2 = yindex;\n    // emit exponent, don't emit minus sign\n    level++;\n    emit_unsigned_expr(caddr(p));\n    level--;\n    return fixup_power(k1, k2);\n  };\n\n  emit_function = function(p) {\n    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {\n      emit_index_function(p);\n      return;\n    }\n    if (car(p) === symbol(FACTORIAL)) {\n      emit_factorial_function(p);\n      return;\n    }\n    if (car(p) === symbol(DERIVATIVE)) {\n      __emit_char('d');\n    } else {\n      emit_symbol(car(p));\n    }\n    __emit_char('(');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        //__emit_char(' ')\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(')');\n  };\n\n  emit_index_function = function(p) {\n    p = cdr(p);\n    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {\n      emit_subexpr(car(p));\n    } else {\n      emit_expr(car(p));\n    }\n    __emit_char('[');\n    p = cdr(p);\n    if (iscons(p)) {\n      emit_expr(car(p));\n      p = cdr(p);\n      while (iscons(p)) {\n        __emit_char(',');\n        emit_expr(car(p));\n        p = cdr(p);\n      }\n    }\n    return __emit_char(']');\n  };\n\n  emit_factorial_function = function(p) {\n    p = cadr(p);\n    if (isfraction(p) || car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {\n      emit_subexpr(p);\n    } else {\n      emit_expr(p);\n    }\n    return __emit_char('!');\n  };\n\n  emit_subexpr = function(p) {\n    __emit_char('(');\n    emit_expr(p);\n    return __emit_char(')');\n  };\n\n  emit_symbol = function(p) {\n    var i, j1, pPrintName, ref2, results;\n    i = 0;\n    if (p === symbol(E)) {\n      __emit_str(\"exp(1)\");\n      return;\n    }\n    pPrintName = get_printname(p);\n    results = [];\n    for (i = j1 = 0, ref2 = pPrintName.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(pPrintName[i]));\n    }\n    return results;\n  };\n\n  emit_string = function(p) {\n    var i, j1, pString, ref2;\n    i = 0;\n    pString = p.str;\n    __emit_char('\"');\n    for (i = j1 = 0, ref2 = pString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      __emit_char(pString[i]);\n    }\n    return __emit_char('\"');\n  };\n\n  fixup_fraction = function(x, k1, k2) {\n    var dx, dy, h1, h2, i, j1, ref2, results, w, w1, w2, y, y1, y2;\n    dx = 0;\n    dy = 0;\n    i = 0;\n    w = 0;\n    y = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    if (w2 > w1) {\n      dx = (w2 - w1) / 2; // shift numerator right\n    } else {\n      dx = 0;\n    }\n    dx++;\n    // this is how much is below the baseline\n    y = y1 + h1 - 1;\n    dy = -y - 1;\n    move(k1, k2, dx, dy);\n    if (w2 > w1) {\n      dx = -w1;\n    } else {\n      dx = -w1 + (w1 - w2) / 2;\n    }\n    dx++;\n    dy = -y2 + 1;\n    move(k2, yindex, dx, dy);\n    if (w2 > w1) {\n      w = w2;\n    } else {\n      w = w1;\n    }\n    w += 2;\n    emit_x = x;\n    results = [];\n    for (i = j1 = 0, ref2 = w; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char('-'));\n    }\n    return results;\n  };\n\n  fixup_power = function(k1, k2) {\n    var dy, h1, h2, w1, w2, y1, y2;\n    dy = 0;\n    h1 = 0;\n    w1 = 0;\n    y1 = 0;\n    h2 = 0;\n    w2 = 0;\n    y2 = 0;\n    [h1, w1, y1] = get_size(k1, k2);\n    [h2, w2, y2] = get_size(k2, yindex);\n    // move superscript to baseline\n    dy = -y2 - h2 + 1;\n    // now move above base\n    dy += y1 - 1;\n    return move(k2, yindex, 0, dy);\n  };\n\n  move = function(j, k, dx, dy) {\n    var i, j1, ref2, ref3, results;\n    i = 0;\n    results = [];\n    for (i = j1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      chartab[i].x += dx;\n      results.push(chartab[i].y += dy);\n    }\n    return results;\n  };\n\n  // finds the bounding rectangle and vertical position\n  get_size = function(j, k) {\n    var h, i, j1, max_x, max_y, min_x, min_y, ref2, ref3, w, y;\n    i = 0;\n    min_x = chartab[j].x;\n    max_x = chartab[j].x;\n    min_y = chartab[j].y;\n    max_y = chartab[j].y;\n    for (i = j1 = ref2 = j + 1, ref3 = k; (ref2 <= ref3 ? j1 < ref3 : j1 > ref3); i = ref2 <= ref3 ? ++j1 : --j1) {\n      if (chartab[i].x < min_x) {\n        min_x = chartab[i].x;\n      }\n      if (chartab[i].x > max_x) {\n        max_x = chartab[i].x;\n      }\n      if (chartab[i].y < min_y) {\n        min_y = chartab[i].y;\n      }\n      if (chartab[i].y > max_y) {\n        max_y = chartab[i].y;\n      }\n    }\n    h = max_y - min_y + 1;\n    w = max_x - min_x + 1;\n    y = min_y;\n    return [h, w, y];\n  };\n\n  displaychar = function(c) {\n    return __emit_char(c);\n  };\n\n  __emit_char = function(c) {\n    if (yindex === YMAX) {\n      return;\n    }\n    if (chartab[yindex] == null) {\n      debugger;\n    }\n    chartab[yindex].c = c;\n    chartab[yindex].x = emit_x;\n    chartab[yindex].y = 0;\n    yindex++;\n    return emit_x++;\n  };\n\n  __emit_str = function(s) {\n    var i, j1, ref2, results;\n    i = 0;\n    results = [];\n    for (i = j1 = 0, ref2 = s.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      results.push(__emit_char(s[i]));\n    }\n    return results;\n  };\n\n  emit_number = function(p, emit_sign) {\n    var i, j1, l1, m1, ref2, ref3, ref4, results, results1, tmpString;\n    tmpString = \"\";\n    i = 0;\n    switch (p.k) {\n      case NUM:\n        tmpString = p.q.a.toString();\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        for (i = j1 = 0, ref2 = tmpString.length; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n          __emit_char(tmpString[i]);\n        }\n        tmpString = p.q.b.toString();\n        if (tmpString === \"1\") {\n          break;\n        }\n        __emit_char('/');\n        results = [];\n        for (i = l1 = 0, ref3 = tmpString.length; (0 <= ref3 ? l1 < ref3 : l1 > ref3); i = 0 <= ref3 ? ++l1 : --l1) {\n          results.push(__emit_char(tmpString[i]));\n        }\n        return results;\n        break;\n      case DOUBLE:\n        tmpString = doubleToReasonableString(p.d);\n        if (tmpString[0] === '-' && emit_sign === 0) {\n          tmpString = tmpString.substring(1);\n        }\n        results1 = [];\n        for (i = m1 = 0, ref4 = tmpString.length; (0 <= ref4 ? m1 < ref4 : m1 > ref4); i = 0 <= ref4 ? ++m1 : --m1) {\n          results1.push(__emit_char(tmpString[i]));\n        }\n        return results1;\n    }\n  };\n\n  // a and b are glyphs\n  cmpGlyphs = function(a, b) {\n    if (a.y < b.y) {\n      return -1;\n    }\n    if (a.y > b.y) {\n      return 1;\n    }\n    if (a.x < b.x) {\n      return -1;\n    }\n    if (a.x > b.x) {\n      return 1;\n    }\n    return 0;\n  };\n\n  print_glyphs = function() {\n    var accumulator, i, j1, ref2, subsetOfStack, x, y;\n    i = 0;\n    accumulator = \"\";\n    \n    // now sort the glyphs by their vertical positions,\n    // since we are going to build a string where obviously the\n    // \"upper\" line has to printed out first, followed by\n    // a new line, followed by the other lines.\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        accumulator += printchar('\\n');\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        accumulator += printchar_nowrap(' ');\n        x++;\n      }\n      accumulator += printchar_nowrap(chartab[i].c);\n      x++;\n    }\n    return accumulator;\n  };\n\n  buffer = \"\";\n\n  getdisplaystr = function() {\n    yindex = 0;\n    level = 0;\n    emit_x = 0;\n    emit_expr(pop());\n    fill_buf();\n    return buffer;\n  };\n\n  fill_buf = function() {\n    var i, j1, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;\n    tmpBuffer = buffer;\n    sIndex = 0;\n    i = 0;\n    //qsort(chartab, yindex, sizeof (struct glyph), __cmp)\n    subsetOfStack = chartab.slice(0, yindex);\n    subsetOfStack.sort(cmpGlyphs);\n    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));\n    x = 0;\n    y = chartab[0].y;\n    for (i = j1 = 0, ref2 = yindex; (0 <= ref2 ? j1 < ref2 : j1 > ref2); i = 0 <= ref2 ? ++j1 : --j1) {\n      while (chartab[i].y > y) {\n        tmpBuffer[sIndex++] = '\\n';\n        x = 0;\n        y++;\n      }\n      while (chartab[i].x > x) {\n        tmpBuffer[sIndex++] = ' ';\n        x++;\n      }\n      tmpBuffer[sIndex++] = chartab[i].c;\n      x++;\n    }\n    return tmpBuffer[sIndex++] = '\\n';\n  };\n\n  N = 100;\n\n  oneElement = (function() {\n    class oneElement {};\n\n    oneElement.prototype.x = 0;\n\n    oneElement.prototype.y = 0;\n\n    oneElement.prototype.h = 0;\n\n    oneElement.prototype.w = 0;\n\n    oneElement.prototype.index = 0;\n\n    oneElement.prototype.count = 0;\n\n    return oneElement;\n\n  }).call(this);\n\n  elem = [];\n\n  for (elelmIndex = j1 = 0; j1 < 10000; elelmIndex = ++j1) {\n    elem[elelmIndex] = new oneElement();\n  }\n\n  SPACE_BETWEEN_COLUMNS = 3;\n\n  SPACE_BETWEEN_ROWS = 1;\n\n  emit_tensor = function(p) {\n    var col, dx, dy, eh, ew, h, i, l1, m1, n, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, row, w, x, y;\n    i = 0;\n    n = 0;\n    nrow = 0;\n    ncol = 0;\n    x = 0;\n    y = 0;\n    h = 0;\n    w = 0;\n    dx = 0;\n    dy = 0;\n    eh = 0;\n    ew = 0;\n    row = 0;\n    col = 0;\n    if (p.tensor.ndim > 2) {\n      emit_flat_tensor(p);\n      return;\n    }\n    nrow = p.tensor.dim[0];\n    if (p.tensor.ndim === 2) {\n      ncol = p.tensor.dim[1];\n    } else {\n      ncol = 1;\n    }\n    n = nrow * ncol;\n    if (n > N) {\n      emit_flat_tensor(p);\n      return;\n    }\n    // horizontal coordinate of the matrix\n\n    //if 0\n    //emit_x += 2; # make space for left paren\n    //endif\n    x = emit_x;\n// emit each element\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      elem[i].index = yindex;\n      elem[i].x = emit_x;\n      emit_expr(p.tensor.elem[i]);\n      elem[i].count = yindex - elem[i].index;\n      [elem[i].h, elem[i].w, elem[i].y] = get_size(elem[i].index, yindex);\n    }\n    // find element height and width\n    eh = 0;\n    ew = 0;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (elem[i].h > eh) {\n        eh = elem[i].h;\n      }\n      if (elem[i].w > ew) {\n        ew = elem[i].w;\n      }\n    }\n    // this is the overall height of the matrix\n    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;\n    // this is the overall width of the matrix\n    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;\n    // this is the vertical coordinate of the matrix\n    y = -(h / 2);\n// move elements around\n    for (row = n1 = 0, ref4 = nrow; (0 <= ref4 ? n1 < ref4 : n1 > ref4); row = 0 <= ref4 ? ++n1 : --n1) {\n      for (col = o1 = 0, ref5 = ncol; (0 <= ref5 ? o1 < ref5 : o1 > ref5); col = 0 <= ref5 ? ++o1 : --o1) {\n        i = row * ncol + col;\n        // first move to upper left corner of matrix\n        dx = x - elem[i].x;\n        dy = y - elem[i].y;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n        // now move to official position\n        dx = 0;\n        if (col > 0) {\n          dx = col * (ew + SPACE_BETWEEN_COLUMNS);\n        }\n        dy = 0;\n        if (row > 0) {\n          dy = row * (eh + SPACE_BETWEEN_ROWS);\n        }\n        // small correction for horizontal centering\n        dx += (ew - elem[i].w) / 2;\n        // small correction for vertical centering\n        dy += (eh - elem[i].h) / 2;\n        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);\n      }\n    }\n    return emit_x = x + w;\n  };\n\n  emit_flat_tensor = function(p) {\n    return emit_tensor_inner(p, 0, 0);\n  };\n\n  emit_tensor_inner = function(p, j, k) {\n    var i, l1, ref2;\n    i = 0;\n    __emit_char('(');\n    for (i = l1 = 0, ref2 = p.tensor.dim[j]; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (j + 1 === p.tensor.ndim) {\n        emit_expr(p.tensor.elem[k]);\n        k = k + 1;\n      } else {\n        k = emit_tensor_inner(p, j + 1, k);\n      }\n      if (i + 1 < p.tensor.dim[j]) {\n        __emit_char(',');\n      }\n    }\n    __emit_char(')');\n    return k;\n  };\n\n  // 'product' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the product at the top of the stack\n  Eval_product = function() {\n    var body, i, indexVariable, j, k, l1, oldIndexVariableValue, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    oldIndexVariableValue = get_binding(indexVariable);\n    push_integer(1);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      if (DEBUG) {\n        console.log(\"product - factor 1: \" + stack[tos - 1].toString());\n        console.log(\"product - factor 2: \" + stack[tos - 2].toString());\n      }\n      multiply();\n      if (DEBUG) {\n        console.log(\"product - result: \" + stack[tos - 1].toString());\n      }\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, oldIndexVariableValue);\n  };\n\n  //  Add rational numbers\n\n  //  Input:    tos-2    addend\n\n  //      tos-1    addend\n\n  //  Output:    sum on stack\n  qadd = function() {\n    var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;\n    // a, qadd_ab, b, qadd_ba, c are all bigNum\n    // we are adding the fractions qadd_frac1 + qadd_frac2 i.e.\n    // qadd_frac1.q.a/qadd_frac1.q.b + qadd_frac2.q.a/qadd_frac2.q.b\n    qadd_frac2 = pop();\n    qadd_frac1 = pop();\n    qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);\n    qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);\n    qadd_numerator = madd(qadd_ab, qadd_ba);\n    //mfree(qadd_ab)\n    //mfree(qadd_ba)\n\n    // zero?\n    if (MZERO(qadd_numerator)) {\n      //console.log \"qadd IS ZERO\"\n      //mfree(qadd_numerator)\n      push(zero);\n      return;\n    }\n    qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);\n    gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);\n    //console.log \"gcd(\"+qadd_numerator+\",\"+qadd_denominator+\"): \" + gcdBetweenNumeratorAndDenominator\n    gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);\n    //console.log \"qadd qadd_denominator: \" + qadd_denominator\n    //console.log \"qadd gcdBetweenNumeratorAndDenominator: \" + gcdBetweenNumeratorAndDenominator\n    resultSum = new U();\n    resultSum.k = NUM;\n    resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);\n    resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);\n    //console.log \"qadd resultSum.q.a: \" + resultSum.q.a\n    //console.log \"qadd resultSum.q.b: \" + resultSum.q.b\n\n    //mfree(qadd_numerator)\n    //mfree(qadd_denominator)\n    //mfree(gcdBetweenNumeratorAndDenominator)\n    return push(resultSum);\n  };\n\n  //console.log \"qadd result: \" + resultSum\n\n  //  Divide rational numbers\n\n  //  Input:    tos-2    dividend\n\n  //      tos-1    divisor\n\n  //  Output:    quotient on stack\n  qdiv = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p2.q.a)) {\n      stop(\"divide by zero\");\n    }\n    if (MZERO(p1.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.b);\n    bb = mmul(p1.q.b, p2.q.a);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    push(p1);\n    return restore();\n  };\n\n  //  Multiply rational numbers\n\n  //  Input:    tos-2    multiplicand\n\n  //      tos-1    multiplier\n\n  //  Output:    product on stack\n  qmul = function() {\n    var aa, bb, c;\n    save();\n    p2 = pop();\n    p1 = pop();\n    // zero?\n    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {\n      push(zero);\n      restore();\n      return;\n    }\n    aa = mmul(p1.q.a, p2.q.a);\n    bb = mmul(p1.q.b, p2.q.b);\n    c = mgcd(aa, bb);\n    c = makeSignSameAs(c, bb);\n    p1 = new U();\n    p1.k = NUM;\n    p1.q.a = mdiv(aa, c);\n    p1.q.b = mdiv(bb, c);\n    //mfree(aa)\n    //mfree(bb)\n    push(p1);\n    return restore();\n  };\n\n  // Rational power function\n  qpow = function() {\n    save();\n    qpowf();\n    return restore();\n  };\n\n  //define BASE p1\n  //define EXPO p2\n  qpowf = function() {\n    var a, b, expo, t, x, y;\n    expo = 0;\n    //unsigned int a, b, *t, *x, *y\n    p2 = pop();\n    p1 = pop();\n    if (isplusone(p1) || isZeroAtomOrTensor(p2)) { // p1 is BASE  # p2 is EXPO\n      push_integer(1);\n      return;\n    }\n    // if (-1)^(1/2) -> leave it as is\n    if (isminusone(p1) && isoneovertwo(p2)) { // p1 is BASE  # p2 is EXPO\n      push(imaginaryunit);\n      return;\n    }\n    // if base is zero then return 0\n    if (isZeroAtomOrTensor(p1)) { // p1 is BASE\n      if (isnegativenumber(p2)) { // p2 is EXPO\n        stop(\"divide by zero\");\n      }\n      push(zero);\n      return;\n    }\n    // if exponent is 1 then return base\n    if (isplusone(p2)) { // p2 is EXPO\n      push(p1);\n      return;\n    }\n    // if exponent is integer then power\n    if (isinteger(p2)) { // p2 is EXPO\n      push(p2);\n      expo = pop_integer();\n      if (isNaN(expo)) {\n        // expo greater than 32 bits\n        push_symbol(POWER);\n        push(p1);\n        push(p2);\n        list(3);\n        return;\n      }\n      x = mpow(p1.q.a, Math.abs(expo));\n      y = mpow(p1.q.b, Math.abs(expo));\n      if (expo < 0) {\n        t = x;\n        x = y;\n        y = t;\n        x = makeSignSameAs(x, y);\n        y = makePositive(y);\n      }\n      p3 = new U();\n      p3.k = NUM;\n      p3.q.a = x;\n      p3.q.b = y;\n      push(p3);\n      return;\n    }\n    // from here on out the exponent is NOT an integer\n\n    // if base is -1 then normalize polar angle\n    if (isminusone(p1)) { // p1 is BASE\n      push(p2);\n      normalize_angle();\n      return;\n    }\n    // if base is negative then (-N)^M -> N^M * (-1)^M\n    if (isnegativenumber(p1)) { // p1 is BASE\n      push(p1);\n      negate();\n      push(p2);\n      qpow();\n      push_integer(-1);\n      push(p2);\n      qpow();\n      multiply();\n      return;\n    }\n    if (!isinteger(p1)) { // p1 is BASE\n      push(p1);\n      mp_numerator();\n      push(p2);\n      qpow();\n      push(p1);\n      mp_denominator();\n      push(p2);\n      negate();\n      qpow();\n      multiply();\n      return;\n    }\n    // At this point p1 (BASE) is a positive integer.\n\n    // If p1 (BASE) is small then factor it.\n    if (is_small_integer(p1)) { // p1 is BASE\n      push(p1);\n      push(p2);\n      quickfactor();\n      return;\n    }\n    if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) { // p2 is EXPO\n      push_symbol(POWER);\n      push(p1); // p1 is BASE\n      push(p2);\n      list(3);\n      return;\n    }\n    a = p2.q.a;\n    b = p2.q.b;\n    x = mroot(p1.q.a, b);\n    if (x === 0) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    y = mpow(x, a);\n    //mfree(x)\n    p3 = new U();\n    p3.k = NUM;\n    if (p2.q.a.isNegative()) { // p2 is EXPO\n      p3.q.a = bigInt(1);\n      p3.q.b = y;\n    } else {\n      p3.q.a = y;\n      p3.q.b = bigInt(1);\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Normalize the angle of unit imaginary, i.e. (-1) ^ N\n\n  //  Input:    N on stack (must be rational, not float)\n\n  //  Output:    Result on stack\n\n  //  Note:\n\n  //  n = q * d + r\n\n  //  Example:\n  //            n  d  q  r\n\n  //  (-1)^(8/3)  ->   (-1)^(2/3)  8  3  2  2\n  //  (-1)^(7/3)  ->   (-1)^(1/3)  7  3  2  1\n  //  (-1)^(5/3)  ->  -(-1)^(2/3)  5  3  1  2\n  //  (-1)^(4/3)  ->  -(-1)^(1/3)  4  3  1  1\n  //  (-1)^(2/3)  ->   (-1)^(2/3)  2  3  0  2\n  //  (-1)^(1/3)  ->   (-1)^(1/3)  1  3  0  1\n\n  //  (-1)^(-1/3)  ->  -(-1)^(2/3)  -1  3  -1  2\n  //  (-1)^(-2/3)  ->  -(-1)^(1/3)  -2  3  -1  1\n  //  (-1)^(-4/3)  ->   (-1)^(2/3)  -4  3  -2  2\n  //  (-1)^(-5/3)  ->   (-1)^(1/3)  -5  3  -2  1\n  //  (-1)^(-7/3)  ->  -(-1)^(2/3)  -7  3  -3  2\n  //  (-1)^(-8/3)  ->  -(-1)^(1/3)  -8  3  -3  1\n\n  //-----------------------------------------------------------------------------\n\n  //define A p1\n  //define Q p2\n  //define R p3\n  normalize_angle = function() {\n    save();\n    p1 = pop();\n    if (isinteger(p1)) { // p1 is A\n      if (p1.q.a.isOdd()) { // p1 is A\n        push_integer(-1); // odd exponent\n      } else {\n        push_integer(1); // even exponent\n      }\n      restore();\n      return;\n    }\n    // floor\n    push(p1);\n    bignum_truncate();\n    p2 = pop();\n    if (isnegativenumber(p1)) { // p1 is A\n      push(p2); // p2 is Q\n      push_integer(-1);\n      add();\n      p2 = pop(); // p2 is Q\n    }\n    \n    // remainder (always positive)\n    push(p1);\n    push(p2);\n    subtract();\n    p3 = pop();\n    push_symbol(POWER);\n    push_integer(-1);\n    push(p3); // p3 is R\n    list(3);\n    // negate if quotient is odd\n    if (p2.q.a.isOdd()) { // p2 is Q\n      negate();\n    }\n    return restore();\n  };\n\n  is_small_integer = function(p) {\n    return isSmall(p.q.a);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Factor small numerical powers\n\n  //  Input:    tos-2    Base (positive integer < 2^31 - 1)\n\n  //      tos-1    Exponent\n\n  //  Output:    Expr on stack\n\n  //-----------------------------------------------------------------------------\n\n  //define BASE p1\n  //define EXPO p2\n  quickfactor = function() {\n    var h, i, l1, n, ref2, stackIndex;\n    i = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    push(p1);\n    factor_small_number();\n    n = tos - h;\n    stackIndex = h;\n    for (i = l1 = 0, ref2 = n; l1 < ref2; i = l1 += 2) {\n      push(stack[stackIndex + i]);\n      push(stack[stackIndex + i + 1]);\n      push(p2);\n      multiply();\n      quickpower();\n    }\n    // stack has n results from factor_number_raw()\n\n    // on top of that are all the expressions from quickpower()\n\n    // multiply the quickpower() results\n    multiply_all(tos - h - n);\n    p1 = pop();\n    moveTos(h);\n    push(p1);\n    return restore();\n  };\n\n  // p1 (BASE) is a prime number so power is simpler\n  quickpower = function() {\n    var expo;\n    expo = 0;\n    save();\n    p2 = pop();\n    p1 = pop();\n    push(p2);\n    bignum_truncate();\n    p3 = pop();\n    push(p2);\n    push(p3);\n    subtract();\n    p4 = pop();\n    if (!isZeroAtomOrTensor(p4)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p4);\n      list(3);\n    }\n    push(p3);\n    expo = pop_integer();\n    if (isNaN(expo)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p3);\n      list(3);\n      restore();\n      return;\n    }\n    if (expo === 0) {\n      restore();\n      return;\n    }\n    push(p1);\n    bignum_power_number(expo);\n    return restore();\n  };\n\n  //if SELFTEST\n\n  // Divide polynomials\n  Eval_quotient = function() {\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    push(cadddr(p1));\n    Eval();\n    p1 = pop();\n    if (p1 === symbol(NIL)) {\n      p1 = symbol(SYMBOL_X);\n    }\n    push(p1);\n    return divpoly();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Divide polynomials\n\n  //  Input:    tos-3    Dividend\n\n  //      tos-2    Divisor\n\n  //      tos-1    x\n\n  //  Output:    tos-1    Quotient\n\n  //-----------------------------------------------------------------------------\n\n  //define DIVIDEND p1\n  //define DIVISOR p2\n  //define X p3\n  //define Q p4\n  //define QUOTIENT p5\n  divpoly = function() {\n    var dividend, divisor, h, i, l1, m, n, ref2, x;\n    h = 0;\n    i = 0;\n    m = 0;\n    n = 0;\n    x = 0;\n    //U **dividend, **divisor\n    save();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    h = tos;\n    dividend = tos;\n    m = coeff(p3, p1) - 1;\n    divisor = tos;\n    n = coeff(p3, p2) - 1;\n    x = m - n;\n    push_integer(0);\n    p5 = pop();\n    while (x >= 0) {\n      push(stack[dividend + m]);\n      push(stack[divisor + n]);\n      divide();\n      p4 = pop();\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        push(stack[dividend + x + i]);\n        push(stack[divisor + i]);\n        push(p4);\n        multiply();\n        subtract();\n        stack[dividend + x + i] = pop();\n      }\n      push(p5);\n      push(p4);\n      push(p3);\n      push_integer(x);\n      power();\n      multiply();\n      add();\n      p5 = pop();\n      m--;\n      x--;\n    }\n    moveTos(h);\n    push(p5);\n    return restore();\n  };\n\n  DEBUG_RATIONALIZE = false;\n\n  Eval_rationalize = function() {\n    push(cadr(p1));\n    Eval();\n    return rationalize();\n  };\n\n  rationalize = function() {\n    var x;\n    x = expanding;\n    yyrationalize();\n    return expanding = x;\n  };\n\n  yyrationalize = function() {\n    var commonDenominator, eachTerm, theArgument;\n    theArgument = pop();\n    if (istensor(theArgument)) {\n      __rationalize_tensor(theArgument);\n      return;\n    }\n    expanding = 0;\n    if (car(theArgument) !== symbol(ADD)) {\n      push(theArgument);\n      return;\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the input expr: \" + theArgument);\n    }\n    // get new denominator\n    push(one);\n    multiply_denominators(theArgument);\n    commonDenominator = pop();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: this is the new denominator: \" + commonDenominator);\n    }\n    // multiply each term by new denominator\n    push(zero);\n    eachTerm = cdr(theArgument);\n    while (iscons(eachTerm)) {\n      if (DEBUG_RATIONALIZE) {\n        console.log(\"term: \" + car(eachTerm));\n      }\n      push(commonDenominator);\n      push(car(eachTerm));\n      multiply();\n      add();\n      eachTerm = cdr(eachTerm);\n    }\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: original terms times new denominator: \" + stack[tos - 1]);\n    }\n    // collect common factors\n    Condense();\n    if (DEBUG_RATIONALIZE) {\n      console.log(\"rationalize: after factoring: \" + stack[tos - 1]);\n    }\n    // divide by common denominator\n    push(commonDenominator);\n    divide();\n    if (DEBUG_RATIONALIZE) {\n      return console.log(\"rationalize: after dividing by new denom. (and we're done): \" + stack[tos - 1]);\n    }\n  };\n\n  multiply_denominators = function(p) {\n    var results;\n    if (car(p) === symbol(ADD)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_term(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_term(p);\n    }\n  };\n\n  multiply_denominators_term = function(p) {\n    var results;\n    if (car(p) === symbol(MULTIPLY)) {\n      p = cdr(p);\n      results = [];\n      while (iscons(p)) {\n        multiply_denominators_factor(car(p));\n        results.push(p = cdr(p));\n      }\n      return results;\n    } else {\n      return multiply_denominators_factor(p);\n    }\n  };\n\n  multiply_denominators_factor = function(p) {\n    if (car(p) !== symbol(POWER)) {\n      return;\n    }\n    push(p);\n    p = caddr(p);\n    // like x^(-2) ?\n    if (isnegativenumber(p)) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // like x^(-a) ?\n    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {\n      inverse();\n      __lcm();\n      return;\n    }\n    // no match\n    return pop();\n  };\n\n  __rationalize_tensor = function(theTensor) {\n    var i, l1, n, ref2;\n    i = 0;\n    push(theTensor);\n    Eval();\n    theTensor = pop();\n    if (!istensor(theTensor)) { // might be zero\n      push(theTensor);\n      return;\n    }\n    n = theTensor.tensor.nelem;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(theTensor.tensor.elem[i]);\n      rationalize();\n      theTensor.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(theTensor);\n    return push(theTensor);\n  };\n\n  __lcm = function() {\n    save();\n    p1 = pop();\n    p2 = pop();\n    push(p1);\n    push(p2);\n    multiply();\n    push(p1);\n    push(p2);\n    gcd();\n    divide();\n    return restore();\n  };\n\n  Eval_real = function() {\n    push(cadr(p1));\n    Eval();\n    return real();\n  };\n\n  real = function() {\n    save();\n    rect();\n    p1 = pop();\n    push(p1);\n    push(p1);\n    conjugate();\n    add();\n    push_integer(2);\n    divide();\n    return restore();\n  };\n\n  DEBUG_RECT = false;\n\n  Eval_rect = function() {\n    push(cadr(p1));\n    Eval();\n    return rect();\n  };\n\n  rect = function() {\n    var input;\n    save();\n    p1 = pop();\n    input = p1;\n    if (DEBUG_RECT) {\n      console.log(\"RECT of \" + input);\n    }\n    if (DEBUG_RECT) {\n      console.log(\"any clock forms in : \" + input + \" ? \" + findPossibleClockForm(input));\n    }\n    // if we assume real variables, then the\n    // rect of any symbol is the symbol itself\n    // (note that 'i' is not a symbol, it's made of (-1)^(1/2))\n    // otherwise we have to leave unevalled\n    if (issymbol(p1)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n        push(p1);\n      } else {\n        push_symbol(YYRECT);\n        push(p1);\n        list(2);\n      }\n    } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !findPossibleExponentialForm(p1) && !findPossibleClockForm(p1) && !(Find(p1, symbol(SIN)) && Find(p1, symbol(COS)) && Find(p1, imaginaryunit))) { // no polar form?\n      if (DEBUG_RECT) {\n        console.log(\" rect: simple symbol: \" + input);\n      }\n      push(p1);\n    // ib\n    } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {\n      push(p1);\n    // sum\n    } else if (car(p1) === symbol(ADD)) {\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is a sum \");\n      }\n      push_integer(0);\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        rect();\n        add();\n        p1 = cdr(p1);\n      }\n    } else {\n      // try to get to the rectangular form by doing\n      // abs(p1) * (cos (theta) + i * sin(theta))\n      // where theta is arg(p1)\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" is NOT a sum \");\n      }\n      push(p1);\n      abs();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" abs: \" + stack[tos - 1].toString());\n      }\n      push(p1);\n      arg();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" arg of \" + p1 + \" : \" + stack[tos - 1].toString());\n      }\n      p1 = pop();\n      push(p1);\n      cosine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cosine: \" + stack[tos - 1].toString());\n      }\n      push(imaginaryunit);\n      push(p1);\n      sine();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" i * sine: \" + stack[tos - 1].toString());\n      }\n      add();\n      if (DEBUG_RECT) {\n        console.log(\" rect - \" + input + \" cos + i * sine: \" + stack[tos - 1].toString());\n      }\n      multiply();\n    }\n    restore();\n    if (DEBUG_RECT) {\n      return console.log(\"rect of \" + input + \" : \" + stack[tos - 1]);\n    }\n  };\n\n  //define POLY p1\n  //define X p2\n  //define A p3\n  //define B p4\n  //define C p5\n  //define Y p6\n  show_power_debug = false;\n\n  performing_roots = false;\n\n  Eval_roots = function() {\n    // this transforms simple \"equation\" forms into\n    // something that can be processed. E.g., say, y = 3x - 2\n    // A == B -> A - B\n    // A = B -> A - B\n    p2 = cadr(p1);\n    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n      push(cadr(p2));\n      Eval();\n      push(caddr(p2));\n      Eval();\n      subtract();\n    } else {\n      push(p2);\n      Eval();\n      p2 = pop();\n      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {\n        push(cadr(p2));\n        Eval();\n        push(caddr(p2));\n        Eval();\n        subtract();\n      } else {\n        push(p2);\n      }\n    }\n    // 2nd arg, x\n    push(caddr(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    p2 = pop();\n    p1 = pop();\n    if (!ispolyexpandedform(p1, p2)) {\n      stop(\"roots: 1st argument is not a polynomial in the variable \" + p2);\n    }\n    push(p1);\n    push(p2);\n    return roots();\n  };\n\n  hasImaginaryCoeff = function(k) {\n    var h, i, imaginaryCoefficients, l1, ref2;\n    //polycoeff = tos\n    imaginaryCoefficients = false;\n    h = tos;\n    for (i = l1 = ref2 = k; l1 > 0; i = l1 += -1) {\n      //console.log \"hasImaginaryCoeff - coeff.:\" + stack[tos-i].toString()\n      if (iscomplexnumber(stack[tos - i])) {\n        imaginaryCoefficients = true;\n        break;\n      }\n    }\n    return imaginaryCoefficients;\n  };\n\n  isSimpleRoot = function(k) {\n    var h, i, isSimpleRootPolynomial, l1, ref2;\n    //polycoeff = tos\n\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    if (k > 2) {\n      isSimpleRootPolynomial = true;\n      h = tos;\n      if (isZeroAtomOrTensor(stack[tos - k])) {\n        isSimpleRootPolynomial = false;\n      }\n      for (i = l1 = ref2 = k - 1; l1 > 1; i = l1 += -1) {\n        if (!isZeroAtomOrTensor(stack[tos - i])) {\n          isSimpleRootPolynomial = false;\n          break;\n        }\n      }\n    } else {\n      isSimpleRootPolynomial = false;\n    }\n    return isSimpleRootPolynomial;\n  };\n\n  normalisedCoeff = function(variable, polynomial) {\n    var divideBy, i, k, l1, m1, miniStack, ref2, ref3;\n    k = coeff(variable, polynomial);\n    //console.log(\"->\" + tos)\n    divideBy = stack[tos - 1];\n    miniStack = [];\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      miniStack.push(pop());\n    }\n//console.log(tos)\n    for (i = m1 = ref3 = k - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); i = ref3 <= 0 ? ++m1 : --m1) {\n      push(miniStack[i]);\n      push(divideBy);\n      divide();\n    }\n    //console.log(tos)\n    return k;\n  };\n\n  // takes the polynomial and the\n  // variable on the stack\n  roots = function() {\n    var h, i, k, l1, lastCoeff, leadingCoeff, n, ref2;\n    h = 0;\n    i = 0;\n    n = 0;\n    if (DEBUG) {\n      console.log(\"roots: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    save();\n    // the simplification of nested radicals uses\n    // \"roots\", which in turn uses simplification\n    // of nested radicals. Usually there is no problem,\n    // one level of recursion does the job. Beyond that,\n    // we probably got stuck in a strange case of infinite\n    // recursion, so bail out and return NIL.\n    if (recursionLevelNestedRadicalsRemoval > 1) {\n      pop();\n      pop();\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    performing_roots = true;\n    h = tos - 2;\n    if (DEBUG) {\n      console.log(\"roots checking if \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n    }\n    p2 = pop();\n    p1 = pop();\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (isSimpleRoot(k)) {\n      if (DEBUG) {\n        console.log(\"yes, \" + stack[tos - 1].toString() + \" is a case of simple roots\");\n      }\n      lastCoeff = stack[tos - k];\n      leadingCoeff = stack[tos - 1];\n      moveTos(tos - k);\n      pop();\n      pop();\n      getSimpleRoots(k, leadingCoeff, lastCoeff);\n    } else {\n      moveTos(tos - k);\n      roots2();\n    }\n    n = tos - h;\n    if (n === 0) {\n      stop(\"roots: the polynomial is not factorable, try nroots\");\n    }\n    if (n === 1) {\n      performing_roots = false;\n      restore();\n      return;\n    }\n    sort_stack(n);\n    p1 = alloc_tensor(n);\n    p1.tensor.ndim = 1;\n    p1.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p1.tensor.elem[i] = stack[h + i];\n    }\n    moveTos(h);\n    push(p1);\n    restore();\n    return performing_roots = false;\n  };\n\n  // ok to generate these roots take a look at their form\n  // in the case of even and odd exponents here:\n  // http://www.wolframalpha.com/input/?i=roots+x%5E14+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+ax%5E14+%2B+b\n  // http://www.wolframalpha.com/input/?i=roots+x%5E15+%2B+1\n  // http://www.wolframalpha.com/input/?i=roots+a*x%5E15+%2B+b\n  getSimpleRoots = function(n, leadingCoeff, lastCoeff) {\n    var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;\n    if (DEBUG) {\n      console.log(\"getSimpleRoots\");\n    }\n    save();\n    //tos-n    Coefficient of x^0\n    //tos-1    Coefficient of x^(n-1)\n    n = n - 1;\n    push(lastCoeff);\n    push_rational(1, n);\n    power();\n    push(leadingCoeff);\n    push_rational(1, n);\n    power();\n    divide();\n    commonPart = pop();\n    if (n % 2 === 0) {\n      for (rootsOfOne = l1 = 1, ref2 = n; l1 <= ref2; rootsOfOne = l1 += 2) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        aSol = pop();\n        push(aSol);\n        push(aSol);\n        negate();\n      }\n    } else {\n      for (rootsOfOne = m1 = 1, ref3 = n; (1 <= ref3 ? m1 <= ref3 : m1 >= ref3); rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {\n        push(commonPart);\n        push_integer(-1);\n        push_rational(rootsOfOne, n);\n        power();\n        multiply();\n        if (rootsOfOne % 2 === 0) {\n          negate();\n        }\n      }\n    }\n    return restore();\n  };\n\n  roots2 = function() {\n    var k;\n    save();\n    if (DEBUG) {\n      console.log(\"roots2: \" + stack[tos - 1].toString() + \" \" + stack[tos - 2].toString());\n    }\n    p2 = pop(); // the polynomial variable\n    p1 = pop(); // the polynomial\n    push(p1);\n    push(p2);\n    k = normalisedCoeff(p2, p1);\n    if (!hasImaginaryCoeff(k)) {\n      moveTos(tos - k);\n      factorpoly();\n      p1 = pop();\n    } else {\n      moveTos(tos - k);\n      pop();\n      pop();\n    }\n    if (car(p1) === symbol(MULTIPLY)) {\n      p1 = cdr(p1);\n      // scan through all the factors\n      // and find the roots of each of them\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        roots3();\n        p1 = cdr(p1);\n      }\n    } else {\n      push(p1);\n      push(p2);\n      roots3();\n    }\n    return restore();\n  };\n\n  roots3 = function() {\n    var n;\n    save();\n    p2 = pop();\n    p1 = pop();\n    if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {\n      n = normalisedCoeff(p2, cadr(p1));\n      mini_solve(n);\n    } else if (ispolyexpandedform(p1, p2)) {\n      n = normalisedCoeff(p2, p1);\n      mini_solve(n);\n    }\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Input:    stack[tos - 2]    polynomial\n\n  //      stack[tos - 1]    dependent symbol\n\n  //  Output:    stack      roots on stack\n\n  //            (input args are popped first)\n\n  //-----------------------------------------------------------------------------\n\n  // note that for many quadratic, cubic and quartic polynomials we don't\n  // actually end up using the quadratic/cubic/quartic formulas in here,\n  // since there is a chance we factored the polynomial and in so\n  // doing we found some solutions and lowered the degree.\n  mini_solve = function(n) {\n    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;\n    //console.log \"mini_solve >>>>>>>>>>>>>>>>>>>>>>>> tos:\" + tos\n    save();\n    // AX + B, X = -B/A\n    if (n === 2) {\n      //console.log \"mini_solve >>>>>>>>> 1st degree\"\n      p3 = pop();\n      p4 = pop();\n      push(p4);\n      push(p3);\n      divide();\n      negate();\n      restore();\n      return;\n    }\n    // AX^2 + BX + C, X = (-B +/- (B^2 - 4AC)^(1/2)) / (2A)\n    if (n === 3) {\n      //console.log \"mini_solve >>>>>>>>> 2nd degree\"\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      \n      // B^2\n      push(p4);\n      push_integer(2);\n      power();\n      // 4AC\n      push_integer(4);\n      push(p3);\n      multiply();\n      push(p5);\n      multiply();\n      // B^2 - 4AC\n      subtract();\n      //(B^2 - 4AC)^(1/2)\n      push_rational(1, 2);\n      power();\n      //p6 is (B^2 - 4AC)^(1/2)\n      p6 = pop();\n      push(p6);\n      push(p4);\n      subtract(); // -B + (B^2 - 4AC)^(1/2)\n      \n      // 1/2A\n      push(p3);\n      push_integer(2);\n      multiply();\n      divide();\n      //simplify()\n      //rationalize()\n      // tos - 1 now is 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      push(p6);\n      push(p4);\n      add();\n      // tos - 1 now is  B + (B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      negate();\n      // tos - 1 now is  -B -(B^2 - 4AC)^(1/2)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n\n      // 1/2A again\n      push(p3);\n      divide();\n      push_rational(1, 2);\n      multiply();\n      //simplify()\n      //rationalize()\n      // tos - 1: 2nd root: (-B - (B^2 - 4AC)^(1/2)) / (2A)\n      // tos - 2: 1st root: (-B + (B^2 - 4AC)^(1/2)) / (2A)\n      restore();\n      return;\n    }\n    //if (n == 4)\n    if (n === 4 || n === 5) {\n      p3 = pop(); // A\n      p4 = pop(); // B\n      p5 = pop(); // C\n      p6 = pop(); // D\n      \n      // C - only related calculations\n      push(p5);\n      push(p5);\n      multiply();\n      R_c2 = pop();\n      push(R_c2);\n      push(p5);\n      multiply();\n      R_c3 = pop();\n      // B - only related calculations\n      push(p4);\n      push(p4);\n      multiply();\n      R_b2 = pop();\n      push(R_b2);\n      push(p4);\n      multiply();\n      R_b3 = pop();\n      push(R_b3);\n      push(p6);\n      multiply();\n      R_b3_d = pop();\n      push(R_b3_d);\n      push_integer(-4);\n      multiply();\n      R_m4_b3_d = pop();\n      push(R_b3);\n      push_integer(2);\n      multiply();\n      R_2_b3 = pop();\n      // A - only related calculations\n      push(p3);\n      push(p3);\n      multiply();\n      R_a2 = pop();\n      push(R_a2);\n      push(p3);\n      multiply();\n      R_a3 = pop();\n      push_integer(3);\n      push(p3);\n      multiply();\n      R_3_a = pop();\n      push(R_a2);\n      push(p6);\n      multiply();\n      R_a2_d = pop();\n      push(R_a2_d);\n      push(p6);\n      multiply();\n      R_a2_d2 = pop();\n      push(R_a2_d);\n      push_integer(27);\n      multiply();\n      R_27_a2_d = pop();\n      push(R_a2_d2);\n      push_integer(-27);\n      multiply();\n      R_m27_a2_d2 = pop();\n      push(R_3_a);\n      push_integer(2);\n      multiply();\n      R_6_a = pop();\n      // mixed calculations\n      push(p3);\n      push(p5);\n      multiply();\n      R_a_c = pop();\n      push(R_a_c);\n      push(p4);\n      multiply();\n      R_a_b_c = pop();\n      push(R_a_b_c);\n      push(p6);\n      multiply();\n      R_a_b_c_d = pop();\n      push(R_a_c);\n      push_integer(3);\n      multiply();\n      R_3_a_c = pop();\n      push_integer(-4);\n      push(p3);\n      push(R_c3);\n      multiply();\n      multiply();\n      R_m4_a_c3 = pop();\n      push(R_a_b_c);\n      push_integer(9);\n      multiply();\n      negate();\n      R_m9_a_b_c = pop();\n      push(R_a_b_c_d);\n      push_integer(18);\n      multiply();\n      R_18_a_b_c_d = pop();\n      push(R_b2);\n      push(R_3_a_c);\n      subtract();\n      R_DELTA0 = pop();\n      push(R_b2);\n      push(R_c2);\n      multiply();\n      R_b2_c2 = pop();\n      push(p4);\n      negate();\n      push(R_3_a);\n      divide();\n      R_m_b_over_3a = pop();\n      if (n === 4) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< \");\n        }\n        //console.log \">>>> A:\" + p3.toString()\n        //console.log \">>>> B:\" + p4.toString()\n        //console.log \">>>> C:\" + p5.toString()\n        //console.log \">>>> D:\" + p6.toString()\n        if (DEBUG) {\n          console.log(\"cubic: D0: \" + R_DELTA0.toString());\n        }\n        push(R_DELTA0);\n        push_integer(3);\n        power();\n        push_integer(4);\n        multiply();\n        R_4_DELTA03 = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_toBeCheckedIfZero = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D0 as float: \" + R_DELTA0_toBeCheckedIfZero.toString());\n        }\n        //if isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)\n        //  console.log \" *********************************** D0 IS ZERO\"\n\n        // DETERMINANT\n        push(R_18_a_b_c_d);\n        push(R_m4_b3_d);\n        push(R_b2_c2);\n        push(R_m4_a_c3);\n        push(R_m27_a2_d2);\n        add();\n        add();\n        add();\n        add();\n        simplify();\n        absValFloat();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"cubic: DETERMINANT: \" + R_determinant.toString());\n        }\n        // R_DELTA1\n        push(R_2_b3);\n        push(R_m9_a_b_c);\n        push(R_27_a2_d);\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"cubic: D1: \" + R_DELTA1.toString());\n        }\n        // R_Q\n        push(R_DELTA1);\n        push_integer(2);\n        power();\n        push(R_4_DELTA03);\n        subtract();\n        push_rational(1, 2);\n        power();\n        simplify();\n        R_Q = pop();\n        if (isZeroAtomOrTensor(R_determinant)) {\n          if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is zero\");\n            }\n            push(R_m_b_over_3a); // just same solution three times\n            restore();\n            return;\n          } else {\n            if (DEBUG) {\n              console.log(\" cubic: DETERMINANT IS ZERO and delta0 is not zero\");\n            }\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            push(p4);\n            push(p5);\n            multiply();\n            subtract();\n            push(R_DELTA0);\n            push_integer(2);\n            multiply();\n            divide(); // first solution\n            root_solution = pop();\n            push(root_solution); // pushing two of them on the stack\n            push(root_solution);\n            // second solution here\n            // 4abc\n            push(R_a_b_c);\n            push_integer(4);\n            multiply();\n            // -9a*a*d\n            push(p3);\n            push(p3);\n            push(p6);\n            push_integer(9);\n            multiply();\n            multiply();\n            multiply();\n            negate();\n            // -9*b^3\n            push(R_b3);\n            negate();\n            // sum the three terms\n            add();\n            add();\n            // denominator is a*delta0\n            push(p3);\n            push(R_DELTA0);\n            multiply();\n            // build the fraction\n            divide();\n            restore();\n            return;\n          }\n        }\n        C_CHECKED_AS_NOT_ZERO = false;\n        flipSignOFQSoCIsNotZero = false;\n        while (!C_CHECKED_AS_NOT_ZERO) {\n          // R_C\n          push(R_Q);\n          if (flipSignOFQSoCIsNotZero) {\n            negate();\n          }\n          push(R_DELTA1);\n          add();\n          push_rational(1, 2);\n          multiply();\n          push_rational(1, 3);\n          power();\n          simplify();\n          R_C = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C: \" + R_C.toString());\n          }\n          push(R_C);\n          simplify();\n          absValFloat();\n          R_C_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"cubic: C as absval and float: \" + R_C_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" cubic: C IS ZERO flipping the sign\");\n            }\n            flipSignOFQSoCIsNotZero = true;\n          } else {\n            C_CHECKED_AS_NOT_ZERO = true;\n          }\n        }\n        push(R_C);\n        push(R_3_a);\n        multiply();\n        R_3_a_C = pop();\n        push(R_3_a_C);\n        push_integer(2);\n        multiply();\n        R_6_a_C = pop();\n        // imaginary parts calculations\n        push(imaginaryunit);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        multiply();\n        i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        add();\n        one_plus_i_sqrt3 = pop();\n        push_integer(1);\n        push(i_sqrt3);\n        subtract();\n        one_minus_i_sqrt3 = pop();\n        push(R_C);\n        push(R_3_a);\n        divide();\n        R_C_over_3a = pop();\n        // first solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        negate(); // second term\n        push(R_DELTA0);\n        push(R_3_a_C);\n        divide();\n        negate(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // second solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_plus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_minus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        // third solution\n        push(R_m_b_over_3a); // first term\n        push(R_C_over_3a);\n        push(one_minus_i_sqrt3);\n        multiply();\n        push_integer(2);\n        divide(); // second term\n        push(one_plus_i_sqrt3);\n        push(R_DELTA0);\n        multiply();\n        push(R_6_a_C);\n        divide(); // third term\n        // now add the three terms together\n        add();\n        add();\n        simplify();\n        restore();\n        return;\n      }\n      // See http://www.sscc.edu/home/jdavidso/Math/Catalog/Polynomials/Fourth/Fourth.html\n      // for a description of general shapes and properties of fourth degree polynomials\n      if (n === 5) {\n        if (DEBUG) {\n          console.log(\">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< \");\n        }\n        p7 = pop(); // E\n        if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {\n          if (DEBUG) {\n            console.log(\"biquadratic case\");\n          }\n          push(p3);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(p5);\n          push(symbol(SECRETX));\n          multiply();\n          push(p7);\n          add();\n          add();\n          push(symbol(SECRETX));\n          roots();\n          biquadraticSolutions = pop();\n          ref2 = biquadraticSolutions.tensor.elem;\n          for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n            eachSolution = ref2[l1];\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            simplify();\n            push(eachSolution);\n            push_rational(1, 2);\n            power();\n            negate();\n            simplify();\n          }\n          restore();\n          return;\n        }\n        // D - only related calculations\n        push(p6);\n        push(p6);\n        multiply();\n        R_d2 = pop();\n        // E - only related calculations\n        push(p7);\n        push(p7);\n        multiply();\n        R_e2 = pop();\n        push(R_e2);\n        push(p7);\n        multiply();\n        R_e3 = pop();\n        // DETERMINANT\n        push_integer(256);\n        push(R_a3);\n        push(R_e3);\n        multiply();\n        multiply(); // first term 256 a^3 e^3\n        push_integer(-192);\n        push(R_a2_d);\n        push(R_e2);\n        push(p4);\n        multiply();\n        multiply();\n        multiply(); // second term -192 a^3 b d e^2\n        push_integer(-128);\n        push(R_a2);\n        push(R_c2);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // third term -128 a^2 c^2 e^2\n        push_integer(144);\n        push(R_a2_d2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fourth term 144 a^2 c d^2 e\n        push(R_m27_a2_d2);\n        push(R_d2);\n        multiply(); // fifth term -27 a^2 d^4\n        push_integer(144);\n        push(R_a_b_c);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // sixth term 144 a b^2 c e^2\n        push_integer(-6);\n        push(p3);\n        push(R_b2);\n        push(R_d2);\n        push(p7);\n        multiply();\n        multiply();\n        multiply();\n        multiply(); // seventh term -6 a b^2 d^2 e\n        push_integer(-80);\n        push(R_a_b_c_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // eigth term -80 a b c^2 d e\n        push_integer(18);\n        push(R_a_b_c_d);\n        push(R_d2);\n        multiply();\n        multiply(); // ninth term 18 a b c d^3\n        push_integer(16);\n        push(R_a_c);\n        push(R_c3);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // tenth term 16 a c^4 e\n        push_integer(-4);\n        push(R_a_c);\n        push(R_c2);\n        push(R_d2);\n        multiply();\n        multiply();\n        multiply(); // eleventh term -4 a c^3 d^2\n        push_integer(-27);\n        push(R_b3);\n        push(p4);\n        push(R_e2);\n        multiply();\n        multiply();\n        multiply(); // twelveth term -27 b^4 e^2\n        push_integer(18);\n        push(R_b3_d);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // thirteenth term 18 b^3 c d e\n        push(R_m4_b3_d);\n        push(R_d2);\n        multiply(); // fourteenth term -4 b^3 d^3\n        push_integer(-4);\n        push(R_b2_c2);\n        push(p5);\n        push(p7);\n        multiply();\n        multiply();\n        multiply(); // fifteenth term -4 b^2 c^3 e\n        push(R_b2_c2);\n        push(R_d2);\n        multiply(); // sixteenth term b^2 c^2 d^2\n        \n        // add together the sixteen terms by doing\n        // fifteen adds\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        add();\n        R_determinant = pop();\n        if (DEBUG) {\n          console.log(\"R_determinant: \" + R_determinant.toString());\n        }\n        // DELTA0\n        push(R_c2); // term one of DELTA0\n        push_integer(-3);\n        push(p4);\n        push(p6);\n        multiply();\n        multiply(); // term two of DELTA0\n        push_integer(12);\n        push(p3);\n        push(p7);\n        multiply();\n        multiply(); // term three of DELTA0\n        \n        // add the three terms together\n        add();\n        add();\n        R_DELTA0 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA0: \" + R_DELTA0.toString());\n        }\n        // DELTA1\n        push_integer(2);\n        push(R_c3);\n        multiply();\n        push_integer(-9);\n        push(p4);\n        push(p5);\n        push(p6);\n        multiply();\n        multiply();\n        multiply();\n        push_integer(27);\n        push(R_b2);\n        push(p7);\n        multiply();\n        multiply();\n        push_integer(27);\n        push(p3);\n        push(R_d2);\n        multiply();\n        multiply();\n        push_integer(-72);\n        push(R_a_c);\n        push(p7);\n        multiply();\n        multiply();\n        // add the five terms together\n        add();\n        add();\n        add();\n        add();\n        R_DELTA1 = pop();\n        if (DEBUG) {\n          console.log(\"R_DELTA1: \" + R_DELTA1.toString());\n        }\n        // p\n        push_integer(8);\n        push(R_a_c);\n        multiply();\n        push_integer(-3);\n        push(R_b2);\n        multiply();\n        add();\n        push_integer(8);\n        push(R_a2);\n        multiply();\n        divide();\n        R_p = pop();\n        if (DEBUG) {\n          console.log(\"p: \" + R_p.toString());\n        }\n        // q\n        push(R_b3);\n        push_integer(-4);\n        push(R_a_b_c);\n        multiply();\n        push_integer(8);\n        push(R_a2_d);\n        multiply();\n        add();\n        add();\n        push_integer(8);\n        push(R_a3);\n        multiply();\n        divide();\n        R_q = pop();\n        if (DEBUG) {\n          console.log(\"q: \" + R_q.toString());\n        }\n        if (DEBUG) {\n          console.log(\"tos 1 \" + tos);\n        }\n        if (!isZeroAtomOrTensor(p4)) {\n          if (DEBUG) {\n            console.log(\"tos 2 \" + tos);\n          }\n          push_integer(8);\n          push(p5);\n          push(p3);\n          multiply();\n          multiply();\n          push_integer(-3);\n          push(p4);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          divide();\n          R_p = pop();\n          if (DEBUG) {\n            console.log(\"p for depressed quartic: \" + R_p.toString());\n          }\n          push(p4);\n          push_integer(3);\n          power();\n          push_integer(-4);\n          push(p3);\n          push(p4);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          push_integer(8);\n          push(p6);\n          push(p3);\n          push_integer(2);\n          power();\n          multiply();\n          multiply();\n          add();\n          add();\n          push_integer(8);\n          push(p3);\n          push_integer(3);\n          power();\n          multiply();\n          divide();\n          R_q = pop();\n          if (DEBUG) {\n            console.log(\"q for depressed quartic: \" + R_q.toString());\n          }\n          // convert to depressed quartic\n          push(p4);\n          push_integer(4);\n          power();\n          push_integer(-3);\n          multiply();\n          push_integer(256);\n          push(R_a3);\n          push(p7);\n          multiply();\n          multiply();\n          push_integer(-64);\n          push(R_a2_d);\n          push(p4);\n          multiply();\n          multiply();\n          push_integer(16);\n          push(R_b2);\n          push(p3);\n          push(p5);\n          multiply();\n          multiply();\n          multiply();\n          add();\n          add();\n          add();\n          push_integer(256);\n          push(p3);\n          push_integer(4);\n          power();\n          multiply();\n          divide();\n          R_r = pop();\n          if (DEBUG) {\n            console.log(\"r for depressed quartic: \" + R_r.toString());\n          }\n          if (DEBUG) {\n            console.log(\"tos 4 \" + tos);\n          }\n          push(symbol(SECRETX));\n          push_integer(4);\n          power();\n          if (DEBUG) {\n            console.log(\"4 * x^4: \" + stack[tos - 1].toString());\n          }\n          push(R_p);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_p * x^2: \" + stack[tos - 1].toString());\n          }\n          push(R_q);\n          push(symbol(SECRETX));\n          multiply();\n          if (DEBUG) {\n            console.log(\"R_q * x: \" + stack[tos - 1].toString());\n          }\n          push(R_r);\n          if (DEBUG) {\n            console.log(\"R_r: \" + stack[tos - 1].toString());\n          }\n          add();\n          add();\n          add();\n          simplify();\n          if (DEBUG) {\n            console.log(\"solving depressed quartic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          depressedSolutions = pop();\n          if (DEBUG) {\n            console.log(\"depressedSolutions: \" + depressedSolutions);\n          }\n          ref3 = depressedSolutions.tensor.elem;\n          for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {\n            eachSolution = ref3[m1];\n            push(eachSolution);\n            push(p4);\n            push_integer(4);\n            push(p3);\n            multiply();\n            divide();\n            subtract();\n            simplify();\n            if (DEBUG) {\n              console.log(\"solution from depressed: \" + stack[tos - 1].toString());\n            }\n          }\n          restore();\n          return;\n        } else {\n          R_p = p5;\n          R_q = p6;\n          R_r = p7;\n          /*\n           * Descartes' solution\n           * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution\n           * finding the \"u\" in the depressed equation\n\n          push_integer(2)\n          push(R_p)\n          multiply()\n          coeff2 = pop()\n\n          push_integer(-4)\n          push(R_p)\n          push_integer(2)\n          power()\n          multiply()\n          push(R_r)\n          multiply()\n          coeff3 = pop()\n\n          push(R_q)\n          push_integer(2)\n          power()\n          negate()\n          coeff4 = pop()\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(3)\n          power()\n\n          push(coeff2)\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n          multiply()\n\n          push(coeff3)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(coeff4)\n\n          add()\n          add()\n          add()\n\n          console.log(\"Descarte's resolventCubic: \" +  stack[tos-1].toString())\n          push(symbol(SECRETX))\n\n          roots()\n\n          resolventCubicSolutions = pop()\n          console.log(\"Descarte's resolventCubic solutions: \" +  resolventCubicSolutions)\n          console.log(\"tos: \" +  tos)\n\n          R_u = null\n          #R_u = resolventCubicSolutions.tensor.elem[1]\n          for eachSolution in resolventCubicSolutions.tensor.elem\n            console.log(\"examining solution: \" +  eachSolution)\n            push(eachSolution)\n            push_integer(2)\n            multiply()\n            push(R_p)\n            add()\n\n            absValFloat()\n            toBeCheckedIFZero = pop()\n            console.log(\"abs value is: \" +  eachSolution)\n            if !isZeroAtomOrTensor(toBeCheckedIFZero)\n              R_u = eachSolution\n              break\n\n          console.log(\"chosen solution: \" +  R_u)\n\n          push(R_u)\n          negate()\n          R_s = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          add()\n          add()\n          push_integer(2)\n          divide()\n          R_t = pop()\n\n          push(R_p)\n          push(R_u)\n          push_integer(2)\n          power()\n          push(R_q)\n          push(R_u)\n          divide()\n          subtract()\n          add()\n          push_integer(2)\n          divide()\n          R_v = pop()\n\n           * factoring the quartic into two quadratics:\n\n           * now build the polynomial\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_s)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_t)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 1: \" + stack[tos-1].toString())\n\n          push(symbol(SECRETX))\n          push_integer(2)\n          power()\n\n          push(R_u)\n          push(symbol(SECRETX))\n          multiply()\n\n          push(R_v)\n\n          add()\n          add()\n\n          console.log(\"factored quartic 2: \" + stack[tos-1].toString())\n          pop()\n\n          restore()\n          return\n           */\n          // Ferrari's solution\n          // https://en.wikipedia.org/wiki/Quartic_function#Ferrari.27s_solution\n          // finding the \"m\" in the depressed equation\n          push_rational(5, 2);\n          push(R_p);\n          multiply();\n          coeff2 = pop();\n          push_integer(2);\n          push(R_p);\n          push_integer(2);\n          power();\n          multiply();\n          push(R_r);\n          subtract();\n          coeff3 = pop();\n          push(R_p);\n          push_integer(3);\n          power();\n          push_integer(2);\n          divide();\n          push_rational(-1, 2);\n          push(R_p);\n          push(R_r);\n          multiply();\n          multiply();\n          push_rational(-1, 8);\n          push(R_q);\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n          coeff4 = pop();\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          push(coeff2);\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push(coeff3);\n          push(symbol(SECRETX));\n          multiply();\n          push(coeff4);\n          add();\n          add();\n          add();\n          if (DEBUG) {\n            console.log(\"resolventCubic: \" + stack[tos - 1].toString());\n          }\n          push(symbol(SECRETX));\n          roots();\n          resolventCubicSolutions = pop();\n          if (DEBUG) {\n            console.log(\"resolventCubicSolutions: \" + resolventCubicSolutions);\n          }\n          R_m = null;\n          ref4 = resolventCubicSolutions.tensor.elem;\n          //R_m = resolventCubicSolutions.tensor.elem[1]\n          for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {\n            eachSolution = ref4[n1];\n            if (DEBUG) {\n              console.log(\"examining solution: \" + eachSolution);\n            }\n            push(eachSolution);\n            push_integer(2);\n            multiply();\n            push(R_p);\n            add();\n            absValFloat();\n            toBeCheckedIFZero = pop();\n            if (DEBUG) {\n              console.log(\"abs value is: \" + eachSolution);\n            }\n            if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {\n              R_m = eachSolution;\n              break;\n            }\n          }\n          if (DEBUG) {\n            console.log(\"chosen solution: \" + R_m);\n          }\n          push(R_m);\n          push_integer(2);\n          multiply();\n          push(R_p);\n          add();\n          push_rational(1, 2);\n          power();\n          simplify();\n          sqrtPPlus2M = pop();\n          push(R_q);\n          push_integer(2);\n          multiply();\n          push(sqrtPPlus2M);\n          divide();\n          simplify();\n          TwoQOversqrtPPlus2M = pop();\n          push(R_p);\n          push_integer(3);\n          multiply();\n          push(R_m);\n          push_integer(2);\n          multiply();\n          add();\n          ThreePPlus2M = pop();\n          // solution1\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution2\n          push(sqrtPPlus2M);\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          add();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          // solution3\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          add();\n          push_integer(2);\n          divide();\n          // solution4\n          push(sqrtPPlus2M);\n          negate();\n          push(ThreePPlus2M);\n          push(TwoQOversqrtPPlus2M);\n          subtract();\n          negate();\n          push_rational(1, 2);\n          power();\n          simplify();\n          subtract();\n          push_integer(2);\n          divide();\n          restore();\n          return;\n        }\n        // Q ---------------------------\n        push(R_determinant);\n        simplify();\n        absValFloat();\n        R_determinant_simplified_toCheckIfZero = pop();\n        push(R_DELTA0);\n        simplify();\n        absValFloat();\n        R_DELTA0_simplified_toCheckIfZero = pop();\n        S_CHECKED_AS_NOT_ZERO = false;\n        choiceOfRadicalInQSoSIsNotZero = 0;\n        while (!S_CHECKED_AS_NOT_ZERO) {\n          Q_CHECKED_AS_NOT_ZERO = false;\n          flipSignOFRadicalSoQIsNotZero = false;\n          while (!Q_CHECKED_AS_NOT_ZERO) {\n            // D1 under the outer radical\n            push(R_DELTA1);\n            // D1^2 under the inner radical\n            push(R_DELTA1);\n            push_integer(2);\n            power();\n            // 4*D0^3 under the inner radical\n            push_integer(-4);\n            push(R_DELTA0);\n            push_integer(3);\n            power();\n            multiply();\n            // addition under the inner radical\n            add();\n            // the second radical\n            push_rational(1, 2);\n            power();\n            if (flipSignOFRadicalSoQIsNotZero) {\n              negate();\n            }\n            // the addition under the outer radical\n            add();\n            // content of outer radical divided by two\n            push_integer(2);\n            divide();\n            if (DEBUG) {\n              console.log(\"content of cubic root: \" + stack[tos - 1].toString());\n            }\n            // outer radical calculation: cubic root\n            // now we actually have to find all the roots\n            // because we have to pick the one that makes S != 0\n            push_rational(1, 3);\n            power();\n            simplify();\n            R_principalCubicRoot = pop();\n            if (DEBUG) {\n              console.log(\"principal cubic root: \" + R_principalCubicRoot.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos : \" + tos);\n            }\n            if (choiceOfRadicalInQSoSIsNotZero === 0) {\n              if (DEBUG) {\n                console.log(\"chosing principal cubic root\");\n              }\n              push(R_principalCubicRoot);\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(-1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {\n              if (DEBUG) {\n                console.log(\"chosing cubic root beyond beyond principal\");\n              }\n              push(R_principalCubicRoot);\n              push_rational(-1, 2);\n              multiply();\n              push_integer(3);\n              push_rational(1, 2);\n              power();\n              push(imaginaryunit);\n              multiply();\n              push_rational(1, 2);\n              multiply();\n              push(R_principalCubicRoot);\n              multiply();\n              add();\n            }\n            simplify();\n            R_Q = pop();\n            if (DEBUG) {\n              console.log(\"Q \" + R_Q.toString());\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n            push(R_Q);\n            simplify();\n            absValFloat();\n            R_Q_simplified_toCheckIfZero = pop();\n            if (DEBUG) {\n              console.log(\"Q simplified and abs\" + R_Q_simplified_toCheckIfZero.toString());\n            }\n            if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && (!isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero))) {\n              if (DEBUG) {\n                console.log(\" *********************************** Q IS ZERO and it matters, flipping the sign\");\n              }\n              flipSignOFRadicalSoQIsNotZero = true;\n            } else {\n              Q_CHECKED_AS_NOT_ZERO = true;\n            }\n            if (DEBUG) {\n              console.log(\"tos: \" + tos);\n            }\n          }\n          // S\n          push_rational(-2, 3);\n          push(R_p);\n          multiply();\n          push(R_Q);\n          push(R_DELTA0);\n          push(R_Q);\n          divide();\n          add();\n          //rationalize()\n          //console.log(\"rationalised: \" + stack[tos-1].toString())\n          //simplify()\n          push(R_3_a);\n          divide();\n          add();\n          push_rational(1, 2);\n          power();\n          push_integer(2);\n          divide();\n          show_power_debug = true;\n          simplify();\n          R_S = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S.toString());\n          }\n          // now check if S is zero\n          push(R_S);\n          simplify();\n          absValFloat();\n          R_S_simplified_toCheckIfZero = pop();\n          if (DEBUG) {\n            console.log(\"S \" + R_S_simplified_toCheckIfZero.toString());\n          }\n          if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {\n            if (DEBUG) {\n              console.log(\" *********************************** S IS ZERO chosing another cubic root\");\n            }\n            choiceOfRadicalInQSoSIsNotZero++;\n          } else {\n            S_CHECKED_AS_NOT_ZERO = true;\n          }\n          if (DEBUG) {\n            console.log(\"tos: \" + tos);\n          }\n        }\n        // ----------------------------\n        if (DEBUG) {\n          console.log(\"tos: \" + tos);\n        }\n        push(p4);\n        negate();\n        push(p3);\n        push_integer(4);\n        multiply();\n        divide();\n        R_minus_b_over_4a = pop();\n        push_integer(-4);\n        push(R_S);\n        push_integer(2);\n        power();\n        multiply();\n        push_integer(2);\n        push(R_p);\n        multiply();\n        subtract();\n        R_minus_4S2_minus_2p = pop();\n        push(R_q);\n        push(R_S);\n        divide();\n        R_q_over_S = pop();\n        if (DEBUG) {\n          console.log(\"tos before putting together the 4 solutions: \" + tos);\n        }\n        // first solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // second solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        subtract();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        add();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        // third solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        add();\n        simplify();\n        // fourth solution\n        push(R_minus_b_over_4a); // first term\n        push(R_S);\n        add();\n        push(R_minus_4S2_minus_2p);\n        push(R_q_over_S);\n        subtract();\n        push_rational(1, 2);\n        power();\n        push_integer(2);\n        divide();\n        subtract();\n        simplify();\n        restore();\n        return;\n      }\n    }\n    moveTos(tos - n);\n    return restore();\n  };\n\n  Eval_round = function() {\n    push(cadr(p1));\n    Eval();\n    return yround();\n  };\n\n  yround = function() {\n    save();\n    yyround();\n    return restore();\n  };\n\n  yyround = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (!isNumericAtom(p1)) {\n      push_symbol(ROUND);\n      push(p1);\n      list(2);\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.round(p1.d);\n      push_double(d);\n      return;\n    }\n    if (isinteger(p1)) {\n      push(p1);\n      return;\n    }\n    push(p1);\n    yyfloat();\n    p1 = pop();\n    return push_integer(Math.round(p1.d));\n  };\n\n  // This scanner uses the recursive descent method.\n\n  // The char pointers token_str and scan_str are pointers to the input string as\n  // in the following example.\n\n  //  | g | a | m | m | a |   | a | l | p | h | a |\n  //    ^                   ^\n  //    token_str           scan_str\n\n  // The char pointer token_buf points to a malloc buffer.\n\n  //  | g | a | m | m | a | \\0 |\n  //    ^\n  //    token_buf\n\n  // In the sequence of method invocations for scanning,\n  // first we do the calls for scanning the operands\n  // of the operators of least precedence.\n  // So, since precedence in maths goes something like\n  // (form high to low) exponents, mult/div, plus/minus\n  // so we scan first for terms, then factors, then powers.\n  // That's the general idea, but of course we also have to deal\n  // with things like parens, non-commutative\n  // dot (or inner) product, assignments and tests,\n  // function calls etc.\n  // Note that a^1/2 is, correctly, a/2, not, incorrectly, sqrt(a),\n  // see comment in related test in power.coffee for more about this.\n\n  //  Notes:\n\n  //  Formerly add() and multiply() were used to construct expressions but\n  //  this preevaluation caused problems.\n\n  //  For example, suppose A has the floating point value inf.\n\n  //  Before, the expression A/A resulted in 1 because the scanner would\n  //  divide the symbols.\n\n  //  After removing add() and multiply(), A/A results in nan which is the\n  //  correct result.\n\n  //  The functions negate() and inverse() are used but they do not cause\n  //  problems with preevaluation of symbols.\n  T_INTEGER = 1001;\n\n  T_DOUBLE = 1002;\n\n  T_SYMBOL = 1003;\n\n  T_FUNCTION = 1004;\n\n  T_NEWLINE = 1006;\n\n  T_STRING = 1007;\n\n  T_GTEQ = 1008;\n\n  T_LTEQ = 1009;\n\n  T_EQ = 1010;\n\n  T_NEQ = 1011;\n\n  T_QUOTASSIGN = 1012;\n\n  token = \"\";\n\n  newline_flag = 0;\n\n  meta_mode = 0;\n\n  input_str = 0;\n\n  scan_str = 0;\n\n  token_str = 0;\n\n  token_buf = 0;\n\n  lastFoundSymbol = null;\n\n  symbolsRightOfAssignment = null;\n\n  symbolsLeftOfAssignment = null;\n\n  isSymbolLeftOfAssignment = null;\n\n  scanningParameters = null;\n\n  functionInvokationsScanningStack = null;\n\n  skipRootVariableToBeSolved = false;\n\n  assignmentFound = null;\n\n  // Returns number of chars scanned and expr on stack.\n\n  // Returns zero when nothing left to scan.\n\n  // takes a string\n  scanned = \"\";\n\n  scan = function(s) {\n    if (DEBUG) {\n      console.log(\"#### scanning \" + s);\n    }\n    //if s==\"y=x\"\n    //  debugger\n    //if s==\"y\"\n    //  debugger\n    //if s==\"i=sqrt(-1)\"\n    //  debugger\n    lastFoundSymbol = null;\n    symbolsRightOfAssignment = [];\n    symbolsLeftOfAssignment = [];\n    isSymbolLeftOfAssignment = true;\n    scanningParameters = [];\n    functionInvokationsScanningStack = [\"\"];\n    assignmentFound = false;\n    scanned = s;\n    meta_mode = 0;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    if (!assignmentFound) {\n      symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);\n    }\n    return token_str - input_str;\n  };\n\n  // takes a string\n  scan_meta = function(s) {\n    scanned = s;\n    meta_mode = 1;\n    expanding++;\n    input_str = 0;\n    scan_str = 0;\n    get_next_token();\n    if (token === \"\") {\n      push(symbol(NIL));\n      expanding--;\n      return 0;\n    }\n    scan_stmt();\n    expanding--;\n    return token_str - input_str;\n  };\n\n  scan_stmt = function() {\n    var assignmentIsOfQuotedType, existingDependencies, i, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;\n    scan_relation();\n    assignmentIsOfQuotedType = false;\n    if (token === T_QUOTASSIGN) {\n      assignmentIsOfQuotedType = true;\n    }\n    if (token === T_QUOTASSIGN || token === '=') {\n      symbolLeftOfAssignment = lastFoundSymbol;\n      if (DEBUG) {\n        console.log(\"assignment!\");\n      }\n      assignmentFound = true;\n      isSymbolLeftOfAssignment = false;\n      get_next_token();\n      push_symbol(SETQ);\n      swap();\n      // if it's a := then add a quote\n      if (assignmentIsOfQuotedType) {\n        push_symbol(QUOTE);\n      }\n      scan_relation();\n      // if it's a := then you have to list\n      // together the quote and its argument\n      if (assignmentIsOfQuotedType) {\n        list(2);\n      }\n      list(3);\n      isSymbolLeftOfAssignment = true;\n      if (codeGen) {\n        // in case of re-assignment, the symbol on the\n        // left will also be in the set of the symbols\n        // on the right. In that case just remove it from\n        // the symbols on the right.\n        indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);\n        if (indexOfSymbolLeftOfAssignment !== -1) {\n          symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);\n          symbolsHavingReassignments.push(symbolLeftOfAssignment);\n        }\n        \n        // print out the immediate dependencies\n        if (DEBUG) {\n          console.log(\"locally, \" + symbolLeftOfAssignment + \" depends on: \");\n          for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {\n            i = symbolsRightOfAssignment[l1];\n            console.log(\"  \" + i);\n          }\n        }\n        // ok add the local dependencies to the existing\n        // dependencies of this left-value symbol\n\n        // create the exiting dependencies list if it doesn't exist\n        if (symbolsDependencies[symbolLeftOfAssignment] == null) {\n          symbolsDependencies[symbolLeftOfAssignment] = [];\n        }\n        existingDependencies = symbolsDependencies[symbolLeftOfAssignment];\n// copy over the new dependencies to the existing\n// dependencies avoiding repetitions\n        for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {\n          i = symbolsRightOfAssignment[m1];\n          if (existingDependencies.indexOf(i) === -1) {\n            existingDependencies.push(i);\n          }\n        }\n        return symbolsRightOfAssignment = [];\n      }\n    }\n  };\n\n  scan_relation = function() {\n    scan_expression();\n    switch (token) {\n      case T_EQ:\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_NEQ:\n        push_symbol(NOT);\n        swap();\n        push_symbol(TESTEQ);\n        swap();\n        get_next_token();\n        scan_expression();\n        list(3);\n        return list(2);\n      case T_LTEQ:\n        push_symbol(TESTLE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case T_GTEQ:\n        push_symbol(TESTGE);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '<':\n        push_symbol(TESTLT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n      case '>':\n        push_symbol(TESTGT);\n        swap();\n        get_next_token();\n        scan_expression();\n        return list(3);\n    }\n  };\n\n  scan_expression = function() {\n    var h;\n    h = tos;\n    switch (token) {\n      case '+':\n        get_next_token();\n        scan_term();\n        break;\n      case '-':\n        get_next_token();\n        scan_term();\n        negate();\n        break;\n      default:\n        scan_term();\n    }\n    while (newline_flag === 0 && (token === '+' || token === '-')) {\n      if (token === '+') {\n        get_next_token();\n        scan_term();\n      } else {\n        get_next_token();\n        scan_term();\n        negate();\n      }\n    }\n    if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(ADD);\n      swap();\n      return cons();\n    }\n  };\n\n  is_factor = function() {\n    if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n      return 1;\n    }\n    switch (token) {\n      case '*':\n      case '/':\n        return 1;\n      case '(':\n      case T_SYMBOL:\n      case T_FUNCTION:\n      case T_INTEGER:\n      case T_DOUBLE:\n      case T_STRING:\n        if (newline_flag) { // implicit mul can't cross line\n          scan_str = token_str; // better error display\n          return 0;\n        } else {\n          return 1;\n        }\n    }\n    return 0;\n  };\n\n  simplify_1_in_products = function(tos, h) {\n    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {\n      return pop();\n    }\n  };\n\n  // calculate away consecutive constants\n  multiply_consecutive_constants = function(tos, h) {\n    if (tos > h + 1 && isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {\n      return multiply();\n    }\n  };\n\n  scan_term = function() {\n    var h;\n    h = tos;\n    scan_factor();\n    if (parse_time_simplifications) {\n      simplify_1_in_products(tos, h);\n    }\n    while (is_factor()) {\n      if (token === '*') {\n        get_next_token();\n        scan_factor();\n      } else if (token === '/') {\n        // in case of 1/... then\n        // we scanned the 1, we get rid\n        // of it because otherwise it becomes\n        // an extra factor that wasn't there and\n        // things like\n        // 1/(2*a) become 1*(1/(2*a))\n        simplify_1_in_products(tos, h);\n        get_next_token();\n        scan_factor();\n        inverse();\n      } else if ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {\n        get_next_token();\n        push_symbol(INNER);\n        swap();\n        scan_factor();\n        list(3);\n      } else {\n        scan_factor();\n      }\n      if (parse_time_simplifications) {\n        multiply_consecutive_constants(tos, h);\n        simplify_1_in_products(tos, h);\n      }\n    }\n    if (h === tos) {\n      return push_integer(1);\n    } else if (tos - h > 1) {\n      list(tos - h);\n      push_symbol(MULTIPLY);\n      swap();\n      return cons();\n    }\n  };\n\n  scan_power = function() {\n    if (token === '^') {\n      get_next_token();\n      push_symbol(POWER);\n      swap();\n      scan_factor();\n      return list(3);\n    }\n  };\n\n  scan_index = function(h) {\n    //console.log \"[ as index\"\n    get_next_token();\n    push_symbol(INDEX);\n    swap();\n    scan_expression();\n    while (token === ',') {\n      get_next_token();\n      scan_expression();\n    }\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    get_next_token();\n    return list(tos - h);\n  };\n\n  scan_factor = function() {\n    var firstFactorIsNumber, h;\n    h = tos;\n    //console.log \"scan_factor token: \" + token\n    firstFactorIsNumber = false;\n    if (token === '(') {\n      scan_subexpr();\n    } else if (token === T_SYMBOL) {\n      scan_symbol();\n    } else if (token === T_FUNCTION) {\n      scan_function_call_with_function_name();\n    } else if (token === '[') {\n      //console.log \"[ as tensor\"\n      //debugger\n      scan_tensor();\n    } else if (token === T_INTEGER) {\n      firstFactorIsNumber = true;\n      bignum_scan_integer(token_buf);\n      get_next_token();\n    } else if (token === T_DOUBLE) {\n      firstFactorIsNumber = true;\n      bignum_scan_float(token_buf);\n      get_next_token();\n    } else if (token === T_STRING) {\n      scan_string();\n    } else {\n      scan_error(\"syntax error\");\n    }\n    // after the main initial part of the factor that\n    // we just scanned above,\n    // we can get an arbitrary about of appendages\n    // of the form ...[...](...)...\n    // If the main part is not a number, then these are all, respectively,\n    //  - index references (as opposed to tensor definition) and\n    //  - function calls without an explicit function name\n    //    (instead of subexpressions or parameters of function\n    //    definitions or function calls with an explicit function\n    //    name), respectively\n    while (token === '[' || token === '(' && newline_flag === 0 && !firstFactorIsNumber) {\n      if (token === '[') {\n        scan_index(h);\n      } else if (token === '(') {\n        //console.log \"( as function call without function name \"\n        scan_function_call_without_function_name();\n      }\n    }\n    while (token === '!') {\n      get_next_token();\n      push_symbol(FACTORIAL);\n      swap();\n      list(2);\n    }\n    while ((typeof token.charCodeAt === \"function\" ? token.charCodeAt(0) : void 0) === transpose_unicode) {\n      get_next_token();\n      push_symbol(TRANSPOSE);\n      swap();\n      list(2);\n    }\n    return scan_power();\n  };\n\n  addSymbolRightOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols right of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsRightOfAssignment.push(theSymbol);\n    }\n  };\n\n  addSymbolLeftOfAssignment = function(theSymbol) {\n    var i, l1, prefixVar, ref2;\n    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(\"'\" + theSymbol) === -1 && !skipRootVariableToBeSolved) {\n      if (DEBUG) {\n        console.log(\"... adding symbol: \" + theSymbol + \" to the set of the symbols left of assignment\");\n      }\n      prefixVar = \"\";\n      for (i = l1 = 1, ref2 = functionInvokationsScanningStack.length; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n        if (functionInvokationsScanningStack[i] !== \"\") {\n          prefixVar += functionInvokationsScanningStack[i] + \"_\" + i + \"_\";\n        }\n      }\n      theSymbol = prefixVar + theSymbol;\n      return symbolsLeftOfAssignment.push(theSymbol);\n    }\n  };\n\n  scan_symbol = function() {\n    if (token !== T_SYMBOL) {\n      scan_error(\"symbol expected\");\n    }\n    if (meta_mode && token_buf.length === 1) {\n      switch (token_buf[0]) {\n        case 'a':\n          push(symbol(METAA));\n          break;\n        case 'b':\n          push(symbol(METAB));\n          break;\n        case 'x':\n          push(symbol(METAX));\n          break;\n        default:\n          push(usr_symbol(token_buf));\n      }\n    } else {\n      push(usr_symbol(token_buf));\n    }\n    //console.log \"found symbol: \" + token_buf\n    if (scanningParameters.length === 0) {\n      if (DEBUG) {\n        console.log(\"out of scanning parameters, processing \" + token_buf);\n      }\n      lastFoundSymbol = token_buf;\n      if (isSymbolLeftOfAssignment) {\n        addSymbolLeftOfAssignment(token_buf);\n      }\n    } else {\n      if (DEBUG) {\n        console.log(\"still scanning parameters, skipping \" + token_buf);\n      }\n      if (isSymbolLeftOfAssignment) {\n        addSymbolRightOfAssignment(\"'\" + token_buf);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"found symbol: \" + token_buf + \" left of assignment: \" + isSymbolLeftOfAssignment);\n    }\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    return get_next_token();\n  };\n\n  scan_string = function() {\n    push(new_string(token_buf));\n    return get_next_token();\n  };\n\n  scan_function_call_with_function_name = function() {\n    var functionName, i, l1, n, p, ref2;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_with_function_name start\");\n    }\n    n = 1; // the parameter number as we scan parameters\n    p = new U();\n    p = usr_symbol(token_buf);\n    push(p);\n    functionName = token_buf;\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.push(token_buf);\n    }\n    lastFoundSymbol = token_buf;\n    if (!isSymbolLeftOfAssignment) {\n      addSymbolRightOfAssignment(token_buf);\n    }\n    get_next_token(); // open parens\n    get_next_token(); // 1st parameter\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        // roots' disappearing variable, if there, is the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // sums' disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"sum\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // product's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"product\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // for's disappearing variable, is alsways the second one\n        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"for\") !== -1) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        // defint's disappearing variables can be in positions 2,5,8...\n        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"defint\") !== -1 && (n === 2 || (n > 2 && ((n - 2) % 3 === 0)))) {\n          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n            return !(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + token_buf)).test(x);\n          });\n          skipRootVariableToBeSolved = true;\n        }\n        scan_stmt();\n        skipRootVariableToBeSolved = false;\n        n++;\n      }\n      // todo refactor this, there are two copies\n      // this catches the case where the \"roots\" variable is not specified\n      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf(\"roots\") !== -1) {\n        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {\n          return !(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\" + \"x\")).test(x);\n        });\n      }\n    }\n    scanningParameters.pop();\n    for (i = l1 = 0, ref2 = symbolsRightOfAssignment.length; (0 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (symbolsRightOfAssignment[i] != null) {\n        if (functionName === \"roots\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"roots_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"defint\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"defint_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"sum\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"sum_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"product\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"product_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n        if (functionName === \"for\") {\n          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp(\"for_\" + (functionInvokationsScanningStack.length - 1) + \"_\"), \"\");\n        }\n      }\n    }\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (functionName === \"roots\" || functionName === \"defint\" || functionName === \"sum\" || functionName === \"product\" || functionName === \"for\") {\n      functionInvokationsScanningStack.pop();\n    }\n    if (functionName === symbol(PATTERN).printname) {\n      patternHasBeenFound = true;\n    }\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_with_function_name end\");\n    }\n  };\n\n  scan_function_call_without_function_name = function() {\n    var n;\n    if (DEBUG) {\n      console.log(\"-- scan_function_call_without_function_name start\");\n    }\n    // the function will have to be looked up\n    // at runtime (i.e. we need to evaulate something to find it\n    // e.g. it might be inside a tensor, so we'd need to evaluate\n    // a tensor element access in that case)\n    push_symbol(EVAL);\n    swap();\n    list(2);\n    n = 1; // the parameter number as we scan parameters\n    get_next_token(); // left paren\n    scanningParameters.push(true);\n    if (token !== ')') {\n      scan_stmt();\n      n++;\n      while (token === ',') {\n        get_next_token();\n        scan_stmt();\n        n++;\n      }\n    }\n    scanningParameters.pop();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    get_next_token();\n    list(n);\n    if (DEBUG) {\n      return console.log(\"-- scan_function_call_without_function_name end: \" + stack[tos - 1]);\n    }\n  };\n\n  // scan subexpression\n  scan_subexpr = function() {\n    var n;\n    n = 0;\n    if (token !== '(') {\n      scan_error(\"( expected\");\n    }\n    get_next_token();\n    scan_stmt();\n    if (token !== ')') {\n      scan_error(\") expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_tensor = function() {\n    var n;\n    n = 0;\n    if (token !== '[') {\n      scan_error(\"[ expected\");\n    }\n    get_next_token();\n    //console.log \"scanning the next statement\"\n    scan_stmt();\n    n = 1;\n    while (token === ',') {\n      get_next_token();\n      scan_stmt();\n      n++;\n    }\n    //console.log \"building tensor with elements number: \" + n\n    build_tensor(n);\n    if (token !== ']') {\n      scan_error(\"] expected\");\n    }\n    return get_next_token();\n  };\n\n  scan_error = function(errmsg) {\n    errorMessage = \"\";\n    // try not to put question mark on orphan line\n    while (input_str !== scan_str) {\n      if ((scanned[input_str] === '\\n' || scanned[input_str] === '\\r') && input_str + 1 === scan_str) {\n        break;\n      }\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += \" ? \";\n    while (scanned[input_str] && (scanned[input_str] !== '\\n' && scanned[input_str] !== '\\r')) {\n      errorMessage += scanned[input_str++];\n    }\n    errorMessage += '\\n';\n    return stop(errmsg);\n  };\n\n  // There are n expressions on the stack, possibly tensors.\n\n  // This function assembles the stack expressions into a single tensor.\n\n  // For example, at the top level of the expression ((a,b),(c,d)), the vectors\n  // (a,b) and (c,d) would be on the stack.\n\n  // takes an integer\n  build_tensor = function(n) {\n    var i, l1, ref2;\n    // int i, j, k, ndim, nelem\n    i = 0;\n    save();\n    p2 = alloc_tensor(n);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = n;\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.elem[i] = stack[tos - n + i];\n    }\n    check_tensor_dimensions(p2);\n    moveTos(tos - n);\n    push(p2);\n    return restore();\n  };\n\n  get_next_token = function() {\n    newline_flag = 0;\n    while (1) {\n      get_token();\n      if (token !== T_NEWLINE) {\n        break;\n      }\n      newline_flag = 1;\n    }\n    if (DEBUG) {\n      return console.log(\"get_next_token token: \" + token);\n    }\n  };\n\n  //if token == ')'\n  //  debugger\n  get_token = function() {\n    // skip spaces\n    while (isspace(scanned[scan_str])) {\n      if (scanned[scan_str] === '\\n' || scanned[scan_str] === '\\r') {\n        token = T_NEWLINE;\n        scan_str++;\n        return;\n      }\n      scan_str++;\n    }\n    token_str = scan_str;\n    // end of string?\n    if (scan_str === scanned.length) {\n      token = \"\";\n      return;\n    }\n    // number?\n    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {\n      while (isdigit(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '.') {\n        scan_str++;\n        while (isdigit(scanned[scan_str])) {\n          scan_str++;\n        }\n        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {\n          scan_str += 2;\n          while (isdigit(scanned[scan_str])) {\n            scan_str++;\n          }\n        }\n        token = T_DOUBLE;\n      } else {\n        token = T_INTEGER;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // symbol?\n    if (isalpha(scanned[scan_str])) {\n      while (isalnumorunderscore(scanned[scan_str])) {\n        scan_str++;\n      }\n      if (scanned[scan_str] === '(') {\n        token = T_FUNCTION;\n      } else {\n        token = T_SYMBOL;\n      }\n      update_token_buf(token_str, scan_str);\n      return;\n    }\n    // string ?\n    if (scanned[scan_str] === '\"') {\n      scan_str++;\n      while (scanned[scan_str] !== '\"') {\n        //if (scan_str == scanned.length || scanned[scan_str] == '\\n' || scanned[scan_str] == '\\r')\n        if (scan_str === scanned.length - 1) {\n          scan_str++;\n          scan_error(\"runaway string\");\n          scan_str--;\n        }\n        scan_str++;\n      }\n      scan_str++;\n      token = T_STRING;\n      update_token_buf(token_str + 1, scan_str - 1);\n      return;\n    }\n    // comment?\n    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {\n      while (scanned[scan_str] && scanned[scan_str] !== '\\n' && scanned[scan_str] !== '\\r') {\n        scan_str++;\n      }\n      if (scanned[scan_str]) {\n        scan_str++;\n      }\n      token = T_NEWLINE;\n      return;\n    }\n    // quote-assignment\n    if (scanned[scan_str] === ':' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_QUOTASSIGN;\n      return;\n    }\n    // relational operator?\n    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_EQ;\n      return;\n    }\n    // != operator. It's a little odd because\n    // \"!\" is not a \"not\", which would make things consistent.\n    // (it's used for factorial).\n    // An alternative would be to use \"<>\" but it's not used\n    // a lot in other languages...\n    if (scanned[scan_str] === '!' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_NEQ;\n      return;\n    }\n    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_LTEQ;\n      return;\n    }\n    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {\n      scan_str += 2;\n      token = T_GTEQ;\n      return;\n    }\n    // single char token\n    return token = scanned[scan_str++];\n  };\n\n  // both strings\n  update_token_buf = function(a, b) {\n    return token_buf = scanned.substring(a, b);\n  };\n\n  $.scan = scan;\n\n  //-----------------------------------------------------------------------------\n\n  //  Author : philippe.billet@noos.fr\n\n  //  sgn sign function\n\n  //-----------------------------------------------------------------------------\n  Eval_sgn = function() {\n    push(cadr(p1));\n    Eval();\n    return sgn();\n  };\n\n  sgn = function() {\n    save();\n    yysgn();\n    return restore();\n  };\n\n  //define X p1\n  yysgn = function() {\n    p1 = pop();\n    if (isdouble(p1)) {\n      if (p1.d > 0) {\n        push_integer(1);\n        return;\n      } else {\n        if (p1.d === 0) {\n          push_integer(1);\n          return;\n        } else {\n          push_integer(-1);\n          return;\n        }\n      }\n    }\n    if (isrational(p1)) {\n      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {\n        push_integer(-1);\n        return;\n      } else {\n        if (MZERO(mmul(p1.q.a, p1.q.b))) {\n          push_integer(0);\n          return;\n        } else {\n          push_integer(1);\n          return;\n        }\n      }\n    }\n    if (iscomplexnumber(p1)) {\n      push_integer(-1);\n      push(p1);\n      absval();\n      power();\n      push(p1);\n      multiply();\n      return;\n    }\n    if (isnegativeterm(p1)) {\n      push_symbol(SGN);\n      push(p1);\n      negate();\n      list(2);\n      push_integer(-1);\n      multiply();\n      return;\n    }\n    /*\n    push_integer(2)\n    push(p1)\n    heaviside()\n    multiply()\n    push_integer(-1)\n    add()\n    */\n    push_symbol(SGN);\n    push(p1);\n    return list(2);\n  };\n\n  // shape of tensor\n  Eval_shape = function() {\n    push(cadr(p1));\n    Eval();\n    return shape();\n  };\n\n  shape = function() {\n    var ai, an, i, l1, m1, ndim, ref2, ref3, t;\n    i = 0;\n    ndim = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        stop(\"transpose: tensor expected, 1st arg is not a tensor\");\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(ndim);\n    p2.tensor.ndim = 1;\n    p2.tensor.dim[0] = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push_integer(p1.tensor.dim[i]);\n      p2.tensor.elem[i] = pop();\n    }\n    push(p2);\n    return restore();\n  };\n\n  /*\n   Simplify factorials\n\n  The following script\n\n    F(n,k) = k binomial(n,k)\n    (F(n,k) + F(n,k-1)) / F(n+1,k)\n\n  generates\n\n         k! n!             n! (1 - k + n)!              k! n!\n   -------------------- + -------------------- - ----------------------\n   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!\n\n  Simplify each term to get\n\n      k       1 - k + n       1\n   ------- + ----------- - -------\n    1 + n       1 + n       1 + n\n\n  Then simplify the sum to get\n\n      n\n   -------\n    1 + n\n\n  */\n  // simplify factorials term-by-term\n  Eval_simfac = function() {\n    push(cadr(p1));\n    Eval();\n    return simfac();\n  };\n\n  //if 1\n  simfac = function() {\n    var h;\n    h = 0;\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      h = tos;\n      p1 = cdr(p1);\n      while (p1 !== symbol(NIL)) {\n        push(car(p1));\n        simfac_term();\n        p1 = cdr(p1);\n      }\n      add_all(tos - h);\n    } else {\n      push(p1);\n      simfac_term();\n    }\n    return restore();\n  };\n\n  //else\n  /*\n  void\n  simfac(void)\n  {\n    int h\n    save()\n    p1 = pop()\n    if (car(p1) == symbol(ADD)) {\n      h = tos\n      p1 = cdr(p1)\n      while (p1 != symbol(NIL)) {\n        push(car(p1))\n        simfac_term()\n        p1 = cdr(p1)\n      }\n      addk(tos - h)\n      p1 = pop()\n      if (find(p1, symbol(FACTORIAL))) {\n        push(p1)\n        if (car(p1) == symbol(ADD)) {\n          Condense()\n          simfac_term()\n        }\n      }\n    } else {\n      push(p1)\n      simfac_term()\n    }\n    restore()\n  }\n\n  #endif\n   */\n  simfac_term = function() {\n    var doNothing, h;\n    h = 0;\n    save();\n    p1 = pop();\n    // if not a product of factors then done\n    if (car(p1) !== symbol(MULTIPLY)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // push all factors\n    h = tos;\n    p1 = cdr(p1);\n    while (p1 !== symbol(NIL)) {\n      push(car(p1));\n      p1 = cdr(p1);\n    }\n    // keep trying until no more to do\n    while (yysimfac(h)) {\n      doNothing = 1;\n    }\n    multiply_all_noexpand(tos - h);\n    return restore();\n  };\n\n  // try all pairs of factors\n  yysimfac = function(h) {\n    var i, j, l1, m1, ref2, ref3, ref4, ref5;\n    i = 0;\n    j = 0;\n    for (i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      p1 = stack[i];\n      for (j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); j = ref4 <= ref5 ? ++m1 : --m1) {\n        if (i === j) {\n          continue;\n        }\n        p2 = stack[j];\n        //  n! / n    ->  (n - 1)!\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {\n          push(cadr(p1));\n          push(one);\n          subtract();\n          factorial();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  n / n!    ->  1 / (n - 1)!\n        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {\n          push(p1);\n          push_integer(-1);\n          add();\n          factorial();\n          reciprocate();\n          stack[i] = pop();\n          stack[j] = one;\n          return 1;\n        }\n        //  (n + 1) n!  ->  (n + 1)!\n        if (car(p2) === symbol(FACTORIAL)) {\n          push(p1);\n          push(cadr(p2));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(p1);\n            factorial();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  1 / ((n + 1) n!)  ->  1 / (n + 1)!\n        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            push(cadr(p1));\n            factorial();\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n        }\n        //  (n + 1)! / n!  ->  n + 1\n\n        //  n! / (n + 1)!  ->  1 / (n + 1)\n        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {\n          push(cadr(p1));\n          push(cadr(cadr(p2)));\n          subtract();\n          p3 = pop();\n          if (isplusone(p3)) {\n            stack[i] = cadr(p1);\n            stack[j] = one;\n            return 1;\n          }\n          if (isminusone(p3)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            stack[j] = one;\n            return 1;\n          }\n          if (equaln(p3, 2)) {\n            stack[i] = cadr(p1);\n            push(cadr(p1));\n            push_integer(-1);\n            add();\n            stack[j] = pop();\n            return 1;\n          }\n          if (equaln(p3, -2)) {\n            push(cadr(cadr(p2)));\n            reciprocate();\n            stack[i] = pop();\n            push(cadr(cadr(p2)));\n            push_integer(-1);\n            add();\n            reciprocate();\n            stack[j] = pop();\n            return 1;\n          }\n        }\n      }\n    }\n    return 0;\n  };\n\n  DEBUG_SIMPLIFY = false;\n\n  Eval_simplify = function() {\n    push(cadr(p1));\n    runUserDefinedSimplifications();\n    Eval();\n    return simplify();\n  };\n\n  runUserDefinedSimplifications = function() {\n    var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;\n    // -----------------------\n    // unfortunately for the time being user\n    // specified simplifications are only\n    // run in things which don't contain\n    // integrals.\n    // Doesn't work yet, could be because of\n    // some clobbering as \"transform\" is called\n    // recursively?\n    if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {\n      originalexpanding = expanding;\n      expanding = false;\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications passed: \" + stack[tos - 1].toString());\n      }\n      Eval();\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"runUserDefinedSimplifications after eval no expanding: \" + stack[tos - 1].toString());\n      }\n      expanding = originalexpanding;\n      p1 = stack[tos - 1];\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"patterns to be checked: \");\n      }\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        eachSimplification = userSimplificationsInListForm[l1];\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"...\" + eachSimplification);\n        }\n      }\n      atLeastOneSuccessInRouldOfRulesApplications = true;\n      numberOfRulesApplications = 0;\n      while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        atLeastOneSuccessInRouldOfRulesApplications = false;\n        numberOfRulesApplications++;\n        for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n          eachSimplification = userSimplificationsInListForm[m1];\n          success = true;\n          eachConsecutiveRuleApplication = 0;\n          while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            eachConsecutiveRuleApplication++;\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"simplify - tos: \" + tos + \" checking pattern: \" + eachSimplification + \" on: \" + p1);\n            }\n            push_symbol(NIL);\n            success = transform(eachSimplification, true);\n            if (success) {\n              atLeastOneSuccessInRouldOfRulesApplications = true;\n            }\n            p1 = stack[tos - 1];\n            if (DEBUG_SIMPLIFY) {\n              console.log(\"p1 at this stage of simplification: \" + p1);\n            }\n          }\n          if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {\n            stop(\"maximum application of single transformation rule exceeded: \" + eachSimplification);\n          }\n        }\n      }\n      if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {\n        stop(\"maximum application of all transformation rules exceeded \");\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAX = \" + get_binding(symbol(METAX)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"METAA = \" + get_binding(symbol(METAA)));\n      }\n      if (DEBUG_SIMPLIFY) {\n        return console.log(\"METAB = \" + get_binding(symbol(METAB)));\n      }\n    }\n  };\n\n  // ------------------------\n  simplifyForCodeGeneration = function() {\n    save();\n    runUserDefinedSimplifications();\n    codeGen = true;\n    // in \"codeGen\" mode we completely\n    // eval and simplify the function bodies\n    // because we really want to resolve all\n    // the variables indirections and apply\n    // all the simplifications we can.\n    simplify_main();\n    codeGen = false;\n    return restore();\n  };\n\n  simplify = function() {\n    save();\n    simplify_main();\n    return restore();\n  };\n\n  simplify_main = function() {\n    var args, fbody;\n    p1 = pop();\n    // when we do code generation, we proceed to\n    // fully evaluate and simplify the body of\n    // a function, so we resolve all variables\n    // indirections and we simplify everything\n    // we can given the current assignments.\n    if (codeGen && car(p1) === symbol(FUNCTION)) {\n      fbody = cadr(p1);\n      push(fbody);\n      // let's simplify the body so we give it a\n      // compact form\n      eval();\n      simplify();\n      p3 = pop();\n      // replace the evaled body\n      args = caddr(p1);\n      push_symbol(FUNCTION);\n      push(p3);\n      push(args);\n      list(3);\n      p1 = pop();\n    }\n    if (istensor(p1)) {\n      simplify_tensor();\n      return;\n    }\n    if (Find(p1, symbol(FACTORIAL))) {\n      push(p1);\n      simfac();\n      p2 = pop();\n      push(p1);\n      rationalize();\n      simfac();\n      p3 = pop();\n      if (count(p2) < count(p3)) {\n        p1 = p2;\n      } else {\n        p1 = p3;\n      }\n    }\n    f10();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f10: \" + p1.toString());\n    }\n    f1();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f1: \" + p1.toString());\n    }\n    f2();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f2: \" + p1.toString());\n    }\n    f3();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f3: \" + p1.toString());\n    }\n    f4();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f4: \" + p1.toString());\n    }\n    f5();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f5: \" + p1.toString());\n    }\n    f9();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"f9: \" + p1.toString());\n    }\n    simplify_polarRect();\n    if (do_simplify_nested_radicals) {\n      // if there is some de-nesting then\n      // re-run a simplification because\n      // the shape of the expression might\n      // have changed significantly.\n      // e.g. simplify(14^(1/2) - (16 - 4*7^(1/2))^(1/2))\n      // needs some more semplification after the de-nesting.\n      if (simplify_nested_radicals()) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"de-nesting successful into: \" + p1.toString());\n        }\n        push(p1);\n        simplify();\n        return;\n      }\n    }\n    simplify_rectToClock();\n    simplify_rational_expressions();\n    return push(p1);\n  };\n\n  simplify_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1.tensor.elem[i]);\n      simplify();\n      p2.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p2);\n    if (isZeroAtomOrTensor(p2)) {\n      p2 = zero; // null tensor becomes scalar zero\n    }\n    return push(p2);\n  };\n\n  // try rationalizing\n  f1 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // try condensing\n  f2 = function() {\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push(p1);\n    Condense();\n    p2 = pop();\n    if (count(p2) <= count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // this simplifies forms like (A-B) / (B-A)\n  f3 = function() {\n    push(p1);\n    rationalize();\n    negate();\n    rationalize();\n    negate();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  f10 = function() {\n    var a, b, carp1, miao, originalexpanding;\n    carp1 = car(p1);\n    miao = cdr(p1);\n    if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {\n      // both operands a transpose?\n      if ((car(car(cdr(p1))) === symbol(TRANSPOSE)) && (car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE))) {\n        if (DEBUG_SIMPLIFY) {\n          console.log(\"maybe collecting a transpose \" + p1);\n        }\n        a = cadr(car(cdr(p1)));\n        b = cadr(car(cdr(cdr(p1))));\n        if (carp1 === symbol(MULTIPLY)) {\n          push(a);\n          push(b);\n          multiply();\n        } else if (isinnerordot(p1)) {\n          push(b);\n          push(a);\n          inner();\n        }\n        push_integer(1);\n        push_integer(2);\n        originalexpanding = expanding;\n        expanding = false;\n        transpose();\n        expanding = originalexpanding;\n        p2 = pop();\n        if (count(p2) < count(p1)) {\n          p1 = p2;\n        }\n        if (DEBUG_SIMPLIFY) {\n          return console.log(\"collecting a transpose \" + p2);\n        }\n      }\n    }\n  };\n\n  // try expanding denominators\n  f4 = function() {\n    if (isZeroAtomOrTensor(p1)) {\n      return;\n    }\n    push(p1);\n    rationalize();\n    inverse();\n    rationalize();\n    inverse();\n    rationalize();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // simplifies trig forms\n  simplify_trig = function() {\n    save();\n    p1 = pop();\n    f5();\n    push(p1);\n    return restore();\n  };\n\n  f5 = function() {\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    p2 = p1;\n    trigmode = 1;\n    push(p2);\n    Eval();\n    p3 = pop();\n    trigmode = 2;\n    push(p2);\n    Eval();\n    p4 = pop();\n    trigmode = 0;\n    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {\n      p3 = p4;\n    }\n    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {\n      return p1 = p3;\n    }\n  };\n\n  // if it's a sum then try to simplify each term\n  f9 = function() {\n    var oldp1, oldp2;\n    if (car(p1) !== symbol(ADD)) {\n      return;\n    }\n    push_integer(0);\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      simplify();\n      add();\n      oldp1 = p1;\n      oldp2 = p2;\n      p1 = pop();\n      simplify_rational_expressions();\n      push(p1);\n      p1 = oldp1;\n      p2 = oldp2;\n      p2 = cdr(p2);\n    }\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_rational_expressions = function() {\n    var denom, num, polyVar, sasa, theGCD;\n    push(p1);\n    denominator();\n    denom = pop();\n    if (isone(denom)) {\n      return;\n    }\n    push(p1);\n    numerator();\n    num = pop();\n    if (isone(num)) {\n      return;\n    }\n    if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {\n      return;\n    }\n    push(num);\n    push(denom);\n    gcd();\n    push(polyVar);\n    factor();\n    theGCD = pop();\n    // if there are no common factors then\n    // bail\n    if (isone(theGCD)) {\n      return;\n    }\n    push(num);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    push(denom);\n    push(polyVar);\n    factor();\n    push(theGCD);\n    //divide()\n    inverse();\n    multiply_noexpand();\n    simplify();\n    sasa = stack[tos - 1].toString();\n    divide();\n    //simplify()\n    Condense();\n    sasa = stack[tos - 1].toString();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  // things like 6*(cos(2/9*pi)+i*sin(2/9*pi))\n  // where we have sin and cos, those might start to\n  // look better in clock form i.e.  6*(-1)^(2/9) \n  simplify_rectToClock = function() {\n    //debugger\n    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {\n      return;\n    }\n    push(p1);\n    Eval();\n    clockform();\n    p2 = pop();\n    if (DEBUG_SIMPLIFY) {\n      console.log(\"before simplification clockform: \" + p1 + \" after: \" + p2);\n    }\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  simplify_polarRect = function() {\n    push(p1);\n    polarRectAMinusOneBase();\n    Eval();\n    p2 = pop();\n    if (count(p2) < count(p1)) {\n      return p1 = p2;\n    }\n  };\n\n  polarRectAMinusOneBase = function() {\n    var h;\n    save();\n    p1 = pop();\n    if (isimaginaryunit(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {\n      // base we just said is minus 1\n      push(one);\n      negate();\n      // exponent\n      push(caddr(p1));\n      polarRectAMinusOneBase();\n      power();\n      // try to simplify it using polar and rect\n      polar();\n      rect();\n    } else if (iscons(p1)) {\n      h = tos;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        polarRectAMinusOneBase();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n    } else {\n      push(p1);\n    }\n    restore();\n  };\n\n  nterms = function(p) {\n    if (car(p) !== symbol(ADD)) {\n      return 1;\n    } else {\n      return length(p) - 1;\n    }\n  };\n\n  simplify_nested_radicals = function() {\n    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    push(p1);\n    somethingSimplified = take_care_of_nested_radicals();\n    // in this paragraph we check whether we can collect\n    // common factors without complicating the expression\n    // in particular we want to avoid \n    // collecting radicals like in this case where\n    // we collect sqrt(2):\n    //   2-2^(1/2) into 2^(1/2)*(-1+2^(1/2))\n    // but we do like to collect other non-radicals e.g.\n    //   17/2+3/2*5^(1/2) into 1/2*(17+3*5^(1/2))\n    // so what we do is we count the powers and we check\n    // which version has the least number of them.\n    simplificationWithoutCondense = stack[tos - 1];\n    prev_expanding = expanding;\n    expanding = 0;\n    yycondense();\n    expanding = prev_expanding;\n    simplificationWithCondense = pop();\n    //console.log(\"occurrences of powers in \" + simplificationWithoutCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithoutCondense))\n    //console.log(\"occurrences of powers in \" + simplificationWithCondense + \" :\" + countOccurrencesOfSymbol(symbol(POWER),simplificationWithCondense))\n    if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {\n      push(simplificationWithoutCondense);\n    } else {\n      push(simplificationWithCondense);\n    }\n    // we got out result, wrap up\n    p1 = pop();\n    return somethingSimplified;\n  };\n\n  take_care_of_nested_radicals = function() {\n    var A, B, C, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;\n    if (recursionLevelNestedRadicalsRemoval > 0) {\n      if (DEBUG_SIMPLIFY) {\n        console.log(\"denesting bailing out because of too much recursion\");\n      }\n      return false;\n    }\n    save();\n    p1 = pop();\n    //console.log(\"take_care_of_nested_radicals p1: \" + p1.toString())\n    if (equal(car(p1), symbol(POWER))) {\n      //console.log(\"ok it's a power \")\n      base = cadr(p1);\n      exponent = caddr(p1);\n      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {\n        //console.log(\"ok there is a radix with a term inside\")\n        firstTerm = cadr(base);\n        push(firstTerm);\n        take_care_of_nested_radicals();\n        pop();\n        secondTerm = caddr(base);\n        push(secondTerm);\n        take_care_of_nested_radicals();\n        pop();\n        //console.log(\"possible double radical term1: \" + firstTerm)\n        //console.log(\"possible double radical term2: \" + secondTerm)\n        numberOfTerms = 0;\n        countingTerms = base;\n        while (cdr(countingTerms) !== symbol(NIL)) {\n          numberOfTerms++;\n          countingTerms = cdr(countingTerms);\n        }\n        //console.log(\"number of terms: \" + numberOfTerms)\n        if (numberOfTerms > 2) {\n          //console.log(\"too many terms under outer radix \")\n          push(p1);\n          restore();\n          return false;\n        }\n        // list here all the factors\n        commonInnerExponent = null;\n        commonBases = [];\n        termsThatAreNotPowers = [];\n        if (car(secondTerm) === symbol(MULTIPLY)) {\n          // product of factors\n          secondTermFactor = cdr(secondTerm);\n          if (iscons(secondTermFactor)) {\n            while (iscons(secondTermFactor)) {\n              //console.log(\"second term factor BIS: \" + car(secondTermFactor).toString())\n              potentialPower = car(secondTermFactor);\n              if (car(potentialPower) === symbol(POWER)) {\n                innerbase = cadr(potentialPower);\n                innerexponent = caddr(potentialPower);\n                if (equalq(innerexponent, 1, 2)) {\n                  if (commonInnerExponent == null) {\n                    commonInnerExponent = innerexponent;\n                    commonBases.push(innerbase);\n                  } else {\n                    if (equal(innerexponent, commonInnerExponent)) {\n                      //console.log(\"common base: \" + innerbase.toString())\n                      commonBases.push(innerbase);\n                    } else {\n\n                    }\n                  }\n                }\n              } else {\n                //console.log(\"no common bases here \")\n                //console.log(\"this one is a power base: \" + innerbase + \" , exponent: \" + innerexponent)\n                termsThatAreNotPowers.push(potentialPower);\n              }\n              secondTermFactor = cdr(secondTermFactor);\n            }\n          }\n        } else if (car(secondTerm) === symbol(POWER)) {\n          innerbase = cadr(secondTerm);\n          innerexponent = caddr(secondTerm);\n          if ((commonInnerExponent == null) && equalq(innerexponent, 1, 2)) {\n            //console.log(\"tackling double radical 2: \" + p1.toString())\n            commonInnerExponent = innerexponent;\n            commonBases.push(innerbase);\n          }\n        }\n        if (commonBases.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        A = firstTerm;\n        //console.log(\"A: \" + A.toString())\n        push_integer(1);\n        for (l1 = 0, len = commonBases.length; l1 < len; l1++) {\n          i = commonBases[l1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"basis with common exponent: \" + i.toString())\n        C = pop();\n        //console.log(\"C: \" + C.toString())\n        push_integer(1);\n        for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {\n          i = termsThatAreNotPowers[m1];\n          push(i);\n          multiply();\n        }\n        //console.log(\"terms that are not powers: \" + i.toString())\n        B = pop();\n        //console.log(\"B: \" + B.toString())\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          negate();\n          push(C);\n          multiply();\n          push(B);\n          divide(); // 4th coeff\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push_integer(3);\n          push(C);\n          multiply(); // 3rd coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(-3);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(3);\n          power();\n          multiply();\n          add();\n          add();\n          add();\n        } else if (equalq(exponent, 1, 2)) {\n          push(C); // 3th coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"constant coeff \" + stack[tos-1].toString())\n          push_integer(-2);\n          push(A);\n          multiply();\n          push(B);\n          divide(); // 2nd coeff\n          checkSize = pop();\n          push(checkSize);\n          real();\n          yyfloat();\n          if (Math.abs(pop().d) > Math.pow(2, 32)) {\n            pop();\n            push(p1);\n            restore();\n            return false;\n          }\n          push(checkSize);\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          multiply();\n          push_integer(1); // 1st coeff\n          //console.log(\"next coeff \" + stack[tos-1].toString())\n          push(symbol(SECRETX));\n          push_integer(2);\n          power();\n          multiply();\n          add();\n          add();\n        }\n        //console.log(\"whole polynomial: \" + stack[tos-1].toString())\n        push(symbol(SECRETX));\n        recursionLevelNestedRadicalsRemoval++;\n        //console.log(\"invoking roots at recursion level: \" + recursionLevelNestedRadicalsRemoval)\n        roots();\n        recursionLevelNestedRadicalsRemoval--;\n        if (equal(stack[tos - 1], symbol(NIL))) {\n          if (DEBUG_SIMPLIFY) {\n            console.log(\"roots bailed out because of too much recursion\");\n          }\n          pop();\n          push(p1);\n          restore();\n          return false;\n        }\n        //console.log(\"all solutions: \" + stack[tos-1].toString())\n\n        // exclude the solutions with radicals\n        possibleSolutions = [];\n        ref2 = stack[tos - 1].tensor.elem;\n        for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {\n          eachSolution = ref2[n1];\n          if (!Find(eachSolution, symbol(POWER))) {\n            possibleSolutions.push(eachSolution);\n          }\n        }\n        pop(); // popping the tensor with the solutions\n        \n        //console.log(\"possible solutions: \" + possibleSolutions.toString())\n        if (possibleSolutions.length === 0) {\n          push(p1);\n          restore();\n          return false;\n        }\n        possibleRationalSolutions = [];\n        realOfpossibleRationalSolutions = [];\n//console.log(\"checking the one with maximum real part \")\n        for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {\n          i = possibleSolutions[o1];\n          push(i);\n          real();\n          yyfloat();\n          possibleRationalSolutions.push(i);\n          realOfpossibleRationalSolutions.push(pop().d);\n        }\n        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));\n        SOLUTION = possibleRationalSolutions[whichRationalSolution];\n        //console.log(\"picked solution: \" + SOLUTION)\n        /*\n        #possibleNewExpressions = []\n        #realOfPossibleNewExpressions = []\n         * pick the solution which cubic root has no radicals\n        lowercase_b = null\n        for SOLUTION in possibleSolutions\n          console.log(\"testing solution: \" + SOLUTION.toString())\n\n          debugger\n          if equalq(exponent,1,3)\n            push(A)\n            push(SOLUTION)\n            push_integer(3)\n            power()\n            push_integer(3)\n            push(C)\n            multiply()\n            push(SOLUTION)\n            multiply()\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,3)\n            power()\n          else if equalq(exponent,1,2)\n            push(A)\n            push(SOLUTION)\n            push_integer(2)\n            power()\n            push(C)\n            add()\n            divide()\n            console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n            push_rational(1,2)\n            power()\n          console.log(\"b is: \" + stack[tos-1].toString())\n\n          lowercase_b = pop()\n\n          if !Find(lowercase_b, symbol(POWER))\n            break\n         */\n        if (equalq(exponent, 1, 3)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(3);\n          power();\n          push_integer(3);\n          push(C);\n          multiply();\n          push(SOLUTION);\n          multiply();\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 3);\n          power();\n        } else if (equalq(exponent, 1, 2)) {\n          push(A);\n          push(SOLUTION);\n          push_integer(2);\n          power();\n          push(C);\n          add();\n          divide();\n          //console.log(\"argument of cubic root: \" + stack[tos-1].toString())\n          push_rational(1, 2);\n          power();\n        }\n        //console.log(\"b is: \" + stack[tos-1].toString())\n        lowercase_b = pop();\n        if (lowercase_b == null) {\n          push(p1);\n          restore();\n          return false;\n        }\n        push(lowercase_b);\n        push(SOLUTION);\n        multiply();\n        if (equalq(exponent, 1, 3)) {\n          //console.log(\"a is: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n        } else if (equalq(exponent, 1, 2)) {\n          //console.log(\"a could be: \" + stack[tos-1].toString())\n          lowercase_a = pop();\n          push(lowercase_b);\n          push(C);\n          push_rational(1, 2);\n          power();\n          multiply();\n          push(lowercase_a);\n          add();\n          simplify();\n          possibleNewExpression = pop();\n          //console.log(\"verifying if  \" + possibleNewExpression + \" is positive\")\n          push(possibleNewExpression);\n          real();\n          yyfloat();\n          possibleNewExpressionValue = pop();\n          if (!isnegativenumber(possibleNewExpressionValue)) {\n            //console.log(\"... it is positive\")\n            push(possibleNewExpression);\n          } else {\n            //console.log(\"... it is NOT positive\")\n            push(lowercase_b);\n            negate();\n            lowercase_b = pop();\n            push(lowercase_a);\n            negate();\n            lowercase_a = pop();\n            push(lowercase_b);\n            push(C);\n            push_rational(1, 2);\n            power();\n            multiply();\n            push(lowercase_a);\n            add();\n            simplify();\n          }\n        }\n        // possibleNewExpression is now at top of stack\n\n        //console.log(\"potential new expression: \" + stack[tos-1].toString())\n        p1 = pop();\n        //newExpression = pop()\n        //debugger\n        //push(newExpression)\n        //real()\n        //yyfloat()\n        //possibleNewExpressions.push(newExpression)\n        //realOfPossibleNewExpressions.push(pop().d)\n\n        //whichExpression = realOfPossibleNewExpressions.indexOf(Math.max.apply(Math, realOfPossibleNewExpressions))\n        //p1 = possibleNewExpressions[whichExpression]\n        //console.log(\"final new expression: \" + p1.toString())\n        push(p1);\n        restore();\n        return true;\n      } else {\n        push(p1);\n        restore();\n        return false;\n      }\n    } else if (iscons(p1)) {\n      h = tos;\n      anyRadicalSimplificationWorked = false;\n      while (iscons(p1)) {\n        //console.log(\"recursing on: \" + car(p1).toString())\n        push(car(p1));\n        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();\n        //console.log(\"...transformed into: \" + stack[tos-1].toString())\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return anyRadicalSimplificationWorked;\n    } else {\n      push(p1);\n      restore();\n      return false;\n    }\n    throw new Error(\"control flow should never reach here\");\n  };\n\n  // Sine function of numerical and symbolic arguments\n  Eval_sin = function() {\n    //console.log \"sin ---- \"\n    push(cadr(p1));\n    Eval();\n    return sine();\n  };\n\n  //console.log \"sin end ---- \"\n  sine = function() {\n    //console.log \"sine ---- \"\n    save();\n    p1 = pop();\n    if (car(p1) === symbol(ADD)) {\n      // sin of a sum can be further decomposed into\n      //sin(alpha+beta) = sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n      sine_of_angle_sum();\n    } else {\n      sine_of_angle();\n    }\n    return restore();\n  };\n\n  //console.log \"sine end ---- \"\n\n  // Use angle sum formula for special angles.\n\n  //define A p3\n  //define B p4\n\n  // decompose sum sin(alpha+beta) into\n  // sin(alpha)*cos(beta)+sin(beta)*cos(alpha)\n  sine_of_angle_sum = function() {\n    //console.log \"sin of angle sum ---- \"\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      p4 = car(p2);\n      if (isnpi(p4)) { // p4 is B\n        push(p1);\n        push(p4);\n        subtract();\n        p3 = pop();\n        push(p3);\n        sine();\n        push(p4);\n        cosine();\n        multiply();\n        push(p3);\n        cosine();\n        push(p4);\n        sine();\n        multiply();\n        add();\n        return;\n      }\n      //console.log \"sin of angle sum end ---- \"\n      p2 = cdr(p2);\n    }\n    return sine_of_angle();\n  };\n\n  //console.log \"sin of angle sum end ---- \"\n  sine_of_angle = function() {\n    var d, n;\n    if (car(p1) === symbol(ARCSIN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sin(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // sine function is antisymmetric, sin(-x) = -sin(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      sine();\n      negate();\n      return;\n    }\n    // sin(arctan(x)) = x / sqrt(1 + x^2)\n\n    // see p. 173 of the CRC Handbook of Mathematical Sciences\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      push_integer(1);\n      push(cadr(p1));\n      push_integer(2);\n      power();\n      add();\n      push_rational(-1, 2);\n      power();\n      multiply();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(SIN));\n      push(p1);\n      list(2);\n      return;\n    }\n    // values of some famous angles. Many more here:\n    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 150:\n        return push_rational(1, 2);\n      case 210:\n      case 330:\n        return push_rational(-1, 2);\n      case 45:\n      case 135:\n        push_rational(1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 225:\n      case 315:\n        push_rational(-1, 2);\n        push_integer(2);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 60:\n      case 120:\n        push_rational(1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 240:\n      case 300:\n        push_rational(-1, 2);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 90:\n        return push_integer(1);\n      case 270:\n        return push_integer(-1);\n      default:\n        push(symbol(SIN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //            exp(x) - exp(-x)\n  //  sinh(x) = ----------------\n  //                   2\n  Eval_sinh = function() {\n    push(cadr(p1));\n    Eval();\n    return ysinh();\n  };\n\n  ysinh = function() {\n    save();\n    yysinh();\n    return restore();\n  };\n\n  yysinh = function() {\n    var d;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCSINH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.sinh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(SINH);\n    push(p1);\n    return list(2);\n  };\n\n  subst = function() {\n    var expr, i, l1, m1, newExpr, newTensor, oldExpr, ref2, ref3;\n    save();\n    newExpr = pop();\n    oldExpr = pop();\n    if (oldExpr === symbol(NIL) || newExpr === symbol(NIL)) {\n      restore();\n      return;\n    }\n    expr = pop();\n    if (istensor(expr)) {\n      newTensor = alloc_tensor(expr.tensor.nelem);\n      newTensor.tensor.ndim = expr.tensor.ndim;\n      for (i = l1 = 0, ref2 = expr.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        newTensor.tensor.dim[i] = expr.tensor.dim[i];\n      }\n      for (i = m1 = 0, ref3 = expr.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n        push(expr.tensor.elem[i]);\n        push(oldExpr);\n        push(newExpr);\n        subst();\n        newTensor.tensor.elem[i] = pop();\n        check_tensor_dimensions(newTensor);\n      }\n      push(newTensor);\n    } else if (equal(expr, oldExpr)) {\n      push(newExpr);\n    } else if (iscons(expr)) {\n      push(car(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      push(cdr(expr));\n      push(oldExpr);\n      push(newExpr);\n      subst();\n      cons();\n    } else {\n      push(expr);\n    }\n    return restore();\n  };\n\n  // 'sum' function\n\n  //define A p3\n  //define B p4\n  //define I p5\n  //define X p6\n\n  // leaves the sum at the top of the stack\n  Eval_sum = function() {\n    var body, i, indexVariable, j, k, l1, ref2, ref3;\n    i = 0;\n    j = 0;\n    k = 0;\n    // 1st arg\n    body = cadr(p1);\n    // 2nd arg (index)\n    indexVariable = caddr(p1);\n    if (!issymbol(indexVariable)) {\n      stop(\"sum: 2nd arg?\");\n    }\n    // 3rd arg (lower limit)\n    push(cadddr(p1));\n    Eval();\n    j = pop_integer();\n    if (isNaN(j)) {\n      push(p1);\n      return;\n    }\n    // 4th arg (upper limit)\n    push(caddddr(p1));\n    Eval();\n    k = pop_integer();\n    if (isNaN(k)) {\n      push(p1);\n      return;\n    }\n    // remember contents of the index\n    // variable so we can put it back after the loop\n    p4 = get_binding(indexVariable);\n    push_integer(0);\n    for (i = l1 = ref2 = j, ref3 = k; (ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      push_integer(i);\n      p5 = pop();\n      set_binding(indexVariable, p5);\n      push(body);\n      Eval();\n      add();\n    }\n    // put back the index variable to original content\n    return set_binding(indexVariable, p4);\n  };\n\n  // Tangent function of numerical and symbolic arguments\n  Eval_tan = function() {\n    push(cadr(p1));\n    Eval();\n    return tangent();\n  };\n\n  tangent = function() {\n    save();\n    yytangent();\n    return restore();\n  };\n\n  yytangent = function() {\n    var d, n;\n    n = 0;\n    d = 0.0;\n    p1 = pop();\n    if (car(p1) === symbol(ARCTAN)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tan(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    // tan function is antisymmetric, tan(-x) = -tan(x)\n    if (isnegative(p1)) {\n      push(p1);\n      negate();\n      tangent();\n      negate();\n      return;\n    }\n    // multiply by 180/pi to go from radians to degrees.\n    // we go from radians to degrees because it's much\n    // easier to calculate symbolic results of most (not all) \"classic\"\n    // angles (e.g. 30,45,60...) if we calculate the degrees\n    // and the we do a switch on that.\n    // Alternatively, we could look at the fraction of pi\n    // (e.g. 60 degrees is 1/3 pi) but that's more\n    // convoluted as we'd need to look at both numerator and\n    // denominator.\n    push(p1);\n    push_integer(180);\n    multiply();\n    if (evaluatingAsFloats) {\n      push_double(Math.PI);\n    } else {\n      push_symbol(PI);\n    }\n    divide();\n    n = pop_integer();\n    // most \"good\" (i.e. compact) trigonometric results\n    // happen for a round number of degrees. There are some exceptions\n    // though, e.g. 22.5 degrees, which we don't capture here.\n    if (n < 0 || isNaN(n)) {\n      push(symbol(TAN));\n      push(p1);\n      list(2);\n      return;\n    }\n    switch (n % 360) {\n      case 0:\n      case 180:\n        return push_integer(0);\n      case 30:\n      case 210:\n        push_rational(1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 150:\n      case 330:\n        push_rational(-1, 3);\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return multiply();\n      case 45:\n      case 225:\n        return push_integer(1);\n      case 135:\n      case 315:\n        return push_integer(-1);\n      case 60:\n      case 240:\n        push_integer(3);\n        push_rational(1, 2);\n        return power();\n      case 120:\n      case 300:\n        push_integer(3);\n        push_rational(1, 2);\n        power();\n        return negate();\n      default:\n        push(symbol(TAN));\n        push(p1);\n        return list(2);\n    }\n  };\n\n  //             exp(2 x) - 1\n  //  tanh(x) = --------------\n  //             exp(2 x) + 1\n  Eval_tanh = function() {\n    var d;\n    d = 0.0;\n    push(cadr(p1));\n    Eval();\n    p1 = pop();\n    if (car(p1) === symbol(ARCTANH)) {\n      push(cadr(p1));\n      return;\n    }\n    if (isdouble(p1)) {\n      d = Math.tanh(p1.d);\n      if (Math.abs(d) < 1e-10) {\n        d = 0.0;\n      }\n      push_double(d);\n      return;\n    }\n    if (isZeroAtomOrTensor(p1)) {\n      push(zero);\n      return;\n    }\n    push_symbol(TANH);\n    push(p1);\n    return list(2);\n  };\n\n  Eval_taylor = function() {\n    // 1st arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    // 2nd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      guess();\n    } else {\n      push(p2);\n    }\n    // 3rd arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(24); // default number of terms\n    } else {\n      push(p2);\n    }\n    // 4th arg\n    p1 = cdr(p1);\n    push(car(p1));\n    Eval();\n    p2 = pop();\n    if (p2 === symbol(NIL)) {\n      push_integer(0); // default expansion point\n    } else {\n      push(p2);\n    }\n    return taylor();\n  };\n\n  //define F p1\n  //define X p2\n  //define N p3\n  //define A p4\n  //define C p5\n  taylor = function() {\n    var i, k, l1, ref2;\n    i = 0;\n    k = 0;\n    save();\n    p4 = pop();\n    p3 = pop();\n    p2 = pop();\n    p1 = pop();\n    push(p3);\n    k = pop_integer();\n    if (isNaN(k)) {\n      push_symbol(TAYLOR);\n      push(p1);\n      push(p2);\n      push(p3);\n      push(p4);\n      list(5);\n      restore();\n      return;\n    }\n    push(p1);\n    push(p2);\n    push(p4);\n    subst();\n    Eval();\n    push_integer(1);\n    p5 = pop();\n    for (i = l1 = 1, ref2 = k; (1 <= ref2 ? l1 <= ref2 : l1 >= ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(p2);\n      derivative();\n      p1 = pop();\n      if (isZeroAtomOrTensor(p1)) {\n        break;\n      }\n      push(p5);\n      push(p2);\n      push(p4);\n      subtract();\n      multiply();\n      p5 = pop();\n      push(p1);\n      push(p2);\n      push(p4);\n      subst();\n      Eval();\n      push(p5);\n      multiply();\n      push_integer(i);\n      factorial();\n      divide();\n      add();\n    }\n    return restore();\n  };\n\n  //(docs are generated from top-level comments, keep an eye on the formatting!)\n  /* tensor =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  General description\n  -------------------\n  Tensors are a strange in-between of matrices and \"computer\"\n  rectangular data structures.\n\n  Tensors, unlike matrices, and like rectangular data structures,\n  can have an arbitrary number of dimensions (rank), although a tensor with\n  rank zero is just a scalar.\n\n  Tensors, like matrices and unlike many computer rectangular data structures,\n  must be \"contiguous\" i.e. have no empty spaces within its size, and \"uniform\",\n  i.e. each element must have the same shape and hence the same rank.\n\n  Also tensors have necessarily to make a distinction between row vectors,\n  column vectors (which have a rank of 2) and uni-dimensional vectors (rank 1).\n  They look very similar but they are fundamentally different.\n\n  Tensors are 1-indexed, as per general math notation, and like Fortran,\n  Lua, Mathematica, SASL, MATLAB, Julia, Erlang and APL.\n\n  Tensors with elements that are also tensors get promoted to a higher rank\n  , this is so we can represent and get the rank of a matrix correctly.\n  Example:\n  Start with a tensor of rank 1 with 2 elements (i.e. shape: 2)\n  if you put in both its elements another 2 tensors\n  of rank 1 with 2 elements (i.e. shape: 2)\n  then the result is a tensor of rank 2 with shape 2,2\n  i.e. the dimension of a tensor at all times must be\n  the number of nested tensors in it.\n  Also, all tensors must be \"uniform\" i.e. they must be accessed\n  uniformly, which means that all existing elements of a tensor\n  must be contiguous and have the same shape.\n  Implication of it all is that you can't put arbitrary\n  tensors inside tensors (like you would do to represent block matrices)\n  Rather, all tensors inside tensors must have same shape (and hence, rank)\n\n  Limitations\n  -----------\n  n.a.\n\n  Implementation info\n  -------------------\n  Tensors are implemented...\n\n  */\n  // Called from the \"eval\" module to evaluate tensor elements.\n  // p1 points to the tensor operand.\n  Eval_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n\n    //---------------------------------------------------------------------\n\n    //  create a new tensor for the result\n\n    //---------------------------------------------------------------------\n    check_tensor_dimensions(p1);\n    nelem = p1.tensor.nelem;\n    ndim = p1.tensor.ndim;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    //---------------------------------------------------------------------\n\n    //  b = Eval(a)\n\n    //---------------------------------------------------------------------\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    check_tensor_dimensions(p2);\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      //console.log \"push/pop: pushing element a of \" + i\n      push(a[i]);\n      Eval();\n      //console.log \"push/pop: popping into element b of \" + i\n      b[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    //---------------------------------------------------------------------\n\n    //  push the result\n\n    //---------------------------------------------------------------------\n    push(p2);\n    return promote_tensor();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Add tensors\n\n  //  Input:    Operands on stack\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  tensor_plus_tensor = function() {\n    var a, b, c, i, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    save();\n    p2 = pop();\n    p1 = pop();\n    // are the dimension lists equal?\n    ndim = p1.tensor.ndim;\n    if (ndim !== p2.tensor.ndim) {\n      push(symbol(NIL));\n      restore();\n      return;\n    }\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {\n        push(symbol(NIL));\n        restore();\n        return;\n      }\n    }\n    // create a new tensor for the result\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    // c = a + b\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = n1 = 0, ref4 = nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      push(a[i]);\n      push(b[i]);\n      add();\n      c[i] = pop();\n    }\n    // push the result\n    push(p3);\n    return restore();\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  careful not to reorder factors\n\n  //-----------------------------------------------------------------------------\n  tensor_times_scalar = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  scalar_times_tensor = function() {\n    var a, b, i, l1, m1, ndim, nelem, ref2, ref3;\n    i = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b\n    save();\n    p2 = pop();\n    p1 = pop();\n    ndim = p2.tensor.ndim;\n    nelem = p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p2.tensor.dim[i];\n    }\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      push(a[i]);\n      multiply();\n      b[i] = pop();\n    }\n    push(p3);\n    return restore();\n  };\n\n  check_tensor_dimensions = function(p) {\n    if (p.tensor.nelem !== p.tensor.elem.length) {\n      console.log(\"something wrong in tensor dimensions\");\n      debugger;\n    }\n  };\n\n  is_square_matrix = function(p) {\n    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_tensor = function() {\n    var a, b, c, i, j, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;\n    i = 0;\n    j = 0;\n    ndim = 0;\n    nelem = 0;\n    //U **a, **b, **c\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    if (ndim + 1 >= MAXDIM) {\n      push_symbol(DERIVATIVE);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    p3 = alloc_tensor(nelem * p2.tensor.nelem);\n    p3.tensor.ndim = ndim + 1;\n    for (i = l1 = 0, ref2 = ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p3.tensor.dim[ndim] = p2.tensor.dim[0];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n    c = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      for (j = n1 = 0, ref4 = p2.tensor.nelem; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n        push(a[i]);\n        push(b[j]);\n        derivative();\n        c[i * p2.tensor.nelem + j] = pop();\n      }\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  gradient of scalar\n\n  //-----------------------------------------------------------------------------\n  d_scalar_tensor = function() {\n    var a, b, i, l1, ref2;\n    //U **a, **b\n    p3 = alloc_tensor(p2.tensor.nelem);\n    p3.tensor.ndim = 1;\n    p3.tensor.dim[0] = p2.tensor.dim[0];\n    a = p2.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = l1 = 0, ref2 = p2.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1);\n      push(a[i]);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Derivative of tensor\n\n  //-----------------------------------------------------------------------------\n  d_tensor_scalar = function() {\n    var a, b, i, l1, m1, ref2, ref3;\n    i = 0;\n    //U **a, **b\n    p3 = alloc_tensor(p1.tensor.nelem);\n    p3.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    a = p1.tensor.elem;\n    b = p3.tensor.elem;\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      push(a[i]);\n      push(p2);\n      derivative();\n      b[i] = pop();\n    }\n    return push(p3);\n  };\n\n  compare_tensors = function(p1, p2) {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    if (p1.tensor.ndim < p2.tensor.ndim) {\n      return -1;\n    }\n    if (p1.tensor.ndim > p2.tensor.ndim) {\n      return 1;\n    }\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {\n        return -1;\n      }\n      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {\n        return 1;\n      }\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        continue;\n      }\n      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return 0;\n  };\n\n  //-----------------------------------------------------------------------------\n\n  //  Raise a tensor to a power\n\n  //  Input:    p1  tensor\n\n  //      p2  exponent\n\n  //  Output:    Result on stack\n\n  //-----------------------------------------------------------------------------\n  power_tensor = function() {\n    var i, k, l1, m1, n, ref2, ref3, results;\n    i = 0;\n    k = 0;\n    n = 0;\n    // first and last dims must be equal\n    k = p1.tensor.ndim - 1;\n    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    push(p2);\n    n = pop_integer();\n    if (isNaN(n)) {\n      push_symbol(POWER);\n      push(p1);\n      push(p2);\n      list(3);\n      return;\n    }\n    if (n === 0) {\n      if (p1.tensor.ndim !== 2) {\n        stop(\"power(tensor,0) with tensor rank not equal to 2\");\n      }\n      n = p1.tensor.dim[0];\n      p1 = alloc_tensor(n * n);\n      p1.tensor.ndim = 2;\n      p1.tensor.dim[0] = n;\n      p1.tensor.dim[1] = n;\n      for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        p1.tensor.elem[n * i + i] = one;\n      }\n      check_tensor_dimensions(p1);\n      push(p1);\n      return;\n    }\n    if (n < 0) {\n      n = -n;\n      push(p1);\n      inv();\n      p1 = pop();\n    }\n    push(p1);\n    results = [];\n    for (i = m1 = 1, ref3 = n; (1 <= ref3 ? m1 < ref3 : m1 > ref3); i = 1 <= ref3 ? ++m1 : --m1) {\n      push(p1);\n      inner();\n      if (isZeroAtomOrTensor(stack[tos - 1])) {\n        break;\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  copy_tensor = function() {\n    var i, l1, m1, ref2, ref3;\n    i = 0;\n    save();\n    p1 = pop();\n    p2 = alloc_tensor(p1.tensor.nelem);\n    p2.tensor.ndim = p1.tensor.ndim;\n    for (i = l1 = 0, ref2 = p1.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (i = m1 = 0, ref3 = p1.tensor.nelem; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p2.tensor.elem[i] = p1.tensor.elem[i];\n    }\n    check_tensor_dimensions(p1);\n    check_tensor_dimensions(p2);\n    push(p2);\n    return restore();\n  };\n\n  // Tensors with elements that are also tensors get promoted to a higher rank.\n  promote_tensor = function() {\n    var i, j, k, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;\n    i = 0;\n    j = 0;\n    k = 0;\n    nelem = 0;\n    ndim = 0;\n    save();\n    p1 = pop();\n    if (!istensor(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    p2 = p1.tensor.elem[0];\n    for (i = l1 = 1, ref2 = p1.tensor.nelem; (1 <= ref2 ? l1 < ref2 : l1 > ref2); i = 1 <= ref2 ? ++l1 : --l1) {\n      if (!compatible(p2, p1.tensor.elem[i])) {\n        stop(\"Cannot promote tensor due to inconsistent tensor components.\");\n      }\n    }\n    if (!istensor(p2)) {\n      push(p1);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim + p2.tensor.ndim;\n    if (ndim > MAXDIM) {\n      stop(\"tensor rank > \" + MAXDIM);\n    }\n    nelem = p1.tensor.nelem * p2.tensor.nelem;\n    p3 = alloc_tensor(nelem);\n    p3.tensor.ndim = ndim;\n    for (i = m1 = 0, ref3 = p1.tensor.ndim; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p3.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    for (j = n1 = 0, ref4 = p2.tensor.ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); j = 0 <= ref4 ? ++n1 : --n1) {\n      p3.tensor.dim[i + j] = p2.tensor.dim[j];\n    }\n    k = 0;\n    for (i = o1 = 0, ref5 = p1.tensor.nelem; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      p2 = p1.tensor.elem[i];\n      for (j = q1 = 0, ref6 = p2.tensor.nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); j = 0 <= ref6 ? ++q1 : --q1) {\n        p3.tensor.elem[k++] = p2.tensor.elem[j];\n      }\n    }\n    check_tensor_dimensions(p2);\n    check_tensor_dimensions(p3);\n    push(p3);\n    return restore();\n  };\n\n  compatible = function(p, q) {\n    var i, l1, ref2;\n    if (!istensor(p) && !istensor(q)) {\n      return 1;\n    }\n    if (!istensor(p) || !istensor(q)) {\n      return 0;\n    }\n    if (p.tensor.ndim !== q.tensor.ndim) {\n      return 0;\n    }\n    for (i = l1 = 0, ref2 = p.tensor.ndim; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (p.tensor.dim[i] !== q.tensor.dim[i]) {\n        return 0;\n      }\n    }\n    return 1;\n  };\n\n  // If the number of args is odd then the last arg is the default result.\n  // Works like a switch statement. Could also be used for piecewise\n  // functions? TODO should probably be called \"switch\"?\n  Eval_test = function() {\n    var checkResult, orig;\n    orig = p1;\n    p1 = cdr(p1);\n    while (iscons(p1)) {\n      // odd number of parameters means that the\n      // last argument becomes the default case\n      // i.e. the one without a test.\n      if (cdr(p1) === symbol(NIL)) {\n        push(car(p1));\n        Eval();\n        return;\n      }\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));\n      if (checkResult == null) {\n        // we couldn't determine the result\n        // of a test. This means we can't conclude\n        // anything about the result of the\n        // overall test, so we must bail\n        // with the unevalled test\n        push(orig);\n        return;\n      } else if (checkResult) {\n        // test succesful, we found out output\n        push(cadr(p1));\n        Eval();\n        return;\n      } else {\n        // test unsuccessful, continue to the\n        // next pair of test,value\n        p1 = cddr(p1);\n      }\n    }\n    // no test matched and there was no\n    // catch-all case, so we return zero.\n    return push_integer(0);\n  };\n\n  // we test A==B by first subtracting and checking if we symbolically\n  // get zero. If not, we evaluate to float and check if we get a zero.\n  // If we get another NUMBER then we know they are different.\n  // If we get something else, then we don't know and we return the\n  // unaveluated test, which is the same as saying \"maybe\".\n  Eval_testeq = function() {\n    var checkResult, orig, subtractionResult;\n    // first try without simplifyng both sides\n    orig = p1;\n    push(cadr(p1));\n    Eval();\n    push(caddr(p1));\n    Eval();\n    subtract();\n    subtractionResult = pop();\n    // OK so we are doing something tricky here\n    // we are using isZeroLikeOrNonZeroLikeOrUndetermined to check if the result\n    // is zero or not zero or unknown.\n    // isZeroLikeOrNonZeroLikeOrUndetermined has some routines\n    // to determine the zero-ness/non-zero-ness or\n    // undeterminate-ness of things so we use\n    // that here and down below.\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // we didn't get a simple numeric result but\n    // let's try again after doing\n    // a simplification on both sides\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    subtractionResult = pop();\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);\n    if (checkResult) {\n      push_integer(0);\n      return;\n    } else if ((checkResult != null) && !checkResult) {\n      push_integer(1);\n      return;\n    }\n    // if we didn't get to a number then we\n    // don't know whether the quantities are\n    // different so do nothing\n    return push(orig);\n  };\n\n  // Relational operators expect a numeric result for operand difference.\n  Eval_testge = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison >= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testgt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison > 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testle = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison <= 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  Eval_testlt = function() {\n    var comparison, orig;\n    orig = p1;\n    comparison = cmp_args();\n    if (comparison == null) {\n      push(orig);\n      return;\n    }\n    if (comparison < 0) {\n      return push_integer(1);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // not definition\n  Eval_not = function() {\n    var checkResult, wholeAndExpression;\n    wholeAndExpression = p1;\n    checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));\n    if (checkResult == null) {\n      // inconclusive test on predicate\n      return push(wholeAndExpression);\n    } else if (checkResult) {\n      // true -> false\n      return push_integer(0);\n    } else {\n      // false -> true\n      return push_integer(1);\n    }\n  };\n\n  /* and =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  a,b,...\n\n  General description\n  -------------------\n  Logical-and of predicate expressions.\n\n  */\n  // and definition\n  Eval_and = function() {\n    var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;\n    wholeAndExpression = p1;\n    andPredicates = cdr(wholeAndExpression);\n    somePredicateUnknown = false;\n    while (iscons(andPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        andPredicates = cdr(andPredicates);\n      } else if (checkResult) {\n        // found a true, move on to the next predicate\n        andPredicates = cdr(andPredicates);\n      } else if (!checkResult) {\n        // found a false, enough to falsify everything and return\n        push_integer(0);\n        return;\n      }\n    }\n    // We checked all the predicates and none of them\n    // was false. So they were all either true or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns true.\n    if (somePredicateUnknown) {\n      return push(wholeAndExpression);\n    } else {\n      return push_integer(1);\n    }\n  };\n\n  // or definition\n  Eval_or = function() {\n    var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;\n    wholeOrExpression = p1;\n    orPredicates = cdr(wholeOrExpression);\n    somePredicateUnknown = false;\n    while (iscons(orPredicates)) {\n      // eval each predicate\n      checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));\n      if (checkResult == null) {\n        // here we have stuff that is not reconducible to any\n        // numeric value (or tensor with numeric values) e.g.\n        // 'a+b', so it just means that we just don't know the\n        // truth value of this particular predicate.\n        // We'll track the fact that we found an unknown\n        // predicate and we continue with the other predicates.\n        // (note that in case some subsequent predicate will be false,\n        // it won't matter that we found some unknowns and\n        // the whole test will be immediately zero).\n        somePredicateUnknown = true;\n        orPredicates = cdr(orPredicates);\n      } else if (checkResult) {\n        // found a true, enough to return true\n        push_integer(1);\n        return;\n      } else if (!checkResult) {\n        // found a false, move on to the next predicate\n        orPredicates = cdr(orPredicates);\n      }\n    }\n    // We checked all the predicates and none of them\n    // was true. So they were all either false or unknown.\n    // Now, if even just one was unknown, we'll have to call this\n    // test as inconclusive and return the whole test expression.\n    // If all the predicates were known, then we can conclude\n    // that the test returns false.\n    if (somePredicateUnknown) {\n      return push(wholeOrExpression);\n    } else {\n      return push_integer(0);\n    }\n  };\n\n  // use subtract for cases like A < A + 1\n\n  // TODO you could be smarter here and\n  // simplify both sides only in the case\n  // of \"relational operator: cannot determine...\"\n  // a bit like we do in Eval_testeq\n  cmp_args = function() {\n    var t;\n    t = 0;\n    push(cadr(p1));\n    Eval();\n    simplify();\n    push(caddr(p1));\n    Eval();\n    simplify();\n    subtract();\n    p1 = pop();\n    // try floating point if necessary\n    if (p1.k !== NUM && p1.k !== DOUBLE) {\n      push(p1);\n      yyfloat();\n      Eval();\n      p1 = pop();\n    }\n    //console.log \"comparison: \" + p1.toString()\n    if (isZeroAtomOrTensor(p1)) {\n      //console.log \"comparison isZero \"\n      return 0;\n    }\n    switch (p1.k) {\n      case NUM:\n        if (MSIGN(p1.q.a) === -1) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      case DOUBLE:\n        //console.log \"comparison p1.d: \" + p1.d\n        if (p1.d < 0.0) {\n          t = -1;\n        } else {\n          t = 1;\n        }\n        break;\n      default:\n        //console.log \"comparison is null\"\n        t = null;\n    }\n    return t;\n  };\n\n  /*\n  Transform an expression using a pattern. The\n  pattern can come from the integrals table or\n  the user-defined patterns.\n\n  The expression and free variable are on the stack.\n\n  The argument s is a null terminated list of transform rules.\n\n  For example, see the itab (integrals table)\n\n  Internally, the following symbols are used:\n\n    F  input expression\n\n    X  free variable, i.e. F of X\n\n    A  template expression\n\n    B  result expression\n\n    C  list of conditional expressions\n\n  Puts the final expression on top of stack\n  (whether it's transformed or not) and returns\n  true is successful, false if not.\n\n  */\n  // p1 and p2 are tmps\n\n  //define F p3\n  //define X p4\n  //define A p5\n  //define B p6\n  //define C p7\n  transform = function(s, generalTransform) {\n    var bookmarkTosToPrintDecomps, eachTransformEntry, i, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;\n    transform_h = 0;\n    save();\n    p1 = null;\n    p4 = pop(); // X i.e. free variable\n    p3 = pop(); // F i.e. input expression\n    if (DEBUG) {\n      console.log(\"         !!!!!!!!!   transform on: \" + p3);\n    }\n    saveMetaBindings();\n    set_binding(symbol(METAX), p4);\n    // put constants in F(X) on the stack\n    transform_h = tos;\n    push_integer(1);\n    push(p3);\n    push(p4);\n    polyform();\n    push(p4);\n    bookmarkTosToPrintDecomps = tos - 2;\n    decomp(generalTransform);\n    numberOfDecomps = tos - bookmarkTosToPrintDecomps;\n    if (DEBUG) {\n      console.log(\"  \" + numberOfDecomps + \" decomposed elements ====== \");\n      for (i = l1 = 0, ref2 = numberOfDecomps; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        console.log(\"  decomposition element \" + i + \": \" + stack[tos - 1 - i]);\n      }\n    }\n    transformationSuccessful = false;\n    if (generalTransform) {\n      if (!isNumericAtom(p3)) {\n        theTransform = s;\n        if (DEBUG) {\n          console.log(\"applying transform: \" + theTransform);\n        }\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + theTransform);\n        }\n        push(theTransform);\n        // replacements of meta variables. Note that we don't\n        // use scan_meta because the pattern is not a string\n        // that we have to parse, it's a tree already.\n        // replace a_ with METAA in the passed transformation\n        push(symbol(SYMBOL_A_UNDERSCORE));\n        push(symbol(METAA));\n        subst();\n        // replace b_ with METAB in the passed transformation\n        push(symbol(SYMBOL_B_UNDERSCORE));\n        push(symbol(METAB));\n        subst();\n        // replace x_ with METAX in the passed transformation\n        push(symbol(SYMBOL_X_UNDERSCORE));\n        push(symbol(METAX));\n        subst();\n        p1 = pop();\n        p5 = car(p1);\n        if (DEBUG) {\n          console.log(\"template expression: \" + p5);\n        }\n        p6 = cadr(p1);\n        p7 = cddr(p1);\n        /*\n        p5 = p1.tensor.elem[0]\n        p6 = p1.tensor.elem[1]\n        for i in [2..(p1.tensor.elem.length-1)]\n          push p1.tensor.elem[i]\n        list(p1.tensor.elem.length - 2)\n        p7 = pop()\n        */\n        if (f_equals_a(transform_h, generalTransform)) {\n          // successful transformation,\n          // transformed result is in p6\n          transformationSuccessful = true;\n        } else {\n          // the match failed but perhaps we can match\n          // something lower down in the tree, so\n          // let's recurse the tree\n          if (DEBUG) {\n            console.log(\"p3 at this point: \" + p3);\n          }\n          transformedTerms = [];\n          if (DEBUG) {\n            console.log(\"car(p3): \" + car(p3));\n          }\n          restTerm = p3;\n          if (iscons(restTerm)) {\n            transformedTerms.push(car(p3));\n            restTerm = cdr(p3);\n          }\n          while (iscons(restTerm)) {\n            secondTerm = car(restTerm);\n            restTerm = cdr(restTerm);\n            if (DEBUG) {\n              console.log(\"tos before recursive transform: \" + tos);\n            }\n            push(secondTerm);\n            push_symbol(NIL);\n            if (DEBUG) {\n              console.log(\"testing: \" + secondTerm);\n            }\n            //if (secondTerm+\"\") == \"eig(A x,transpose(A x))()\"\n            //  debugger\n            if (DEBUG) {\n              console.log(\"about to try to simplify other term: \" + secondTerm);\n            }\n            success = transform(s, generalTransform);\n            transformationSuccessful = transformationSuccessful || success;\n            transformedTerms.push(pop());\n            if (DEBUG) {\n              console.log(\"tried to simplify other term: \" + secondTerm + \" ...successful?: \" + success + \" ...transformed: \" + transformedTerms[transformedTerms.length - 1]);\n            }\n          }\n          // recreate the tree we were passed,\n          // but with all the terms being transformed\n          if (transformedTerms.length !== 0) {\n            for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {\n              i = transformedTerms[m1];\n              push(i);\n            }\n            list(transformedTerms.length);\n            p6 = pop(); // \"integrals\" mode\n          }\n        }\n      }\n    } else {\n      for (n1 = 0, len1 = s.length; n1 < len1; n1++) {\n        eachTransformEntry = s[n1];\n        if (DEBUG) {\n          console.log(\"scanning table entry \" + eachTransformEntry);\n          if ((eachTransformEntry + \"\").indexOf(\"f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))\") !== -1) {\n            debugger;\n          }\n        }\n        if (eachTransformEntry) {\n          scan_meta(eachTransformEntry);\n          p1 = pop();\n          p5 = cadr(p1);\n          p6 = caddr(p1);\n          p7 = cdddr(p1);\n          /*\n          p5 = p1.tensor.elem[0]\n          p6 = p1.tensor.elem[1]\n          for i in [2..(p1.tensor.elem.length-1)]\n            push p1.tensor.elem[i]\n          list(p1.tensor.elem.length - 2)\n          p7 = pop()\n          */\n          if (f_equals_a(transform_h, generalTransform)) {\n            // there is a successful transformation,\n            // transformed result is in p6\n            transformationSuccessful = true;\n            break;\n          }\n        }\n      }\n    }\n    moveTos(transform_h);\n    if (transformationSuccessful) {\n      //console.log \"transformation successful\"\n      // a transformation was successful\n      push(p6);\n      Eval();\n      p1 = pop();\n      //console.log \"...into: \" + p1\n      transformationSuccessful = true;\n    } else {\n      // transformations failed\n      if (generalTransform) {\n        // result = original expression\n        p1 = p3;\n      } else {\n        p1 = symbol(NIL);\n      }\n    }\n    restoreMetaBindings();\n    push(p1);\n    restore();\n    return transformationSuccessful;\n  };\n\n  saveMetaBindings = function() {\n    push(get_binding(symbol(METAA)));\n    push(get_binding(symbol(METAB)));\n    return push(get_binding(symbol(METAX)));\n  };\n\n  restoreMetaBindings = function() {\n    set_binding(symbol(METAX), pop());\n    set_binding(symbol(METAB), pop());\n    return set_binding(symbol(METAA), pop());\n  };\n\n  // search for a METAA and METAB such that F = A\n  f_equals_a = function(h, generalTransform) {\n    var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;\n    fea_i = 0;\n    fea_j = 0;\n    for (fea_i = l1 = ref2 = h, ref3 = tos; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); fea_i = ref2 <= ref3 ? ++l1 : --l1) {\n      set_binding(symbol(METAA), stack[fea_i]);\n      if (DEBUG) {\n        console.log(\"  binding METAA to \" + get_binding(symbol(METAA)));\n      }\n      for (fea_j = m1 = ref4 = h, ref5 = tos; (ref4 <= ref5 ? m1 < ref5 : m1 > ref5); fea_j = ref4 <= ref5 ? ++m1 : --m1) {\n        set_binding(symbol(METAB), stack[fea_j]);\n        if (DEBUG) {\n          console.log(\"  binding METAB to \" + get_binding(symbol(METAB)));\n        }\n        // now test all the conditions (it's an and between them)\n        p1 = p7;\n        while (iscons(p1)) {\n          push(car(p1));\n          Eval();\n          p2 = pop();\n          if (isZeroAtomOrTensor(p2)) {\n            break;\n          }\n          p1 = cdr(p1);\n        }\n        if (iscons(p1)) {\n          // conditions are not met,\n          // skip to the next binding of metas\n          continue;\n        }\n        push(p3);\n        if (DEBUG) {\n          console.log(\"about to evaluate template expression: \" + p5 + \" binding METAA to \" + get_binding(symbol(METAA)) + \" and binding METAB to \" + get_binding(symbol(METAB)) + \" and binding METAX to \" + get_binding(symbol(METAX)));\n        }\n        push(p5);\n        if (generalTransform) {\n          originalexpanding = expanding;\n          expanding = false;\n        }\n        Eval();\n        if (generalTransform) {\n          expanding = originalexpanding;\n        }\n        if (DEBUG) {\n          console.log(\"  comparing \" + stack[tos - 1] + \" to: \" + stack[tos - 2]);\n        }\n        subtract();\n        p1 = pop();\n        if (isZeroAtomOrTensor(p1)) {\n          if (DEBUG) {\n            console.log(\"binding METAA to \" + get_binding(symbol(METAA)));\n            console.log(\"binding METAB to \" + get_binding(symbol(METAB)));\n            console.log(\"binding METAX to \" + get_binding(symbol(METAX)));\n            console.log(\"comparing \" + p3 + \" to: \" + p5);\n          }\n          return 1; // yes\n        }\n      }\n    }\n    return 0; // no\n  };\n\n  // Transpose tensor indices\n  Eval_transpose = function() {\n    push(cadr(p1));\n    Eval();\n    // add default params if they\n    // have not been passed\n    if (cddr(p1) === symbol(NIL)) {\n      push_integer(1);\n      push_integer(2);\n    } else {\n      push(caddr(p1));\n      Eval();\n      push(cadddr(p1));\n      Eval();\n    }\n    return transpose();\n  };\n\n  transpose = function() {\n    var a, accumulator, ai, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, l1, m, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t;\n    i = 0;\n    j = 0;\n    k = 0;\n    l = 0;\n    m = 0;\n    ndim = 0;\n    nelem = 0;\n    t = 0;\n    ai = [];\n    an = [];\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      ai[i] = 0;\n      an[i] = 0;\n    }\n    //U **a, **b\n    save();\n    // by default p3 is 2 and p2 is 1\n    p3 = pop(); // index to be transposed\n    p2 = pop(); // other index to be transposed\n    p1 = pop(); // what needs to be transposed\n    \n    // a transposition just goes away when\n    // applied to a scalar\n    if (isNumericAtom(p1)) {\n      push(p1);\n      restore();\n      return;\n    }\n    // transposition goes away for identity matrix\n    if ((isplusone(p2) && isplustwo(p3)) || (isplusone(p3) && isplustwo(p2))) {\n      if (isidentitymatrix(p1)) {\n        push(p1);\n        restore();\n        return;\n      }\n    }\n    // a transposition just goes away when\n    // applied to another transposition with\n    // the same columns to be switched\n    if (istranspose(p1)) {\n      innerTranspSwitch1 = car(cdr(cdr(p1)));\n      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));\n      if ((equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2)) || (equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2)) || ((equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL))) && ((isplusone(p3) && isplustwo(p2)) || (isplusone(p2) && isplustwo(p3))))) {\n        push(car(cdr(p1)));\n        restore();\n        return;\n      }\n    }\n    // if operand is a sum then distribute\n    // (if we are in expanding mode)\n    if (expanding && isadd(p1)) {\n      p1 = cdr(p1);\n      push(zero);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        add();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // if operand is a multiplication then distribute\n    // (if we are in expanding mode)\n    if (expanding && ismultiply(p1)) {\n      p1 = cdr(p1);\n      push(one);\n      while (iscons(p1)) {\n        push(car(p1));\n        // add the dimensions to switch but only if\n        // they are not the default ones.\n        push(p2);\n        push(p3);\n        transpose();\n        multiply();\n        p1 = cdr(p1);\n      }\n      restore();\n      return;\n    }\n    // distribute the transpose of a dot\n    // if in expanding mode\n    // note that the distribution happens\n    // in reverse as per tranpose rules.\n    // The dot operator is not\n    // commutative, so, it matters.\n    if (expanding && isinnerordot(p1)) {\n      p1 = cdr(p1);\n      accumulator = [];\n      while (iscons(p1)) {\n        accumulator.push([car(p1), p2, p3]);\n        p1 = cdr(p1);\n      }\n      for (eachEntry = m1 = ref3 = accumulator.length - 1; (ref3 <= 0 ? m1 <= 0 : m1 >= 0); eachEntry = ref3 <= 0 ? ++m1 : --m1) {\n        push(accumulator[eachEntry][0]);\n        push(accumulator[eachEntry][1]);\n        push(accumulator[eachEntry][2]);\n        transpose();\n        if (eachEntry !== accumulator.length - 1) {\n          inner();\n        }\n      }\n      restore();\n      return;\n    }\n    if (!istensor(p1)) {\n      if (!isZeroAtomOrTensor(p1)) {\n        //stop(\"transpose: tensor expected, 1st arg is not a tensor\")\n        push_symbol(TRANSPOSE);\n        push(p1);\n        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {\n          push(p2);\n          push(p3);\n          list(4);\n        } else {\n          list(2);\n        }\n        restore();\n        return;\n      }\n      push(zero);\n      restore();\n      return;\n    }\n    ndim = p1.tensor.ndim;\n    nelem = p1.tensor.nelem;\n    // is it a vector?\n    // so here it's something curious - note how vectors are\n    // not really special two-dimensional matrices, but rather\n    // 1-dimension objects (like tensors can be). So since\n    // they have one dimension, transposition has no effect.\n    // (as opposed as if they were special two-dimensional\n    // matrices)\n    // see also Ran Pan, Tensor Transpose and Its Properties. CoRR abs/1411.1503 (2014)\n    if (ndim === 1) {\n      push(p1);\n      restore();\n      return;\n    }\n    push(p2);\n    l = pop_integer();\n    push(p3);\n    m = pop_integer();\n    if (l < 1 || l > ndim || m < 1 || m > ndim) {\n      stop(\"transpose: index out of range\");\n    }\n    l--;\n    m--;\n    p2 = alloc_tensor(nelem);\n    p2.tensor.ndim = ndim;\n    for (i = n1 = 0, ref4 = ndim; (0 <= ref4 ? n1 < ref4 : n1 > ref4); i = 0 <= ref4 ? ++n1 : --n1) {\n      p2.tensor.dim[i] = p1.tensor.dim[i];\n    }\n    p2.tensor.dim[l] = p1.tensor.dim[m];\n    p2.tensor.dim[m] = p1.tensor.dim[l];\n    a = p1.tensor.elem;\n    b = p2.tensor.elem;\n// init tensor index\n    for (i = o1 = 0, ref5 = ndim; (0 <= ref5 ? o1 < ref5 : o1 > ref5); i = 0 <= ref5 ? ++o1 : --o1) {\n      ai[i] = 0;\n      an[i] = p1.tensor.dim[i];\n    }\n// copy components from a to b\n    for (i = q1 = 0, ref6 = nelem; (0 <= ref6 ? q1 < ref6 : q1 > ref6); i = 0 <= ref6 ? ++q1 : --q1) {\n      // swap indices l and m\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      k = 0;\n      for (j = r1 = 0, ref7 = ndim; (0 <= ref7 ? r1 < ref7 : r1 > ref7); j = 0 <= ref7 ? ++r1 : --r1) {\n        k = (k * an[j]) + ai[j];\n      }\n      // swap indices back\n      t = ai[l];\n      ai[l] = ai[m];\n      ai[m] = t;\n      t = an[l];\n      an[l] = an[m];\n      an[m] = t;\n      b[k] = a[i];\n// increment tensor index\n\n      // Suppose the tensor dimensions are 2 and 3.\n// Then the tensor index ai increments as follows:\n// 00 -> 01\n// 01 -> 02\n// 02 -> 10\n// 10 -> 11\n// 11 -> 12\n// 12 -> 00\n      for (j = s1 = ref8 = ndim - 1; (ref8 <= 0 ? s1 <= 0 : s1 >= 0); j = ref8 <= 0 ? ++s1 : --s1) {\n        if (++ai[j] < an[j]) {\n          break;\n        }\n        ai[j] = 0;\n      }\n    }\n    push(p2);\n    return restore();\n  };\n\n  // Evaluate a user defined function\n\n  //define F p3 # F is the function body\n  //define A p4 # A is the formal argument list\n  //define B p5 # B is the calling argument list\n  //define S p6 # S is the argument substitution list\n\n  // we got here because there was a function invocation and\n  // it's not been parsed (and consequently tagged) as any\n  // system function.\n  // So we are dealing with another function.\n  // The function could be actually defined, or not yet,\n  // so we'll deal with both cases.\n  /* d =====================================================================\n\n  Tags\n  ----\n  scripting, JS, internal, treenode, general concept\n\n  Parameters\n  ----------\n  f,x\n\n  General description\n  -------------------\n  Returns the partial derivative of f with respect to x. x can be a vector e.g. [x,y].\n\n  */\n  Eval_user_function = function() {\n    var bodyAndFormalArguments, h;\n    // Use \"derivative\" instead of \"d\" if there is no user function \"d\"\n    if (DEBUG) {\n      console.log(\"Eval_user_function evaluating: \" + car(p1));\n    }\n    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {\n      Eval_derivative();\n      return;\n    }\n    // normally car(p1) is a symbol with the function name\n    // but it could be something that has to be\n    // evaluated to get to the function definition instead\n    // (e.g. the function is an element of an array)\n    // so we do an eval to sort it all out. \n    push(car(p1));\n    Eval();\n    // we expect to find either the body and\n    // formula arguments, OR, if the function\n    // has not been defined yet, then the\n    // function will just contain its own name, as\n    // all undefined variables do.\n    bodyAndFormalArguments = pop();\n    if (isNumericAtom(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.\");\n    } else if (istensor(bodyAndFormalArguments)) {\n      stop(\"expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.\");\n    } else if (isstr(bodyAndFormalArguments)) {\n      stop(\"expected function, found string instead.\");\n    }\n    p3 = car(cdr(bodyAndFormalArguments)); // p3 is function body F\n    // p4 is the formal argument list\n    // that is also contained here in the FUNCTION node \n    p4 = car(cdr(cdr(bodyAndFormalArguments)));\n    p5 = cdr(p1);\n    // next check is whether evaluation did nothing, so the function is undefined\n    if ((car(bodyAndFormalArguments) !== symbol(FUNCTION)) || (bodyAndFormalArguments === car(p1))) { // p3 is F\n      // leave everything as it was and return\n      h = tos;\n      push(bodyAndFormalArguments);\n      p1 = p5;\n      while (iscons(p1)) {\n        push(car(p1));\n        Eval();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      return;\n    }\n    // Create the argument substitution list p6(S)\n    p1 = p4;\n    p2 = p5;\n    h = tos;\n    while (iscons(p1) && iscons(p2)) {\n      push(car(p1));\n      push(car(p2));\n      // why explicitly Eval the parameters when\n      // the body of the function is\n      // evalled anyways? Commenting it out. All tests pass...\n      //Eval()\n      p1 = cdr(p1);\n      p2 = cdr(p2);\n    }\n    list(tos - h);\n    p6 = pop();\n    push(p3);\n    if (iscons(p6)) { // p6 is S\n      push(p6);\n      rewrite_args();\n    }\n    //console.log \"rewritten body: \" + stack[tos-1]\n    return Eval();\n  };\n\n  // Rewrite by expanding symbols that contain args\n  rewrite_args = function() {\n    var h, n;\n    n = 0;\n    save();\n    // subst. list which is a list\n    // where each consecutive pair\n    // is what needs to be substituted and with what\n    p2 = pop();\n    p1 = pop();\n    if (istensor(p1)) {\n      n = rewrite_args_tensor();\n      restore();\n      return n;\n    }\n    if (iscons(p1)) {\n      h = tos;\n      if (car(p1) === car(p2)) {\n        // rewrite a function in\n        // the body with the one\n        // passed from the paramaters\n        push_symbol(EVAL);\n        push(car(cdr(p2)));\n        list(2);\n      } else {\n        // if there is no match\n        // then no substitution necessary\n        push(car(p1));\n      }\n      // continue recursively to\n      // rewrite the rest of the body\n      p1 = cdr(p1);\n      while (iscons(p1)) {\n        push(car(p1));\n        push(p2);\n        n += rewrite_args();\n        p1 = cdr(p1);\n      }\n      list(tos - h);\n      restore();\n      return n;\n    }\n    if (!issymbol(p1)) {\n      push(p1);\n      restore();\n      return 0;\n    }\n    // Here we are in a symbol case\n    // so we need to substitute\n\n    // Check if there is a direct match\n    // of symbols right away\n    p3 = p2;\n    while (iscons(p3)) {\n      if (p1 === car(p3)) {\n        push(cadr(p3));\n        restore();\n        return 1;\n      }\n      p3 = cddr(p3);\n    }\n    // Get the symbol's content, if _that_\n    // matches then do the substitution\n    p3 = get_binding(p1);\n    push(p3);\n    if (p1 !== p3) {\n      push(p2);\n      n = rewrite_args();\n      if (n === 0) {\n        pop();\n        push(p1); // restore if not rewritten with arg\n      }\n    }\n    restore();\n    return n;\n  };\n\n  rewrite_args_tensor = function() {\n    var i, l1, n, ref2;\n    n = 0;\n    i = 0;\n    push(p1);\n    copy_tensor();\n    p1 = pop();\n    for (i = l1 = 0, ref2 = p1.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      push(p1.tensor.elem[i]);\n      push(p2);\n      n += rewrite_args();\n      p1.tensor.elem[i] = pop();\n    }\n    check_tensor_dimensions(p1);\n    push(p1);\n    return n;\n  };\n\n  Eval_zero = function() {\n    var i, k, l1, m, m1, n, ref2, ref3;\n    i = 0;\n    k = [];\n    m = 0;\n    n = 0;\n    for (i = l1 = 0, ref2 = MAXDIM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      k[i] = 0;\n    }\n    m = 1;\n    n = 0;\n    p2 = cdr(p1);\n    while (iscons(p2)) {\n      push(car(p2));\n      Eval();\n      i = pop_integer();\n      if (i < 1 || isNaN(i)) {\n        // if the input is nonsensical\n        // just return 0\n        push(zero);\n        return;\n      }\n      m *= i;\n      k[n++] = i;\n      p2 = cdr(p2);\n    }\n    if (n === 0) {\n      push(zero);\n      return;\n    }\n    p1 = alloc_tensor(m);\n    p1.tensor.ndim = n;\n    for (i = m1 = 0, ref3 = n; (0 <= ref3 ? m1 < ref3 : m1 > ref3); i = 0 <= ref3 ? ++m1 : --m1) {\n      p1.tensor.dim[i] = k[i];\n    }\n    return push(p1);\n  };\n\n  allocatedId = 0;\n\n  alloc_tensor = function(nelem) {\n    var i, l1, p, ref2;\n    i = 0;\n    p = new U();\n    p.k = TENSOR;\n    p.tensor = new tensor();\n    p.tensor.nelem = nelem;\n    for (i = l1 = 0, ref2 = nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      p.tensor.elem[i] = zero;\n    }\n    p.tensor.allocatedId = allocatedId;\n    //if allocatedId == 9\n    //  debugger\n    allocatedId++;\n    check_tensor_dimensions(p);\n    return p;\n  };\n\n  /*\n  // garbage collector\n\n  void\n  gc(void)\n  {\n    int i, j\n    U *p\n\n    // tag everything\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++)\n        p[j].tag = 1\n    }\n\n    // untag what's used\n\n    untag(p0)\n    untag(p1)\n    untag(p2)\n    untag(p3)\n    untag(p4)\n    untag(p5)\n    untag(p6)\n    untag(p7)\n    untag(p8)\n    untag(p9)\n\n    untag(one)\n    untag(zero)\n    untag(imaginaryunit)\n\n    for (i = 0; i < NSYM; i++) {\n      untag(binding[i])\n      untag(arglist[i])\n    }\n\n    for (i = 0; i < tos; i++)\n      untag(stack[i])\n\n    for (i = (int) (frame - stack); i < TOS; i++)\n      untag(stack[i])\n\n    // collect everything that's still tagged\n\n    free_count = 0\n\n    for (i = 0; i < mcount; i++) {\n      p = mem[i]\n      for (j = 0; j < N; j++) {\n        if (p[j].tag == 0)\n          continue\n        // still tagged so it's unused, put on free list\n        switch (p[j].k) {\n        case TENSOR:\n          free(p[j].u.tensor)\n          break\n        case STR:\n          free(p[j].u.str)\n          break\n        case NUM:\n          mfree(p[j].u.q.a)\n          mfree(p[j].u.q.b)\n          break\n        }\n        p[j].k = CONS; // so no double free occurs above\n        p[j].u.cons.cdr = free_list\n        free_list = p + j\n        free_count++\n      }\n    }\n  }\n\n  void\n  untag(U *p)\n  {\n    int i\n\n    if (iscons(p)) {\n      do {\n        if (p->tag == 0)\n          return\n        p->tag = 0\n        untag(p->u.cons.car)\n        p = p->u.cons.cdr\n      } while (iscons(p))\n      untag(p)\n      return\n    }\n\n    if (p->tag) {\n      p->tag = 0\n       if (istensor(p)) {\n        for (i = 0; i < p->u.tensor->nelem; i++)\n          untag(p->u.tensor->elem[i])\n      }\n    }\n  }\n\n  // get memory for 100,000 atoms\n\n  void\n  alloc_mem(void)\n  {\n    int i\n    U *p\n    if (mcount == M)\n      return\n    p = (U *) malloc(N * sizeof (struct U))\n    if (p == NULL)\n      return\n    mem[mcount++] = p\n    for (i = 0; i < N; i++) {\n      p[i].k = CONS; // so no free in gc\n      p[i].u.cons.cdr = p + i + 1\n    }\n    p[N - 1].u.cons.cdr = free_list\n    free_list = p\n    free_count += N\n  }\n\n  void\n  print_mem_info(void)\n  {\n    char buf[100]\n\n    sprintf(buf, \"%d blocks (%d bytes/block)\\n\", N * mcount, (int) sizeof (U))\n    printstr(buf)\n\n    sprintf(buf, \"%d free\\n\", free_count)\n    printstr(buf)\n\n    sprintf(buf, \"%d used\\n\", N * mcount - free_count)\n    printstr(buf)\n  }\n  */\n  // returns 1 if expr p contains expr q, otherweise returns 0\n  Find = function(p, q) {\n    var i, l1, ref2;\n    i = 0;\n    if (equal(p, q)) {\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (Find(p.tensor.elem[i], q)) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (Find(car(p), q)) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (-1)^(something (but disregard\n  // imaginary units which are in the form (-1)^(1/2))\n  findPossibleClockForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (isimaginaryunit(p)) {\n      return 0;\n    }\n    if (car(p) === symbol(POWER) && !isinteger(caddr(p1))) {\n      if (Find(cadr(p), imaginaryunit)) {\n        //console.log \"found i^fraction \" + p\n        return 1;\n      }\n    }\n    if (car(p) === symbol(POWER) && equaln(cadr(p), -1) && !isinteger(caddr(p1))) {\n      //console.log \"found -1^fraction in \" + p\n      return 1;\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleClockForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleClockForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  // find stuff like (e)^(i something)\n  findPossibleExponentialForm = function(p) {\n    var i, l1, ref2;\n    i = 0;\n    if (car(p) === symbol(POWER) && cadr(p) === symbol(E)) {\n      return Find(caddr(p), imaginaryunit);\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        if (findPossibleExponentialForm(p.tensor.elem[i])) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    while (iscons(p)) {\n      if (findPossibleExponentialForm(car(p))) {\n        return 1;\n      }\n      p = cdr(p);\n    }\n    return 0;\n  };\n\n  $.Find = Find;\n\n  init = function() {\n    var i, l1, ref2;\n    //debugger\n    //console.log \"DOING AN INIT ========================================================================\"\n    i = 0;\n    flag = 0;\n    reset_after_error();\n    chainOfUserSymbolsNotFunctionsBeingEvaluated = [];\n    if (flag) { // already initted\n      return;\n    }\n    flag = 1;\n// total clearout of symbol table\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      isSymbolReclaimable[i] = false;\n    }\n    return defn();\n  };\n\n  defn_str = [\n    \"version=\\\"\" + version + \"\\\"\",\n    \"e=exp(1)\",\n    \"i=sqrt(-1)\",\n    \"autoexpand=1\",\n    \"assumeRealVariables=1\",\n    \"trange=[-pi,pi]\",\n    \"xrange=[-10,10]\",\n    \"yrange=[-10,10]\",\n    \"last=0\",\n    \"trace=0\",\n    \"forceFixedPrintout=1\",\n    \"maxFixedPrintoutDigits=6\",\n    \"printLeaveEAlone=1\",\n    \"printLeaveXAlone=0\",\n    // cross definition\n    \"cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]\",\n    // curl definition\n    \"curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]\",\n    // div definition\n    \"div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)\",\n    // Note that we use the mathematics / Javascript / Mathematica\n    // convention that \"log\" is indeed the natural logarithm.\n\n    // In engineering, biology, astronomy, \"log\" can stand instead\n    // for the \"common\" logarithm i.e. base 10. Also note that Google\n    // calculations use log for the common logarithm.\n    \"ln(x)=log(x)\"\n  ];\n\n  defn = function() {\n    var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;\n    p0 = symbol(NIL);\n    p1 = symbol(NIL);\n    p2 = symbol(NIL);\n    p3 = symbol(NIL);\n    p4 = symbol(NIL);\n    p5 = symbol(NIL);\n    p6 = symbol(NIL);\n    p7 = symbol(NIL);\n    p8 = symbol(NIL);\n    p9 = symbol(NIL);\n    std_symbol(\"abs\", ABS);\n    std_symbol(\"add\", ADD);\n    std_symbol(\"adj\", ADJ);\n    std_symbol(\"and\", AND);\n    std_symbol(\"approxratio\", APPROXRATIO);\n    std_symbol(\"arccos\", ARCCOS);\n    std_symbol(\"arccosh\", ARCCOSH);\n    std_symbol(\"arcsin\", ARCSIN);\n    std_symbol(\"arcsinh\", ARCSINH);\n    std_symbol(\"arctan\", ARCTAN);\n    std_symbol(\"arctanh\", ARCTANH);\n    std_symbol(\"arg\", ARG);\n    std_symbol(\"atomize\", ATOMIZE);\n    std_symbol(\"besselj\", BESSELJ);\n    std_symbol(\"bessely\", BESSELY);\n    std_symbol(\"binding\", BINDING);\n    std_symbol(\"binomial\", BINOMIAL);\n    std_symbol(\"ceiling\", CEILING);\n    std_symbol(\"check\", CHECK);\n    std_symbol(\"choose\", CHOOSE);\n    std_symbol(\"circexp\", CIRCEXP);\n    std_symbol(\"clear\", CLEAR);\n    std_symbol(\"clearall\", CLEARALL);\n    std_symbol(\"clearpatterns\", CLEARPATTERNS);\n    std_symbol(\"clock\", CLOCK);\n    std_symbol(\"coeff\", COEFF);\n    std_symbol(\"cofactor\", COFACTOR);\n    std_symbol(\"condense\", CONDENSE);\n    std_symbol(\"conj\", CONJ);\n    std_symbol(\"contract\", CONTRACT);\n    std_symbol(\"cos\", COS);\n    std_symbol(\"cosh\", COSH);\n    std_symbol(\"decomp\", DECOMP);\n    std_symbol(\"defint\", DEFINT);\n    std_symbol(\"deg\", DEGREE);\n    std_symbol(\"denominator\", DENOMINATOR);\n    std_symbol(\"det\", DET);\n    std_symbol(\"derivative\", DERIVATIVE);\n    std_symbol(\"dim\", DIM);\n    std_symbol(\"dirac\", DIRAC);\n    std_symbol(\"divisors\", DIVISORS);\n    std_symbol(\"do\", DO);\n    std_symbol(\"dot\", DOT);\n    std_symbol(\"draw\", DRAW);\n    std_symbol(\"dsolve\", DSOLVE);\n    std_symbol(\"erf\", ERF);\n    std_symbol(\"erfc\", ERFC);\n    std_symbol(\"eigen\", EIGEN);\n    std_symbol(\"eigenval\", EIGENVAL);\n    std_symbol(\"eigenvec\", EIGENVEC);\n    std_symbol(\"eval\", EVAL);\n    std_symbol(\"exp\", EXP);\n    std_symbol(\"expand\", EXPAND);\n    std_symbol(\"expcos\", EXPCOS);\n    std_symbol(\"expsin\", EXPSIN);\n    std_symbol(\"factor\", FACTOR);\n    std_symbol(\"factorial\", FACTORIAL);\n    std_symbol(\"factorpoly\", FACTORPOLY);\n    std_symbol(\"filter\", FILTER);\n    std_symbol(\"float\", FLOATF);\n    std_symbol(\"floor\", FLOOR);\n    std_symbol(\"for\", FOR);\n    std_symbol(\"function\", FUNCTION);\n    std_symbol(\"Gamma\", GAMMA);\n    std_symbol(\"gcd\", GCD);\n    std_symbol(\"hermite\", HERMITE);\n    std_symbol(\"hilbert\", HILBERT);\n    std_symbol(\"imag\", IMAG);\n    std_symbol(\"component\", INDEX);\n    std_symbol(\"inner\", INNER);\n    std_symbol(\"integral\", INTEGRAL);\n    std_symbol(\"inv\", INV);\n    std_symbol(\"invg\", INVG);\n    std_symbol(\"isinteger\", ISINTEGER);\n    std_symbol(\"isprime\", ISPRIME);\n    std_symbol(\"laguerre\", LAGUERRE);\n    //  std_symbol(\"laplace\", LAPLACE)\n    std_symbol(\"lcm\", LCM);\n    std_symbol(\"leading\", LEADING);\n    std_symbol(\"legendre\", LEGENDRE);\n    std_symbol(\"log\", LOG);\n    std_symbol(\"lookup\", LOOKUP);\n    std_symbol(\"mod\", MOD);\n    std_symbol(\"multiply\", MULTIPLY);\n    std_symbol(\"not\", NOT);\n    std_symbol(\"nroots\", NROOTS);\n    std_symbol(\"number\", NUMBER);\n    std_symbol(\"numerator\", NUMERATOR);\n    std_symbol(\"operator\", OPERATOR);\n    std_symbol(\"or\", OR);\n    std_symbol(\"outer\", OUTER);\n    std_symbol(\"pattern\", PATTERN);\n    std_symbol(\"patternsinfo\", PATTERNSINFO);\n    std_symbol(\"polar\", POLAR);\n    std_symbol(\"power\", POWER);\n    std_symbol(\"prime\", PRIME);\n    std_symbol(\"print\", PRINT);\n    std_symbol(\"print2dascii\", PRINT2DASCII);\n    std_symbol(\"printcomputer\", PRINTFULL);\n    std_symbol(\"printlatex\", PRINTLATEX);\n    std_symbol(\"printlist\", PRINTLIST);\n    std_symbol(\"printhuman\", PRINTPLAIN);\n    std_symbol(\"printLeaveEAlone\", PRINT_LEAVE_E_ALONE);\n    std_symbol(\"printLeaveXAlone\", PRINT_LEAVE_X_ALONE);\n    std_symbol(\"product\", PRODUCT);\n    std_symbol(\"quote\", QUOTE);\n    std_symbol(\"quotient\", QUOTIENT);\n    std_symbol(\"rank\", RANK);\n    std_symbol(\"rationalize\", RATIONALIZE);\n    std_symbol(\"real\", REAL);\n    std_symbol(\"rect\", YYRECT);\n    std_symbol(\"roots\", ROOTS);\n    std_symbol(\"round\", ROUND);\n    std_symbol(\"equals\", SETQ);\n    std_symbol(\"sgn\", SGN);\n    std_symbol(\"silentpattern\", SILENTPATTERN);\n    std_symbol(\"simplify\", SIMPLIFY);\n    std_symbol(\"sin\", SIN);\n    std_symbol(\"sinh\", SINH);\n    std_symbol(\"shape\", SHAPE);\n    std_symbol(\"sqrt\", SQRT);\n    std_symbol(\"stop\", STOP);\n    std_symbol(\"subst\", SUBST);\n    std_symbol(\"sum\", SUM);\n    std_symbol(\"symbolsinfo\", SYMBOLSINFO);\n    std_symbol(\"tan\", TAN);\n    std_symbol(\"tanh\", TANH);\n    std_symbol(\"taylor\", TAYLOR);\n    std_symbol(\"test\", TEST);\n    std_symbol(\"testeq\", TESTEQ);\n    std_symbol(\"testge\", TESTGE);\n    std_symbol(\"testgt\", TESTGT);\n    std_symbol(\"testle\", TESTLE);\n    std_symbol(\"testlt\", TESTLT);\n    std_symbol(\"transpose\", TRANSPOSE);\n    std_symbol(\"unit\", UNIT);\n    std_symbol(\"zero\", ZERO);\n    std_symbol(\"nil\", NIL);\n    std_symbol(\"autoexpand\", AUTOEXPAND);\n    std_symbol(\"bake\", BAKE);\n    std_symbol(\"assumeRealVariables\", ASSUME_REAL_VARIABLES);\n    std_symbol(\"last\", LAST);\n    std_symbol(\"lastprint\", LAST_PRINT);\n    std_symbol(\"last2dasciiprint\", LAST_2DASCII_PRINT);\n    std_symbol(\"lastfullprint\", LAST_FULL_PRINT);\n    std_symbol(\"lastlatexprint\", LAST_LATEX_PRINT);\n    std_symbol(\"lastlistprint\", LAST_LIST_PRINT);\n    std_symbol(\"lastplainprint\", LAST_PLAIN_PRINT);\n    std_symbol(\"trace\", TRACE);\n    std_symbol(\"forceFixedPrintout\", FORCE_FIXED_PRINTOUT);\n    std_symbol(\"maxFixedPrintoutDigits\", MAX_FIXED_PRINTOUT_DIGITS);\n    std_symbol(\"~\", YYE); // tilde so sort puts it after other symbols\n    std_symbol(\"$DRAWX\", DRAWX); // special purpose internal symbols\n    std_symbol(\"$METAA\", METAA);\n    std_symbol(\"$METAB\", METAB);\n    std_symbol(\"$METAX\", METAX);\n    std_symbol(\"$SECRETX\", SECRETX);\n    std_symbol(\"version\", VERSION);\n    std_symbol(\"pi\", PI);\n    std_symbol(\"a\", SYMBOL_A);\n    std_symbol(\"b\", SYMBOL_B);\n    std_symbol(\"c\", SYMBOL_C);\n    std_symbol(\"d\", SYMBOL_D);\n    std_symbol(\"i\", SYMBOL_I);\n    std_symbol(\"j\", SYMBOL_J);\n    std_symbol(\"n\", SYMBOL_N);\n    std_symbol(\"r\", SYMBOL_R);\n    std_symbol(\"s\", SYMBOL_S);\n    std_symbol(\"t\", SYMBOL_T);\n    std_symbol(\"x\", SYMBOL_X);\n    std_symbol(\"y\", SYMBOL_Y);\n    std_symbol(\"z\", SYMBOL_Z);\n    std_symbol(\"I\", SYMBOL_IDENTITY_MATRIX);\n    std_symbol(\"a_\", SYMBOL_A_UNDERSCORE);\n    std_symbol(\"b_\", SYMBOL_B_UNDERSCORE);\n    std_symbol(\"x_\", SYMBOL_X_UNDERSCORE);\n    std_symbol(\"$C1\", C1);\n    std_symbol(\"$C2\", C2);\n    std_symbol(\"$C3\", C3);\n    std_symbol(\"$C4\", C4);\n    std_symbol(\"$C5\", C5);\n    std_symbol(\"$C6\", C6);\n    defineSomeHandyConstants();\n    // don't add all these functions to the\n    // symbolsDependencies, clone the original\n    originalCodeGen = codeGen;\n    codeGen = false;\n    for (defn_i = l1 = 0, ref2 = defn_str.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); defn_i = 0 <= ref2 ? ++l1 : --l1) {\n      definitionOfInterest = defn_str[defn_i];\n      scan(definitionOfInterest);\n      if (DEBUG) {\n        console.log(\"... evaling \" + definitionOfInterest);\n        console.log(\"top of stack:\");\n        console.log(print_list(stack[tos - 1]));\n      }\n      Eval();\n      pop();\n    }\n    // restore the symbol dependencies as they were before.\n    return codeGen = originalCodeGen;\n  };\n\n  defineSomeHandyConstants = function() {\n    zero = new_integer(0);\n    one = new_integer(1);\n    push_double(1.0);\n    one_as_double = pop();\n    // i is the square root of -1 i.e. -1 ^ 1/2\n    push_symbol(POWER);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_integer(-1);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    push_rational(1, 2);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    list(3);\n    if (DEBUG) {\n      console.log(print_list(stack[tos - 1]));\n    }\n    return imaginaryunit = pop(); // must be untagged in gc\n  };\n\n  // Bignum compare\n\n  //  returns\n\n  //  -1    a < b\n\n  //  0    a = b\n\n  //  1    a > b\n  mcmp = function(a, b) {\n    return a.compare(b);\n  };\n\n  // a is a bigint, n is a normal int\n  mcmpint = function(a, n) {\n    var b, t;\n    b = bigInt(n);\n    t = mcmp(a, b);\n    return t;\n  };\n\n  strcmp = function(str1, str2) {\n    if (str1 === str2) {\n      return 0;\n    } else if (str1 > str2) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  doubleToReasonableString = function(d) {\n    var maxFixedPrintoutDigits, stringRepresentation;\n    // when generating code, print out\n    // the standard JS Number printout\n    if (codeGen) {\n      return \"\" + d;\n    }\n    if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {\n      stringRepresentation = \"\" + d;\n      // manipulate the string so that it can be parsed by\n      // Algebrite (something like 1.23e-123 wouldn't cut it because\n      // that would be parsed as 1.23*e - 123)\n      if (printMode === PRINTMODE_LATEX) {\n        // 1.0\\mathrm{e}{-10} looks much better than the plain 1.0e-10\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"\\\\mathrm{e}{$1}\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0\\mathrm{e}{-10}\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0\\\\mathrm{e}{$2}\");\n        }\n      } else {\n        if (/\\d*\\.\\d*e.*/gm.test(stringRepresentation)) {\n          stringRepresentation = stringRepresentation.replace(/e(.*)/gm, \"*10^($1)\");\n        } else {\n          // if there is no dot in the mantissa, add it so we see it's\n          // a double and not a perfect number\n          // e.g. 1e-10 becomes 1.0e-10\n          stringRepresentation = stringRepresentation.replace(/(\\d+)e(.*)/gm, \"$1.0*10^($2)\");\n        }\n      }\n    } else {\n      push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));\n      maxFixedPrintoutDigits = pop_integer();\n      //console.log \"maxFixedPrintoutDigits: \" + maxFixedPrintoutDigits\n      //console.log \"type: \" + typeof(maxFixedPrintoutDigits)\n      //console.log \"toFixed: \" + d.toFixed(maxFixedPrintoutDigits)\n      stringRepresentation = \"\" + d.toFixed(maxFixedPrintoutDigits);\n      // remove any trailing zeroes after the dot\n      // see https://stackoverflow.com/questions/26299160/using-regex-how-do-i-remove-the-trailing-zeros-from-a-decimal-number\n      stringRepresentation = stringRepresentation.replace(/(\\.\\d*?[1-9])0+$/gm, \"$1\");\n      // in case there are only zeroes after the dot, removes the dot too\n      stringRepresentation = stringRepresentation.replace(/\\.0+$/gm, \"\");\n      // we actually want to give a hint to user that\n      // it's a double, so add a trailing \".0\" if there\n      // is no decimal point\n      if (stringRepresentation.indexOf(\".\") === -1) {\n        stringRepresentation += \".0\";\n      }\n      if (parseFloat(stringRepresentation) !== d) {\n        stringRepresentation = d.toFixed(maxFixedPrintoutDigits) + \"...\";\n      }\n    }\n    return stringRepresentation;\n  };\n\n  // does nothing\n  clear_term = function() {};\n\n  // s is a string here anyways\n  isspace = function(s) {\n    if (s == null) {\n      return false;\n    }\n    return s === ' ' || s === '\\t' || s === '\\n' || s === '\\v' || s === '\\f' || s === '\\r';\n  };\n\n  isdigit = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return /^\\d+$/.test(str);\n  };\n\n  isalpha = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z]/) === -1;\n  };\n\n  isalphaOrUnderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    //Check for non-alphabetic characters and space\n    return str.search(/[^A-Za-z_]/) === -1;\n  };\n\n  isunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return str.search(/_/) === -1;\n  };\n\n  isalnumorunderscore = function(str) {\n    if (str == null) {\n      return false;\n    }\n    return isalphaOrUnderscore(str) || isdigit(str);\n  };\n\n  count = function(p) {\n    var n;\n    if (iscons(p)) {\n      n = 0;\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  // this probably works out to be\n  // more general than just counting symbols, it can\n  // probably count instances of anything you pass as\n  // first argument but didn't try it.\n  countOccurrencesOfSymbol = function(needle, p) {\n    var n;\n    n = 0;\n    if (iscons(p)) {\n      while (iscons(p)) {\n        n += countOccurrencesOfSymbol(needle, car(p));\n        p = cdr(p);\n      }\n    } else {\n      if (equal(needle, p)) {\n        n = 1;\n      }\n    }\n    return n;\n  };\n\n  // returns the total number of elements\n  // in an expression\n  countsize = function(p) {\n    var i, l1, n, ref2;\n    n = 0;\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        n += p.tensor.elem[i];\n      }\n    } else if (iscons(p)) {\n      while (iscons(p)) {\n        n += count(car(p)) + 1;\n        p = cdr(p);\n      }\n    } else {\n      n = 1;\n    }\n    return n;\n  };\n\n  //jmp_buf stop_return, draw_stop_return\n\n  // s is a string here\n  stop = function(s) {\n    var message;\n    //if (draw_flag == 2)\n    //  longjmp(draw_stop_return, 1)\n    //else\n    errorMessage += \"Stop: \";\n    errorMessage += s;\n    //debugger\n    message = errorMessage;\n    errorMessage = '';\n    moveTos(0);\n    throw new Error(message);\n  };\n\n  \n  //longjmp(stop_return, 1)\n\n  // Figuring out dependencies is key to automatically\n  // generating a method signature when generating JS code\n  // from algebrite scripts.\n  // This is important because the user can keep using normal Algebrite\n  // scripting without special notations.\n  // Basically the process consists of figuring out\n  // the \"ground variables\" that are needed to compute each variable.\n  // Now there are two ways of doing this:\n  //   * at parse time\n  //   * after running the scripts\n  // Doing it at parse time means that we can't track simplifications\n  // canceling-out some variables for example. But on the other side\n  // it's very quick and the user can somehow see what the signature is\n  // going to look like (assuming tha code is rather simple), or anyways\n  // is going to easily make sense of the generated signature.\n  // Doing it after execution on the other hand would allow us to see\n  // if some variable cancel-out. But if variables cancel out then\n  // they might do so according to some run-time behaviour that the user\n  // might struggle to keep track of.\n  // So the effort for the user to make sense of the signature in the first case\n  // is similar to the effort of keeping tab of types in a typed language.\n  // While in the second case the effort is similar to running the\n  // code and simplifications in her head.\n\n  // If we just want to compute the dependencies, we don't need to do\n  // anything costly, we don't \"run\" the code and we don't simplify\n  // the code. Just finding the plain dependencies\n  // TODO change the name of this function, as it doesn't just find the\n  // dependencies. It also runs it and generates the JS code.\n  findDependenciesInScript = function(stringToBeParsed, dontGenerateCode) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t1, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;\n    if (DEBUG) {\n      console.log(\"stringToBeParsed: \" + stringToBeParsed);\n    }\n    timeStartFromAlgebra = new Date().getTime();\n    inited = true;\n    codeGen = true;\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    symbolsInExpressionsWithoutAssignments = [];\n    patternHasBeenFound = false;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    n = 0;\n    // we are going to store the dependencies _of the block as a whole_\n    // so all affected variables in the whole block are lumped\n    // together, and same for the variable that affect those, we\n    // lump them all together.\n    dependencyInfo = {\n      affectsVariables: [],\n      affectedBy: []\n    };\n    stringToBeRun = stringToBeParsed;\n    // parse the input. This collects the\n    // dependency information\n    while (1) {\n      try {\n        errorMessage = \"\";\n        check_stack();\n        if (DEBUG) {\n          console.log(\"findDependenciesInScript: scanning\");\n        }\n        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));\n        if (DEBUG) {\n          console.log(\"scanned\");\n        }\n        pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      indexOfPartRemainingToBeParsed += n;\n    }\n    testableString = \"\";\n    // print out all local dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"all local dependencies ----------------\");\n    }\n    testableString += \"All local dependencies: \";\n    for (key in symbolsDependencies) {\n      value = symbolsDependencies[key];\n      if (DEBUG) {\n        console.log(\"variable \" + key + \" depends on: \");\n      }\n      dependencyInfo.affectsVariables.push(key);\n      testableString += \" variable \" + key + \" depends on: \";\n      for (l1 = 0, len = value.length; l1 < len; l1++) {\n        i = value[l1];\n        if (DEBUG) {\n          console.log(\"    \" + i);\n        }\n        if (i[0] !== \"'\") {\n          dependencyInfo.affectedBy.push(i);\n        }\n        testableString += i + \", \";\n      }\n      testableString += \"; \";\n    }\n    testableString += \". \";\n    // print out the symbols with re-assignments:\n    if (DEBUG) {\n      console.log(\"Symbols with reassignments ----------------\");\n    }\n    testableString += \"Symbols with reassignments: \";\n    for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {\n      key = symbolsHavingReassignments[m1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // print out the symbols that appear in expressions without assignments\n    if (DEBUG) {\n      console.log(\"Symbols in expressions without assignments ----------------\");\n    }\n    testableString += \"Symbols in expressions without assignments: \";\n    for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {\n      key = symbolsInExpressionsWithoutAssignments[n1];\n      if (dependencyInfo.affectedBy.indexOf(key) === -1) {\n        dependencyInfo.affectedBy.push(key);\n        testableString += key + \", \";\n      }\n    }\n    testableString += \". \";\n    // ALL Algebrite code is affected by any pattern changing\n    dependencyInfo.affectedBy.push(\"PATTERN_DEPENDENCY\");\n    if (patternHasBeenFound) {\n      dependencyInfo.affectsVariables.push(\"PATTERN_DEPENDENCY\");\n      testableString += \" - PATTERN_DEPENDENCY inserted - \";\n    }\n    // print out all global dependencies as collected by this\n    // parsing pass\n    if (DEBUG) {\n      console.log(\"All dependencies recursively ----------------\");\n    }\n    testableString += \"All dependencies recursively: \";\n    scriptEvaluation = [\"\", \"\"];\n    generatedCode = \"\";\n    readableSummaryOfGeneratedCode = \"\";\n    if (errorMessage === \"\" && !dontGenerateCode) {\n      try {\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n        scriptEvaluation = run(stringToBeParsed, true);\n        allReturnedPlainStrings = \"\";\n        allReturnedLatexStrings = \"\";\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        errorMessage = error + \"\";\n        //debugger\n        init();\n      }\n      if (errorMessage === \"\") {\n        for (key in symbolsDependencies) {\n          codeGen = true;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          codeGen = false;\n          if (DEBUG) {\n            console.log(\"  variable \" + key + \" depends on: \");\n          }\n          testableString += \" variable \" + key + \" depends on: \";\n          recursedDependencies = [];\n          variablesWithCycles = [];\n          cyclesDescriptions = [];\n          recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);\n          for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {\n            i = variablesWithCycles[o1];\n            if (DEBUG) {\n              console.log(\"    --> cycle through \" + i);\n            }\n          }\n          for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {\n            i = recursedDependencies[q1];\n            if (DEBUG) {\n              console.log(\"    \" + i);\n            }\n            testableString += i + \", \";\n          }\n          testableString += \"; \";\n          for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {\n            i = cyclesDescriptions[r1];\n            testableString += \" \" + i + \", \";\n          }\n          if (DEBUG) {\n            console.log(\"  code generation:\" + key + \" is: \" + get_binding(usr_symbol(key)).toString());\n          }\n          // we really want to make an extra effort\n          // to generate simplified code, so\n          // run a \"simplify\" on the content of each\n          // variable that we are generating code for.\n          // Note that the variable\n          // will still point to un-simplified structures,\n          // we only simplify the generated code.\n          push(get_binding(usr_symbol(key)));\n          // Since we go and simplify all variables we meet,\n          // we have to replace each variable passed as a parameter\n          // with something entirely new, so that there is no chance\n          // that it might evoke previous values in the external scope\n          // as in this case:\n          //  a = 2\n          //  f(a) = a+1+b\n          // we don't want 'a' in the body of f to be simplified to 2\n          // There are two cases: 1) the variable actually was already in\n          // the symbol table, in which case there is going to be this new\n          // one prepended with AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE, and\n          // we'll have to remove up this variable later.\n          // OR 2) the variable wasn't already in the symbol table, in which\n          // case we directly create this one, which means that we'll have\n          // to rename it later to the correct name without the prepended\n          // part.\n          replacementsFrom = [];\n          replacementsTo = [];\n          for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {\n            eachDependency = recursedDependencies[s1];\n            if (eachDependency[0] === \"'\") {\n              deQuotedDep = eachDependency.substring(1);\n              originalUserSymbol = usr_symbol(deQuotedDep);\n              newUserSymbol = usr_symbol(\"AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE\" + deQuotedDep);\n              replacementsFrom.push(originalUserSymbol);\n              replacementsTo.push(newUserSymbol);\n              push(originalUserSymbol);\n              push(newUserSymbol);\n              subst();\n              if (DEBUG) {\n                console.log(\"after substitution: \" + stack[tos - 1]);\n              }\n            }\n          }\n          try {\n            simplifyForCodeGeneration();\n          } catch (error1) {\n            error = error1;\n            if (PRINTOUTRESULT) {\n              console.log(error);\n            }\n            errorMessage = error + \"\";\n            //debugger\n            init();\n          }\n          for (indexOfEachReplacement = t1 = 0, ref2 = replacementsFrom.length; (0 <= ref2 ? t1 < ref2 : t1 > ref2); indexOfEachReplacement = 0 <= ref2 ? ++t1 : --t1) {\n            //console.log \"replacing back \" + replacementsTo[indexOfEachReplacement] + \" into: \" + replacementsFrom[indexOfEachReplacement]\n            push(replacementsTo[indexOfEachReplacement]);\n            push(replacementsFrom[indexOfEachReplacement]);\n            subst();\n          }\n          clearRenamedVariablesToAvoidBindingToExternalScope();\n          if (errorMessage === \"\") {\n            toBePrinted = pop();\n            // we have to get all the variables used on the right side\n            // here. I.e. to print the arguments it's better to look at the\n            // actual method body after simplification.\n            userVariablesMentioned = [];\n            collectUserSymbols(toBePrinted, userVariablesMentioned);\n            allReturnedPlainStrings = \"\";\n            allReturnedLatexStrings = \"\";\n            codeGen = true;\n            generatedBody = toBePrinted.toString();\n            codeGen = false;\n            origPrintMode = printMode;\n            printMode = PRINTMODE_LATEX;\n            bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();\n            printMode = origPrintMode;\n            if (variablesWithCycles.indexOf(key) !== -1) {\n              generatedCode += \"// \" + key + \" is part of a cyclic dependency, no code generated.\";\n              readableSummaryOfGeneratedCode += \"#\" + key + \" is part of a cyclic dependency, no code generated.\";\n            } else {\n              /*\n               * using this paragraph instead of the following one\n               * creates methods signatures that\n               * are slightly less efficient\n               * i.e. variables compare even if they are\n               * simplified away.\n               * In theory these signatures are more stable, but\n               * in practice signatures vary quite a bit anyways\n               * depending on previous assignments for example,\n               * so it's unclear whether going for stability\n               * is sensible at all..\n              if recursedDependencies.length != 0\n                parameters = \"(\"\n                for i in recursedDependencies\n                  if i.indexOf(\"'\") != 0\n                    parameters += i + \", \"\n                  else\n                    if recursedDependencies.indexOf(i.substring(1)) == -1\n                      parameters += i.substring(1) + \", \"\n               */\n              // remove all native functions from the\n              // parameters as well.\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x + \"\") === -1;\n              });\n              // remove the variable that are not in the dependency list\n              // i.e. only allow the variables that are in the dependency list\n              userVariablesMentioned = userVariablesMentioned.filter(function(x) {\n                return recursedDependencies.indexOf(x + \"\") !== -1 || recursedDependencies.indexOf(\"\\'\" + x + \"\") !== -1;\n              });\n              if (userVariablesMentioned.length !== 0) {\n                parameters = \"(\";\n                for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {\n                  i = userVariablesMentioned[u1];\n                  if (i.printname !== key) {\n                    parameters += i.printname + \", \";\n                  }\n                }\n                // eliminate the last \", \" for printout clarity\n                parameters = parameters.replace(/, $/gm, \"\");\n                parameters += \")\";\n                generatedCode += key + \" = function \" + parameters + \" { return ( \" + generatedBody + \" ); }\";\n                readableSummaryOfGeneratedCode += key + parameters + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              } else {\n                generatedCode += key + \" = \" + generatedBody + \";\";\n                readableSummaryOfGeneratedCode += key + \" = \" + bodyForReadableSummaryOfGeneratedCode;\n              }\n            }\n            generatedCode += \"\\n\";\n            readableSummaryOfGeneratedCode += \"\\n\";\n            if (DEBUG) {\n              console.log(\"    \" + generatedCode);\n            }\n          }\n        }\n      }\n    }\n    // eliminate the last new line\n    generatedCode = generatedCode.replace(/\\n$/gm, \"\");\n    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\\n$/gm, \"\");\n    // cleanup\n    symbolsDependencies = {};\n    symbolsHavingReassignments = [];\n    patternHasBeenFound = false;\n    symbolsInExpressionsWithoutAssignments = [];\n    if (DEBUG) {\n      console.log(\"testable string: \" + testableString);\n    }\n    if (TIMING_DEBUGS) {\n      console.log(\"findDependenciesInScript time for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];\n  };\n\n  recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {\n    var cyclesDescription, i, k, l1, len, len1, m1, ref2;\n    variablesAlreadyFleshedOut.push(variableToBeChecked);\n    // recursive dependencies can only be descended if the variable is not bound to a parameter\n    if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {\n      if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf(\"'\" + variableToBeChecked) !== -1) {\n        if (DEBUG) {\n          console.log(\"can't keep following the chain of \" + variableToBeChecked + \" because it's actually a variable bound to a parameter\");\n        }\n        if (arrayWhereDependenciesWillBeAdded.indexOf(\"'\" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n          arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n        }\n        return arrayWhereDependenciesWillBeAdded;\n      }\n    }\n    chainBeingChecked.push(variableToBeChecked);\n    if (symbolsDependencies[variableToBeChecked] == null) {\n      // end case: the passed variable has no dependencies\n      // so there is nothing else to do\n      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {\n        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);\n      }\n      return arrayWhereDependenciesWillBeAdded;\n    } else {\n      ref2 = symbolsDependencies[variableToBeChecked];\n      // recursion case: we have to dig deeper\n      for (l1 = 0, len = ref2.length; l1 < len; l1++) {\n        i = ref2[l1];\n        // check that there is no recursion in dependencies\n        // we do that by keeping a list of variables that\n        // have already been \"fleshed-out\". If we encounter\n        // any of those \"fleshed-out\" variables while\n        // fleshing out, then there is a cycle \n        if (chainBeingChecked.indexOf(i) !== -1) {\n          if (DEBUG) {\n            console.log(\"  found cycle:\");\n          }\n          cyclesDescription = \"\";\n          for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {\n            k = chainBeingChecked[m1];\n            if (variablesWithCycles.indexOf(k) === -1) {\n              variablesWithCycles.push(k);\n            }\n            if (DEBUG) {\n              console.log(k + \" --> \");\n            }\n            cyclesDescription += k + \" --> \";\n          }\n          if (DEBUG) {\n            console.log(\" ... then \" + i + \" again\");\n          }\n          cyclesDescription += \" ... then \" + i + \" again\";\n          cyclesDescriptions.push(cyclesDescription);\n          //if DEBUG then console.log \"    --> cycle through \" + i\n          // we want to flesh-out i but it's already been\n          // fleshed-out, just add it to the variables\n          // with cycles and move on\n          // todo refactor this, there are two copies of these two lines\n          if (variablesWithCycles.indexOf(i) === -1) {\n            variablesWithCycles.push(i);\n          }\n        } else {\n          // flesh-out i recursively\n          recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);\n          chainBeingChecked.pop();\n        }\n      }\n      //variablesAlreadyFleshedOut.pop()\n      return arrayWhereDependenciesWillBeAdded;\n    }\n  };\n\n  // parses and runs one statement/expression at a time\n  inited = false;\n\n  latexErrorSign = \"\\\\rlap{\\\\large\\\\color{red}\\\\bigtriangleup}{\\\\ \\\\ \\\\tiny\\\\color{red}!}\";\n\n  turnErrorMessageToLatex = function(theErrorMessage) {\n    theErrorMessage = theErrorMessage.replace(/\\n/g, \"\");\n    theErrorMessage = theErrorMessage.replace(/_/g, \"} \\\\_ \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), 'g'), \"}{}^{T}\\\\text{\");\n    theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), 'g'), \"}\\\\cdot \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"Stop:\", \"}  \\\\quad \\\\text{Stop:\");\n    theErrorMessage = theErrorMessage.replace(\"->\", \"}  \\\\rightarrow \\\\text{\");\n    theErrorMessage = theErrorMessage.replace(\"?\", \"}\\\\enspace \" + latexErrorSign + \" \\\\enspace  \\\\text{\");\n    theErrorMessage = \"$$\\\\text{\" + theErrorMessage.replace(/\\n/g, \"\") + \"}$$\";\n    //console.log \"theErrorMessage: \" + theErrorMessage\n    return theErrorMessage;\n  };\n\n  // there are around a dozen different unicodes that\n  // represent some sort of middle dot, let's catch the most\n  // common and turn them into what we can process\n  normaliseDots = function(stringToNormalise) {\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), 'g'), String.fromCharCode(dotprod_unicode));\n    stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), 'g'), String.fromCharCode(dotprod_unicode));\n    return stringToNormalise;\n  };\n\n  TIMING_DEBUGS = false;\n\n  run = function(stringToBeRun, generateLatex = false) {\n    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i, indexOfPartRemainingToBeParsed, n, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;\n    timeStart = new Date().getTime();\n    //stringToBeRun = stringToBeRun + \"\\n\"\n    stringToBeRun = normaliseDots(stringToBeRun);\n    //console.log \"run running: \" + stringToBeRun\n    if (stringToBeRun === \"selftest\") {\n      selftest();\n      return;\n    }\n    if (!inited) {\n      inited = true;\n      init();\n    }\n    i = 0;\n    n = 0;\n    indexOfPartRemainingToBeParsed = 0;\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    while (1) {\n      try {\n        // while we can keep scanning commands out of the\n        // passed input AND we can execute them...\n        errorMessage = \"\";\n        check_stack();\n        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));\n        p1 = pop();\n        check_stack();\n      } catch (error1) {\n        error = error1;\n        if (PRINTOUTRESULT) {\n          console.log(error);\n        }\n        //debugger\n        allReturnedPlainStrings += error.message;\n        if (generateLatex) {\n          //debugger\n          theErrorMessage = turnErrorMessageToLatex(error.message);\n          allReturnedLatexStrings += theErrorMessage;\n        }\n        reset_after_error();\n        break;\n      }\n      if (n === 0) {\n        break;\n      }\n      // if debug mode then print the source text\n\n      //if (equaln(get_binding(symbol(TRACE)), 1)) {\n      //  for (i = 0 i < n i++)\n      //    if (s[i] != '\\r')\n      //      printchar(s[i])\n      //  if (s[n - 1] != '\\n') # n is not zero, see above\n      //    printchar('\\n')\n      //}\n      indexOfPartRemainingToBeParsed += n;\n      push(p1);\n      //debugger\n      errorWhileExecution = false;\n      try {\n        stringsEmittedByUserPrintouts = \"\";\n        top_level_eval();\n        //console.log \"emitted string after top_level_eval(): >\" + stringsEmittedByUserPrintouts + \"<\"\n        //console.log \"allReturnedPlainStrings string after top_level_eval(): >\" + allReturnedPlainStrings + \"<\"\n        p2 = pop();\n        check_stack();\n        if (isstr(p2)) {\n          if (DEBUG) {\n            console.log(p2.str);\n          }\n          if (DEBUG) {\n            console.log(\"\\n\");\n          }\n        }\n        // if the return value is nil there isn't much point\n        // in adding \"nil\" to the printout\n        if (p2 === symbol(NIL)) {\n          //collectedPlainResult = stringsEmittedByUserPrintouts\n          collectedPlainResult = stringsEmittedByUserPrintouts;\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + stringsEmittedByUserPrintouts + \"$$\";\n          }\n        } else {\n          //console.log \"emitted string before collectPlainStringFromReturnValue: >\" + stringsEmittedByUserPrintouts + \"<\"\n          //console.log \"allReturnedPlainStrings string before collectPlainStringFromReturnValue: >\" + allReturnedPlainStrings + \"<\"\n          collectedPlainResult = print_expr(p2);\n          collectedPlainResult += \"\\n\";\n          //console.log \"collectedPlainResult: >\" + collectedPlainResult + \"<\"\n          if (generateLatex) {\n            collectedLatexResult = \"$$\" + collectLatexStringFromReturnValue(p2) + \"$$\";\n            if (DEBUG) {\n              console.log(\"collectedLatexResult: \" + collectedLatexResult);\n            }\n          }\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n        }\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"printline\");\n          }\n          if (DEBUG) {\n            console.log(collectedPlainResult);\n          }\n        }\n        //alert collectedPlainResult\n        if (PRINTOUTRESULT) {\n          if (DEBUG) {\n            console.log(\"display:\");\n          }\n          print2dascii(p2);\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += \"\\n\";\n        }\n      } catch (error1) {\n        error = error1;\n        errorWhileExecution = true;\n        collectedPlainResult = error.message;\n        if (generateLatex) {\n          collectedLatexResult = turnErrorMessageToLatex(error.message);\n        }\n        if (PRINTOUTRESULT) {\n          console.log(collectedPlainResult);\n        }\n        allReturnedPlainStrings += collectedPlainResult;\n        if (collectedPlainResult !== \"\") {\n          allReturnedPlainStrings += \"\\n\";\n        }\n        if (generateLatex) {\n          allReturnedLatexStrings += collectedLatexResult;\n          allReturnedLatexStrings += \"\\n\";\n        }\n        init();\n      }\n    }\n    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === \"\\n\") {\n      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);\n    }\n    if (generateLatex) {\n      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === \"\\n\") {\n        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);\n      }\n    }\n    if (generateLatex) {\n      if (DEBUG) {\n        console.log(\"allReturnedLatexStrings: \" + allReturnedLatexStrings);\n      }\n      stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];\n    } else {\n      stringToBeReturned = allReturnedPlainStrings;\n    }\n    if (TIMING_DEBUGS) {\n      timingDebugWrite = \"run time on: \" + stringToBeRun + \" : \" + (new Date().getTime() - timeStart) + \"ms\";\n      console.log(timingDebugWrite);\n    }\n    allReturnedPlainStrings = \"\";\n    allReturnedLatexStrings = \"\";\n    return stringToBeReturned;\n  };\n\n  check_stack = function() {\n    if (tos !== 0) {\n      debugger;\n      stop(\"stack error\");\n    }\n    if (frame !== TOS) {\n      debugger;\n      stop(\"frame error\");\n    }\n    if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {\n      debugger;\n      stop(\"symbols evaluation still ongoing?\");\n    }\n    if (evaluatingAsFloats !== 0) {\n      debugger;\n      stop(\"numeric evaluation still ongoing?\");\n    }\n    if (evaluatingPolar !== 0) {\n      debugger;\n      return stop(\"evaluation of polar still ongoing?\");\n    }\n  };\n\n  // cannot reference symbols yet\n\n  // returns nil on stack if no result to print\n  top_level_eval = function() {\n    var evalledArgument, originalArgument, shouldAutoexpand;\n    if (DEBUG) {\n      console.log(\"#### top level eval\");\n    }\n    trigmode = 0;\n    shouldAutoexpand = symbol(AUTOEXPAND);\n    if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {\n      expanding = 0;\n    } else {\n      expanding = 1;\n    }\n    originalArgument = top();\n    Eval();\n    evalledArgument = top();\n    // \"draw\", \"for\" and \"setq\" return \"nil\", there is no result to print\n    if (evalledArgument === symbol(NIL)) {\n      return;\n    }\n    // update \"last\" to contain the last result\n    set_binding(symbol(LAST), evalledArgument);\n    if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {\n      bake();\n      evalledArgument = top();\n    }\n    // If user asked explicitly asked to evaluate \"i\" or \"j\" and\n    // they represent the imaginary unit (-1)^(1/2), then \n    // show (-1)^(1/2).\n    if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {\n\n    // In all other cases, replace all instances of (-1)^(1/2) in the result\n    // with the symbol \"i\" or \"j\" depending on which one\n    // represents the imaginary unit\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_J);\n      return subst();\n    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {\n      push(imaginaryunit);\n      push_symbol(SYMBOL_I);\n      return subst();\n    }\n  };\n\n  check_esc_flag = function() {\n    if (esc_flag) {\n      return stop(\"esc key\");\n    }\n  };\n\n  // this is called when the whole notebook is re-run\n  // so we get the chance of clearing the whole state from\n  // scratch.\n  // In practice, the state we need to clear that persists\n  // across blocks are only the patterns, so\n  // just eject those.\n  clearAlgebraEnvironment = function() {\n    //console.log \"CLEARING clearAlgebraEnvironment =============================================================\"\n    return do_clearall();\n  };\n\n  computeDependenciesFromAlgebra = function(codeFromAlgebraBlock) {\n    var i, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra!!!\");\n    }\n    // return findDependenciesInScript(codeFromAlgebraBlock, true)[6]\n\n    // TODO this part below is duplicated from computeResultsAndJavaScriptFromAlgebra\n    //      ...should refactor.\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    if (DEBUG) {\n      console.log(\"computeDependenciesFromAlgebra: patterns in the list --------------- \");\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    called_from_Algebra_block = false;\n    return findDependenciesInScript(codeFromAlgebraBlock, true)[6];\n  };\n\n  computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {\n    var code, dependencyInfo, i, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;\n    originalcodeFromAlgebraBlock = codeFromAlgebraBlock;\n    keepState = true;\n    called_from_Algebra_block = true;\n    timeStartFromAlgebra = new Date().getTime();\n    if (TIMING_DEBUGS) {\n      console.log(\" --------- computeResultsAndJavaScriptFromAlgebra input: \" + codeFromAlgebraBlock + \" at: \" + (new Date()));\n    }\n    // we start \"clean\" each time:\n    // clear all the symbols and then re-define\n    // the \"starting\" symbols.\n\n    //console.log \"codeFromAlgebraBlock: \" + codeFromAlgebraBlock\n    codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);\n    stringToBeRun = codeFromAlgebraBlock;\n    if (DEBUG) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- \");\n      for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {\n        i = userSimplificationsInListForm[l1];\n        console.log(car(i) + \",\" + cdr(i) + \")\");\n      }\n      console.log(\"...end of list --------------- \");\n    }\n    if (!keepState) {\n      userSimplificationsInListForm = [];\n      userSimplificationsInProgramForm = \"\";\n      for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {\n        i = userSimplificationsInListForm[m1];\n        //console.log \"silentpattern(\" + car(i) + \",\"+cdr(i)+\")\"\n        userSimplificationsInProgramForm += \"silentpattern(\" + car(i) + \",\" + car(cdr(i)) + \",\" + car(cdr(cdr(i))) + \")\\n\";\n      }\n      do_clearall();\n      codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;\n      if (DEBUG) {\n        console.log(\"codeFromAlgebraBlock including patterns: \" + codeFromAlgebraBlock);\n      }\n    }\n    //debugger\n    [testableStringIsIgnoredHere, result, code, readableSummaryOfCode, latexResult, errorMessage, dependencyInfo] = findDependenciesInScript(codeFromAlgebraBlock);\n    called_from_Algebra_block = false;\n    if (readableSummaryOfCode !== \"\" || errorMessage !== \"\") {\n      result += \"\\n\" + readableSummaryOfCode;\n      if (errorMessage !== \"\") {\n        result += \"\\n\" + errorMessage;\n      }\n      result = result.replace(/\\n/g, \"\\n\\n\");\n      latexResult += \"\\n\" + \"$$\" + readableSummaryOfCode + \"$$\";\n      if (errorMessage !== \"\") {\n        latexResult += turnErrorMessageToLatex(errorMessage);\n      }\n      latexResult = latexResult.replace(/\\n/g, \"\\n\\n\");\n    }\n    // remove empty results altogether from latex output, which happens\n    // for example for assignments to variables or\n    // functions definitions\n    latexResult = latexResult.replace(/\\n*/, \"\");\n    latexResult = latexResult.replace(/\\$\\$\\$\\$\\n*/g, \"\");\n    code = code.replace(/Math\\./g, \"\");\n    code = code.replace(/\\n/g, \"\\n\\n\");\n    //console.log \"code: \" + code\n    //console.log \"result: \" + result\n    //console.log \"latexResult: \" + latexResult\n    if (TIMING_DEBUGS) {\n      console.log(\"computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: \" + stringToBeRun + \" : \" + ((new Date().getTime()) - timeStartFromAlgebra) + \"ms\");\n    }\n    return {\n      //code: \"// no code generated yet\\n//try again later\"\n      //code: \"console.log('some passed code is run'); window.something = 1;\"\n      code: code,\n      // TODO temporarily pass latex in place of standard result too\n      result: latexResult,\n      latexResult: latexResult,\n      dependencyInfo: dependencyInfo\n    };\n  };\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).run = run;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;\n\n  (typeof exports !== \"undefined\" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;\n\n  //   _______\n  //  |  | <- stack\n  //  |  |\n  //  |_______|\n  //  |  | <- stack + tos\n  //  |  |\n  //  |  |\n  //  |_______|\n  //  |  | <- frame\n  //  |_______|\n  //      <- stack + TOS\n\n  //  The stack grows from low memory towards high memory. This is so that\n  //  multiple expressions can be pushed on the stack and then accessed as an\n  //  array.\n\n  //  The frame area holds local variables and grows from high memory towards\n  //  low memory. The frame area makes local variables visible to the garbage\n  //  collector.\n  tos = 0;\n\n  // p is a U\n  nil_symbols = 0;\n\n  push = function(p) {\n    if (p == null) {\n      debugger;\n    }\n    if (p.isZero != null) {\n      debugger;\n    }\n    //console.log \"pushing \"\n    //console.log print_list(p)\n    if (p === symbol(NIL)) {\n      nil_symbols++;\n      if (DEBUG) {\n        console.log(\"pushing symbol(NIL) #\" + nil_symbols);\n      }\n    }\n    //if nil_symbols == 111\n    //  debugger\n    if (tos >= frame) {\n      stop(\"stack overflow\");\n    }\n    return stack[tos++] = p;\n  };\n\n  // returns a U\n  moveTos = function(stackPos) {\n    if (tos <= stackPos) {\n      // we are moving the stack pointer\n      // \"up\" the stack (as if we were doing a push)\n      tos = stackPos;\n      return;\n    }\n    // we are moving the stack pointer\n    // \"down\" the stack i.e. as if we were\n    // doing a pop, we can zero-\n    // out all the elements that we pass\n    // so we can reclaim the memory\n    while (tos > stackPos) {\n      stack[tos] = null;\n      tos--;\n    }\n  };\n\n  top = function() {\n    return stack[tos - 1];\n  };\n\n  pop = function() {\n    var elementToBeReturned;\n    //popsNum++\n    //console.log \"pop #\" + popsNum\n    if (tos === 0) {\n      debugger;\n      stop(\"stack underflow\");\n    }\n    if (stack[tos - 1] == null) {\n      debugger;\n    }\n    elementToBeReturned = stack[--tos];\n    \n    // give a chance to the garbage\n    // collection to reclaim space\n    // This is JS-specific, it would\n    // actually make the C garbage\n    // collector useless.\n    stack[tos] = null;\n    return elementToBeReturned;\n  };\n\n  // n is an integer\n  push_frame = function(n) {\n    var i, l1, ref2, results;\n    i = 0;\n    frame -= n;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    results = [];\n    for (i = l1 = 0, ref2 = n; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      results.push(stack[frame + i] = symbol(NIL));\n    }\n    return results;\n  };\n\n  // n is an integer\n  pop_frame = function(n) {\n    frame += n;\n    if (frame > TOS) {\n      return stop(\"frame underflow\");\n    }\n  };\n\n  save = function() {\n    frame -= 10;\n    if (frame < tos) {\n      debugger;\n      stop(\"frame overflow, circular reference?\");\n    }\n    stack[frame + 0] = p0;\n    stack[frame + 1] = p1;\n    stack[frame + 2] = p2;\n    stack[frame + 3] = p3;\n    stack[frame + 4] = p4;\n    stack[frame + 5] = p5;\n    stack[frame + 6] = p6;\n    stack[frame + 7] = p7;\n    stack[frame + 8] = p8;\n    return stack[frame + 9] = p9;\n  };\n\n  restore = function() {\n    if (frame > TOS - 10) {\n      stop(\"frame underflow\");\n    }\n    p0 = stack[frame + 0];\n    p1 = stack[frame + 1];\n    p2 = stack[frame + 2];\n    p3 = stack[frame + 3];\n    p4 = stack[frame + 4];\n    p5 = stack[frame + 5];\n    p6 = stack[frame + 6];\n    p7 = stack[frame + 7];\n    p8 = stack[frame + 8];\n    p9 = stack[frame + 9];\n    return frame += 10;\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  swap = function() {\n    var p, q;\n    //U *p, *q\n    // p and q are both Us\n    p = pop();\n    q = pop();\n    push(p);\n    return push(q);\n  };\n\n  // Local U * is OK here because there is no functional path to the garbage collector.\n  dupl = function() {\n    var p;\n    //U *p\n    p = pop();\n    push(p);\n    return push(p);\n  };\n\n  $.dupl = dupl;\n\n  $.swap = swap;\n\n  $.restore = restore;\n\n  $.save = save;\n\n  $.push = push;\n\n  $.pop = pop;\n\n  // The symbol table is a simple array of struct U.\n\n  // put symbol at index n\n  Eval_symbolsinfo = function() {\n    var symbolsinfoToBePrinted;\n    symbolsinfoToBePrinted = symbolsinfo();\n    if (symbolsinfoToBePrinted !== \"\") {\n      return push(new_string(symbolsinfoToBePrinted));\n    } else {\n      return push_symbol(NIL);\n    }\n  };\n\n  symbolsinfo = function() {\n    var bindingi, i, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;\n    symbolsinfoToBePrinted = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = symtab[i] + \"\";\n      bindingi = (binding[i] + \"\").substring(0, 4);\n      symbolsinfoToBePrinted += \"symbol: \" + symtabi + \" size: \" + countsize(binding[i]) + \" value: \" + bindingi + \"...\\n\";\n    }\n    return symbolsinfoToBePrinted;\n  };\n\n  // s is a string, n is an int\n  // TODO: elsewhere when we create a symbol we\n  // rather prefer to create a new entry. Here we just\n  // reuse the existing one. If that can never be a problem\n  // then explain why, otherwise do create a new entry.\n  std_symbol = function(s, n, latexPrint) {\n    var p;\n    p = symtab[n];\n    if (p == null) {\n      debugger;\n    }\n    p.printname = s;\n    if (latexPrint != null) {\n      return p.latexPrint = latexPrint;\n    } else {\n      return p.latexPrint = s;\n    }\n  };\n\n  // symbol lookup, or symbol creation if symbol doesn't exist yet\n  // this happens often from the scanner. When the scanner sees something\n  // like myVar = 2, it create a tree (SETQ (\"myVar\" symbol as created/looked up here (2)))\n  // user-defined functions also have a usr symbol.\n\n  // Note that some symbols like, say, \"abs\",\n  // are picked up by the scanner directly as keywords,\n  // so they are not looked up via this.\n  // So in fact you could redefine abs to be abs(x) = x\n  // but still abs would be picked up by the scanner as a particular\n  // node type and calls to abs() will be always to the \"native\" abs\n\n  // Also note that some symbols such as \"zero\" are (strangely) not picked up by\n  // the scanner as special nodes, rather they are identified as keywords\n  // (e.g. not redefinable) at time of symbol lookup (in Eval_sym) and\n  // evalled, where eval has a case for ZERO.\n\n  // Also note that there are a number of symbols, such as a,b,c,x,y,z,...\n  // that are actually created by std_symbols.\n  // They are not special node types (like abs), they are normal symbols\n  // that are looked up, but the advantage is that since they are often\n  // used internally by algebrite, we create the symbol in advance and\n  // we can reference the symbol entry in a clean way\n  // (e.g. symbol(SYMBOL_X)) rather than\n  // by looking up a string.\n\n  // s is a string\n  usr_symbol = function(s) {\n    var i, l1, ref2;\n    //console.log \"usr_symbol of \" + s\n    //if s == \"aaa\"\n    //  debugger\n\n    // find either the existing symbol, or if we\n    // reach an empty symbol (printname == \"\") then\n    // re-use that location.\n    i = 0;\n    for (i = l1 = 0, ref2 = NSYM; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      if (s === symtab[i].printname) {\n        // found the symbol\n        return symtab[i];\n      }\n      if (symtab[i].printname === \"\") {\n        // found an entry in the symbol table\n        // with no printname, exit the loop\n        // and re-use this location\n        break;\n      }\n    }\n    if (i === NSYM) {\n      stop(\"symbol table overflow\");\n    }\n    symtab[i] = new U();\n    symtab[i].k = SYM;\n    symtab[i].printname = s;\n    // say that we just created the symbol\n    // then, binding[the new symbol entry]\n    // by default points to the symbol.\n    // So the value of an unassigned symbol will\n    // be just its name.\n    binding[i] = symtab[i];\n    isSymbolReclaimable[i] = false;\n    return symtab[i];\n  };\n\n  // get the symbol's printname\n\n  // p is a U\n  get_printname = function(p) {\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    return p.printname;\n  };\n\n  // p and q are both U\n  // there are two Us at play here. One belongs to the\n  // symtab array and is the variable name.\n  // The other one is the U with the content, and that\n  // one will go in the corresponding \"binding\" array entry.\n  set_binding = function(p, q) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"setting binding of \" + p.toString() + \" to: \" + q.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> set_binding lookup \" + indexFound);\n    }\n    isSymbolReclaimable[indexFound] = false;\n    return binding[indexFound] = q;\n  };\n\n  // p is a U\n  get_binding = function(p) {\n    var indexFound;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    //console.log \"getting binding of \" + p.toString()\n    //if p.toString() == \"aaa\"\n    //  debugger\n    indexFound = symtab.indexOf(p);\n    /*\n    if indexFound == -1\n      debugger\n      for i in [0...symtab.length]\n        if p.printname == symtab[i].printname\n          indexFound = i\n          console.log \"remedied an index not found!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n          break\n    */\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> get_binding lookup \" + indexFound);\n    }\n    //if indexFound == 139\n    //  debugger\n    //if indexFound == 137\n    //  debugger\n    return binding[indexFound];\n  };\n\n  // the concept of user symbol is a little fuzzy\n  // beucase mathematics is full of symbols that actually\n  // have a special meaning, e.g. e,i,I in some cases j...\n  is_usr_symbol = function(p) {\n    var theSymnum;\n    if (p.k !== SYM) {\n      return false;\n    }\n    theSymnum = symnum(p);\n    // see \"defs\" file for the naming of the symbols\n    if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {\n      return true;\n    }\n    return false;\n  };\n\n  // get symbol's number from ptr\n  // p is U\n  lookupsTotal = 0;\n\n  symnum = function(p) {\n    var indexFound;\n    lookupsTotal++;\n    if (p.k !== SYM) {\n      stop(\"symbol error\");\n    }\n    indexFound = symtab.indexOf(p);\n    if (symtab.indexOf(p, indexFound + 1) !== -1) {\n      console.log(\"ops, more than one element!\");\n      debugger;\n    }\n    if (DEBUG) {\n      console.log(\"lookup >> symnum lookup \" + indexFound + \" lookup # \" + lookupsTotal);\n    }\n    //if lookupsTotal == 21\n    //  debugger\n    //if indexFound == 79\n    //  debugger\n    return indexFound;\n  };\n\n  // push indexed symbol\n\n  // k is an int\n  push_symbol = function(k) {\n    return push(symtab[k]);\n  };\n\n  clear_symbols = function() {\n    var i, l1, ref2, ref3, results;\n// we can clear just what's assignable.\n// everything before NIL is not assignable,\n// so there is no need to clear it.\n    results = [];\n    for (i = l1 = ref2 = NIL + 1, ref3 = NSYM; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      // stop at the first empty\n      // entry that is not reclaimable\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtab[i] = new U();\n      symtab[i].k = SYM;\n      binding[i] = symtab[i];\n      results.push(isSymbolReclaimable[i] = false);\n    }\n    return results;\n  };\n\n  //symtab[i].printname = \"\"\n  //binding[i] = symtab[i]\n\n  // collect all the variables in a tree\n  collectUserSymbols = function(p, accumulator = []) {\n    var i, l1, ref2;\n    if (is_usr_symbol(p)) {\n      if (accumulator.indexOf(p) === -1) {\n        accumulator.push(p);\n        return;\n      }\n    }\n    if (istensor(p)) {\n      for (i = l1 = 0, ref2 = p.tensor.nelem; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n        collectUserSymbols(p.tensor.elem[i], accumulator);\n      }\n      return;\n    }\n    while (iscons(p)) {\n      collectUserSymbols(car(p), accumulator);\n      p = cdr(p);\n    }\n  };\n\n  $.get_binding = get_binding;\n\n  $.set_binding = set_binding;\n\n  $.usr_symbol = usr_symbol;\n\n  $.symbolsinfo = symbolsinfo;\n\n  $.collectUserSymbols = collectUserSymbols;\n\n  if (!inited) {\n    inited = true;\n    init();\n  }\n\n  $.init = init;\n\n  parse_internal = function(argu) {\n    if (typeof argu === 'string') {\n      return scan(argu);\n    // now its in the stack\n    } else if (typeof argu === 'number') {\n      if (argu % 1 === 0) {\n        return push_integer(argu);\n      } else {\n        return push_double(argu);\n      }\n    } else if (argu instanceof U) {\n      // hey look its a U\n      return push(argu);\n    } else {\n      console.warn('unknown argument type', argu);\n      return push(symbol(NIL));\n    }\n  };\n\n  parse = function(argu) {\n    var data, error;\n    try {\n      parse_internal(argu);\n      data = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return data;\n  };\n\n  // exec handles the running ia JS of all the algebrite\n  // functions. The function name is passed in \"name\" and\n  // the corresponding function is pushed at the top of the stack\n  exec = function(name, ...argus) {\n    var argu, error, fn, l1, len, result;\n    fn = get_binding(usr_symbol(name));\n    check_stack();\n    push(fn);\n    for (l1 = 0, len = argus.length; l1 < len; l1++) {\n      argu = argus[l1];\n      parse_internal(argu);\n    }\n    list(1 + argus.length);\n    p1 = pop();\n    push(p1);\n    try {\n      top_level_eval();\n      result = pop();\n      check_stack();\n    } catch (error1) {\n      error = error1;\n      reset_after_error();\n      throw error;\n    }\n    return result;\n  };\n\n  $.exec = exec;\n\n  $.parse = parse;\n\n  (function() {\n    var builtin_fns, fn, l1, len, results;\n    builtin_fns = [\"abs\", \"add\", \"adj\", \"and\", \"approxratio\", \"arccos\", \"arccosh\", \"arcsin\", \"arcsinh\", \"arctan\", \"arctanh\", \"arg\", \"atomize\", \"besselj\", \"bessely\", \"binding\", \"binomial\", \"ceiling\", \"check\", \"choose\", \"circexp\", \"clear\", \"clearall\", \"clearpatterns\", \"clock\", \"coeff\", \"cofactor\", \"condense\", \"conj\", \"contract\", \"cos\", \"cosh\", \"decomp\", \"defint\", \"deg\", \"denominator\", \"det\", \"derivative\", \"dim\", \"dirac\", \"divisors\", \"do\", \"dot\", \"draw\", \"dsolve\", \"eigen\", \"eigenval\", \"eigenvec\", \"erf\", \"erfc\", \"eval\", \"exp\", \"expand\", \"expcos\", \"expsin\", \"factor\", \"factorial\", \"factorpoly\", \"filter\", \"float\", \"floor\", \"for\", \"Gamma\", \"gcd\", \"hermite\", \"hilbert\", \"imag\", \"component\", \"inner\", \"integral\", \"inv\", \"invg\", \"isinteger\", \"isprime\", \"laguerre\", \"lcm\", \"leading\", \"legendre\", \"log\", \"mod\", \"multiply\", \"not\", \"nroots\", \"number\", \"numerator\", \"operator\", \"or\", \"outer\", \"pattern\", \"patternsinfo\", \"polar\", \"power\", \"prime\", \"print\", \"print2dascii\", \"printcomputer\", \"printlatex\", \"printlist\", \"printhuman\", \"product\", \"quote\", \"quotient\", \"rank\", \"rationalize\", \"real\", \"rect\", \"roots\", \"round\", \"equals\", \"shape\", \"sgn\", \"silentpattern\", \"simplify\", \"sin\", \"sinh\", \"sqrt\", \"stop\", \"subst\", \"sum\", \"symbolsinfo\", \"tan\", \"tanh\", \"taylor\", \"test\", \"testeq\", \"testge\", \"testgt\", \"testle\", \"testlt\", \"transpose\", \"unit\", \"zero\"];\n    results = [];\n    for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {\n      fn = builtin_fns[l1];\n      results.push($[fn] = exec.bind(this, fn));\n    }\n    return results;\n  })();\n\n  freeze = function() {\n    var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i, l1, ref2;\n    frozenSymbols = [];\n    frozenContents = [];\n    frozenPatterns = [];\n    frozenHash = \"\";\n    for (i = l1 = 0, ref2 = symtab.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      //if symtab[i].printname == \"\"\n      //  if isSymbolReclaimable[i] == false\n      //    break\n      //  else\n      //    continue\n      if (isSymbolReclaimable[i] === false) {\n        frozenSymbols.push(symtab[i]);\n        frozenContents.push(binding[i]);\n      }\n    }\n    // just clone them\n    frozenPatterns = userSimplificationsInListForm.slice(0);\n    return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];\n  };\n\n  unfreeze = function(frozen) {\n    var frozenContents, frozenPatterns, frozenSymbols, i, l1, ref2;\n    [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit] = frozen;\n//clear_symbols()\n    for (i = l1 = 0, ref2 = frozenSymbols.length; (0 <= ref2 ? l1 < ref2 : l1 > ref2); i = 0 <= ref2 ? ++l1 : --l1) {\n      symtab[i] = frozenSymbols[i];\n      binding[i] = frozenContents[i];\n    }\n    return userSimplificationsInListForm = frozenPatterns.slice(0);\n  };\n\n  compareState = function(previousHash) {\n    var frozenHash;\n    frozenHash = getStateHash();\n    if (frozenHash === previousHash) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getStateHash = function() {\n    var bindingi, frozenHash, i, l1, len, m1, ref2, ref3, symtabi;\n    frozenHash = \"\";\n    for (i = l1 = ref2 = NIL + 1, ref3 = symtab.length; (ref2 <= ref3 ? l1 < ref3 : l1 > ref3); i = ref2 <= ref3 ? ++l1 : --l1) {\n      if (symtab[i].printname === \"\") {\n        if (isSymbolReclaimable[i] === false) {\n          break;\n        } else {\n          continue;\n        }\n      }\n      symtabi = print_list(symtab[i]);\n      bindingi = print_list(binding[i]);\n      frozenHash += \" //\" + symtabi + \" : \" + bindingi;\n    }\n    for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {\n      i = userSimplificationsInListForm[m1];\n      frozenHash += \" pattern: \" + i;\n    }\n    if (DEBUG) {\n      console.log(\"frozenHash: \" + frozenHash);\n    }\n    return frozenHash;\n  };\n\n}).call(this);\n","var bigInt = (function (undefined) {\r\n    \"use strict\";\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    }\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    }\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    }\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    }\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    }\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    }\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    }\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    }\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, t, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    }\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    }\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    }\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < digits[i]) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); }\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    }\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif (typeof module !== \"undefined\" && module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n\r\n//amd check\r\nif (typeof define === \"function\" && define.amd) {\r\n    define( function () {\r\n        return bigInt;\r\n    });\r\n}\r\n","window.Algebrite  = require('algebrite')\n"],"names":["$","ABS","ADD","ADJ","AND","APPROXRATIO","ARCCOS","ARCCOSH","ARCSIN","ARCSINH","ARCTAN","ARCTANH","ARG","ASSUME_REAL_VARIABLES","ATOMIZE","AUTOEXPAND","BAKE","BESSELJ","BESSELY","BINDING","BINOMIAL","BINOM_check_args","BUF","C1","C2","C3","C4","C5","C6","CEILING","CHECK","CHOOSE","CIRCEXP","CLEAR","CLEARALL","CLEARPATTERNS","CLOCK","COEFF","COFACTOR","CONDENSE","CONJ","CONS","CONTRACT","COS","COSH","Condense","DEBUG","DEBUG_ABS","DEBUG_ARG","DEBUG_CLOCKFORM","DEBUG_IMAG","DEBUG_IS","DEBUG_MULTIPLY","DEBUG_POWER","DEBUG_RATIONALIZE","DEBUG_RECT","DEBUG_SIMPLIFY","DECOMP","DEFINT","DEGREE","DENOMINATOR","DERIVATIVE","DET","DET_check_arg","DIM","DIRAC","DIVISORS","DO","DOT","DOUBLE","DRAW","DRAWX","DSOLVE","E","EIGEN","EIGENVAL","EIGENVEC","EIG_N","EIG_check_arg","EIG_yydd","EIG_yyqq","ERF","ERFC","EVAL","EXP","EXPAND","EXPCOS","EXPSIN","Eval","Eval_Eval","Eval_abs","Eval_add","Eval_adj","Eval_and","Eval_approxratio","Eval_arccos","Eval_arccosh","Eval_arcsin","Eval_arcsinh","Eval_arctan","Eval_arctanh","Eval_arg","Eval_besselj","Eval_bessely","Eval_binding","Eval_binomial","Eval_ceiling","Eval_check","Eval_choose","Eval_circexp","Eval_clear","Eval_clearall","Eval_clearpatterns","Eval_clock","Eval_coeff","Eval_cofactor","Eval_condense","Eval_conj","Eval_cons","Eval_contract","Eval_cos","Eval_cosh","Eval_decomp","Eval_defint","Eval_degree","Eval_denominator","Eval_derivative","Eval_det","Eval_dim","Eval_dirac","Eval_divisors","Eval_do","Eval_dsolve","Eval_eigen","Eval_eigenval","Eval_eigenvec","Eval_erf","Eval_erfc","Eval_exp","Eval_expand","Eval_expcos","Eval_expsin","Eval_factor","Eval_factorial","Eval_factorpoly","Eval_filter","Eval_float","Eval_floor","Eval_for","Eval_function_reference","Eval_gamma","Eval_gcd","Eval_hermite","Eval_hilbert","Eval_imag","Eval_index","Eval_inner","Eval_integral","Eval_inv","Eval_invg","Eval_isinteger","Eval_isprime","Eval_laguerre","Eval_lcm","Eval_leading","Eval_legendre","Eval_log","Eval_lookup","Eval_mod","Eval_multiply","Eval_noexpand","Eval_not","Eval_nroots","Eval_number","Eval_numerator","Eval_operator","Eval_or","Eval_outer","Eval_pattern","Eval_patternsinfo","Eval_polar","Eval_power","Eval_predicate","Eval_prime","Eval_print","Eval_print2dascii","Eval_printcomputer","Eval_printhuman","Eval_printlatex","Eval_printlist","Eval_product","Eval_quote","Eval_quotient","Eval_rank","Eval_rationalize","Eval_real","Eval_rect","Eval_roots","Eval_round","Eval_setq","Eval_sgn","Eval_shape","Eval_silentpattern","Eval_simfac","Eval_simplify","Eval_sin","Eval_sinh","Eval_sqrt","Eval_stop","Eval_subst","Eval_sum","Eval_sym","Eval_symbolsinfo","Eval_tan","Eval_tanh","Eval_taylor","Eval_tensor","Eval_test","Eval_testeq","Eval_testge","Eval_testgt","Eval_testle","Eval_testlt","Eval_transpose","Eval_unit","Eval_user_function","Eval_zero","Evalpoly","FACTOR","FACTORIAL","FACTORPOLY","FILTER","FLOATF","FLOOR","FOR","FORCE_FIXED_PRINTOUT","FUNCTION","Find","GAMMA","GCD","HERMITE","HILBERT","IMAG","INDEX","INNER","INTEGRAL","INV","INVG","INV_check_arg","INV_decomp","ISINTEGER","ISPRIME","LAGUERRE","LAST","LAST_2DASCII_PRINT","LAST_FULL_PRINT","LAST_LATEX_PRINT","LAST_LIST_PRINT","LAST_PLAIN_PRINT","LAST_PRINT","LCM","LEADING","LEGENDRE","LOG","LOOKUP","M","MAXDIM","MAXPRIMETAB","MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES","MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE","MAX_FIXED_PRINTOUT_DIGITS","MAX_PROGRAM_SIZE","MEQUAL","METAA","METAB","METAX","MLENGTH","MOD","MSIGN","MULTIPLY","MZERO","N","NIL","NOT","NROOTS","NROOTS_ABS","NROOTS_DELTA","NROOTS_EPSILON","NROOTS_RANDOM","NROOTS_YMAX","NROOTS_divpoly","NSYM","NUM","NUMBER","NUMERATOR","OPERATOR","OR","OUTER","PATTERN","PATTERNSINFO","PI","POLAR","POWER","PRIME","PRINT","PRINT2DASCII","PRINTFULL","PRINTLATEX","PRINTLIST","PRINTMODE_2DASCII","PRINTMODE_COMPUTER","PRINTMODE_HUMAN","PRINTMODE_LATEX","PRINTMODE_LIST","PRINTOUTRESULT","PRINTPLAIN","PRINT_LEAVE_E_ALONE","PRINT_LEAVE_X_ALONE","PRODUCT","QUOTE","QUOTIENT","RANK","RATIONALIZE","REAL","ROOTS","ROUND","SECRETX","SELFTEST","SETQ","SGN","SHAPE","SILENTPATTERN","SIMPLIFY","SIN","SINH","SPACE_BETWEEN_COLUMNS","SPACE_BETWEEN_ROWS","SQRT","STOP","STR","SUBST","SUM","SYM","SYMBOLSINFO","SYMBOL_A","SYMBOL_A_UNDERSCORE","SYMBOL_B","SYMBOL_B_UNDERSCORE","SYMBOL_C","SYMBOL_D","SYMBOL_I","SYMBOL_IDENTITY_MATRIX","SYMBOL_J","SYMBOL_N","SYMBOL_R","SYMBOL_S","SYMBOL_T","SYMBOL_X","SYMBOL_X_UNDERSCORE","SYMBOL_Y","SYMBOL_Z","TAN","TANH","TAYLOR","TENSOR","TEST","TESTEQ","TESTGE","TESTGT","TESTLE","TESTLT","TIMING_DEBUGS","TOS","TRACE","TRANSPOSE","T_DOUBLE","T_EQ","T_FUNCTION","T_GTEQ","T_INTEGER","T_LTEQ","T_NEQ","T_NEWLINE","T_QUOTASSIGN","T_STRING","T_SYMBOL","U","UNIT","USR_SYMBOLS","VERSION","YMAX","YYE","YYRECT","ZERO","__emit_char","__emit_str","__factor_add","__factorial","__is_negative","__is_radical_number","__lcm","__legendre","__legendre2","__legendre3","__normalize_radical_factors","__rationalize_tensor","_print","abs","absValFloat","absval","absval_tensor","add","addSymbolLeftOfAssignment","addSymbolRightOfAssignment","add_all","add_factor_to_accumulator","add_numbers","add_terms","addf","adj","alloc_tensor","allocatedId","any_denominators","approxAll","approxLogs","approxLogsOfRationals","approxOneRatioOnly","approxRadicals","approxRadicalsOfRationals","approxRationalsOfLogs","approxRationalsOfPowersOfE","approxRationalsOfPowersOfPI","approxRationalsOfRadicals","approxSineOfRationalMultiplesOfPI","approxSineOfRationals","approxTrigonometric","approx_just_an_integer","approx_logarithmsOfRationals","approx_nothingUseful","approx_radicalOfRatio","approx_ratioOfRadical","approx_rationalOfE","approx_rationalOfPi","approx_rationalsOfLogarithms","approx_sine_of_pi_times_rational","approx_sine_of_rational","approxratioRecursive","arccos","arccosh","arcsin","arcsinh","arctan","arctanh","areunivarpolysfactoredorexpandedform","arg","arglist","assignmentFound","avoidCalculatingPowersIntoArctans","bake","bake_poly","bake_poly_term","besselj","bessely","bigInt","bignum_factorial","bignum_float","bignum_power_number","bignum_scan_float","bignum_scan_integer","bignum_truncate","binding","binomial","buffer","build_tensor","caaddr","caadr","caar","cadaddr","cadadr","cadar","caddaddr","caddadr","caddar","caddddr","cadddr","caddr","cadr","called_from_Algebra_block","car","cdaddr","cdadr","cdar","cddaddr","cddar","cdddaddr","cddddr","cdddr","cddr","cdr","ceiling","chainOfUserSymbolsNotFunctionsBeingEvaluated","charTabIndex","chartab","checkFloatHasWorkedOutCompletely","check_esc_flag","check_stack","check_tensor_dimensions","choose","choose_check_args","circexp","clearAlgebraEnvironment","clearRenamedVariablesToAvoidBindingToExternalScope","clear_symbols","clear_term","clearall","clockform","cmpGlyphs","cmp_args","cmp_expr","cmp_terms","cmp_terms_count","codeGen","coeff","cofactor","collectLatexStringFromReturnValue","collectUserSymbols","combine_factors","combine_gammas","combine_terms","compareState","compare_numbers","compare_rationals","compare_tensors","compatible","computeDependenciesFromAlgebra","computeResultsAndJavaScriptFromAlgebra","compute_fa","conjugate","cons","consCount","contract","convert_bignum_to_double","convert_rational_to_double","copy_tensor","cosine","cosine_of_angle","cosine_of_angle_sum","count","countOccurrencesOfSymbol","count_denominators","counter","countsize","d_scalar_scalar","d_scalar_scalar_1","d_scalar_tensor","d_tensor_scalar","d_tensor_tensor","dabs","darccos","darccosh","darcsin","darcsinh","darctan","darctanh","dbesselj0","dbesseljn","dbessely0","dbesselyn","dcos","dcosh","dd","decomp","decomp_product","decomp_sum","defineSomeHandyConstants","define_user_function","defn","defn_str","degree","denominator","derf","derfc","derivative","derivative_of_integral","det","determinant","detg","dfunction","dhermite","dirac","display","display_flag","displaychar","divide","divide_numbers","divisors","divisors_onstack","divpoly","dlog","do_clearPatterns","do_clearall","do_simplify_nested_radicals","dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication","dotprod_unicode","doubleToReasonableString","dpow","dpower","dproduct","draw_flag","draw_stop_return","dsgn","dsin","dsinh","dsum","dtan","dtanh","dupl","eigen","elelmIndex","elem","emit_denominator","emit_denominators","emit_expr","emit_factor","emit_factorial_function","emit_flat_tensor","emit_fraction","emit_function","emit_index_function","emit_multiply","emit_number","emit_numerators","emit_numerical_fraction","emit_power","emit_string","emit_subexpr","emit_symbol","emit_tensor","emit_tensor_inner","emit_term","emit_top_expr","emit_unsigned_expr","emit_x","equal","equaln","equalq","erfc","errorMessage","esc_flag","evaluatingAsFloats","evaluatingPolar","exec","expand","expand_get_A","expand_get_AF","expand_get_B","expand_get_C","expand_get_CF","expand_tensor","expanding","expcos","exponential","expr_level","expsin","f1","f10","f2","f3","f4","f5","f9","f_equals_a","factor","factor_a","factor_again","factor_b","factor_number","factor_small_number","factor_term","factorial","factorpoly","factors","fill_buf","filter","filter_main","filter_sum","filter_tensor","findDependenciesInScript","findPossibleClockForm","findPossibleExponentialForm","findroot","fixup_fraction","fixup_power","flag","floatToRatioRoutine","fmt_index","fmt_level","fmt_x","frame","freeze","functionInvokationsScanningStack","gamma","gamma_of_sum","gammaf","gcd","gcd_main","gcd_numbers","gcd_polys","gcd_powers_with_same_base","gcd_product_product","gcd_product_sum","gcd_sum","gcd_sum_product","gcd_sum_sum","gen","getSimpleRoots","getStateHash","get_binding","get_factor_from_complex_root","get_factor_from_real_root","get_innerprod_factors","get_next_token","get_printname","get_size","get_token","getdisplaystr","glyph","gp","guess","hasImaginaryCoeff","hasNegativeRationalExponent","hash_addition","hash_function","hash_multiplication","hash_power","hashcode_values","hashed_itab","hermite","hilbert","i1","imag","imaginaryunit","index_function","init","initNRoots","inited","inner","inner_f","input_str","integral","integral_of_form","integral_of_product","integral_of_sum","inv","inverse","invert_number","invg","isNumberOneOverSomething","isNumericAtom","isNumericAtomOrTensor","isSimpleRoot","isSmall","isSymbolLeftOfAssignment","isSymbolReclaimable","isZeroAtom","isZeroAtomOrTensor","isZeroLikeOrNonZeroLikeOrUndetermined","isZeroTensor","is_denominator","is_factor","is_small_integer","is_square_matrix","is_usr_symbol","isadd","isalnumorunderscore","isalpha","isalphaOrUnderscore","iscomplexnumber","iscomplexnumberdouble","iscons","isdenominator","isdigit","isdouble","iseveninteger","isfactor","isfactorial","isfloating","isfraction","isidentitymatrix","isimaginarynumber","isimaginarynumberdouble","isimaginaryunit","isinnerordot","isinteger","isintegerfactor","isintegerorintegerfloat","isinv","iskeyword","isminusone","isminusoneoversqrttwo","isminusoneovertwo","isminussqrtthreeovertwo","ismultiply","isnegative","isnegativenumber","isnegativeterm","isnonnegativeinteger","isnpi","isone","isoneover","isoneoversqrttwo","isoneovertwo","isplusone","isplustwo","ispolyexpandedform","ispolyexpandedform_expr","ispolyexpandedform_factor","ispolyexpandedform_term","ispolyfactoredorexpandedform","ispolyfactoredorexpandedform_factor","ispolyfactoredorexpandedform_power","isposint","ispositivenumber","ispower","isquarterturn","isrational","isspace","issqrtthree","issqrtthreeovertwo","isstr","issymbol","issymbolic","istensor","istranspose","isunderscore","isunivarpolyfactoredorexpandedform","itab","italu_hashcode","j1","laguerre","laguerre2","lastFoundSymbol","latexErrorSign","lcm","leading","legendre","length","lessp","level","list","listLength","logarithm","logbuf","lookupsTotal","lu_decomp","madd","makePositive","makeSignSameAs","make_hashed_itab","mask","mcmp","mcmpint","mdiv","mdivrem","meta_mode","mgcd","mini_solve","mint","mmod","mmul","mod","monic","move","moveTos","mp_clr_bit","mp_denominator","mp_numerator","mp_set_bit","mpow","mprime","mroot","mshiftright","msub","mtotal","multinomial_sum","multiply","multiply_all","multiply_all_noexpand","multiply_consecutive_constants","multiply_denominators","multiply_denominators_factor","multiply_denominators_term","multiply_noexpand","multiply_numbers","n_factor_number","negate","negate_expand","negate_noexpand","negate_number","new_integer","new_string","newline_flag","nil_symbols","normaliseDots","normalisedCoeff","normalize_angle","nroots_a","nroots_b","nroots_c","nroots_df","nroots_dx","nroots_fa","nroots_fb","nroots_x","nroots_y","nterms","nthCadr","numerator","numericRootOfPolynomial","o","one","oneElement","one_as_double","out_buf","out_count","out_of_memory","outer","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","parse","parse_internal","parse_p1","parse_p2","parse_time_simplifications","partition","patternHasBeenFound","patternsinfo","performing_roots","polar","polarRectAMinusOneBase","polyform","pop","pop_double","pop_frame","pop_integer","power","power_str","power_sum","power_tensor","predefinedSymbolsInGlobalScope_doNotTrackInDependencies","prime","primetab","print2dascii","printMode","print_ABS_latex","print_ARCCOS_codegen","print_ARCSIN_codegen","print_ARCTAN_codegen","print_BINOMIAL_latex","print_COS_codegen","print_DEFINT_latex","print_DOT_codegen","print_DOT_latex","print_DO_codegen","print_FOR_codegen","print_INV_codegen","print_INV_latex","print_PRODUCT_codegen","print_PRODUCT_latex","print_SETQ_codegen","print_SIN_codegen","print_SQRT_latex","print_SUM_codegen","print_SUM_latex","print_TAN_codegen","print_TESTEQ_latex","print_TESTGE_latex","print_TESTGT_latex","print_TESTLE_latex","print_TESTLT_latex","print_TEST_codegen","print_TEST_latex","print_TRANSPOSE_codegen","print_TRANSPOSE_latex","print_UNIT_codegen","print_a_over_b","print_base","print_base_of_denom","print_char","print_denom","print_double","print_expo_of_denom","print_exponent","print_expr","print_factor","print_factorial_function","print_glyphs","print_index_function","print_list","print_multiply_sign","print_number","print_power","print_str","print_subexpr","print_tensor","print_tensor_inner","print_tensor_inner_latex","print_tensor_latex","print_term","printchar","printchar_nowrap","printline","program_buf","promote_tensor","push","pushTryNotToDuplicate","push_cars","push_double","push_factor","push_frame","push_identity_matrix","push_integer","push_rational","push_symbol","push_term_factors","push_terms","push_zero_matrix","qadd","qdiv","qmul","qpow","qpowf","quickfactor","quickpower","rational","rationalize","rationalize_coefficients","real","reciprocate","rect","recursionLevelNestedRadicalsRemoval","recursiveDependencies","ref","ref1","rememberPrint","remove_negative_exponents","reset_after_error","restore","restoreMetaBindings","rewrite_args","rewrite_args_tensor","roots","roots2","roots3","run","runUserDefinedSimplifications","save","saveMetaBindings","scalar_times_tensor","scan","scan_error","scan_expression","scan_factor","scan_function_call_with_function_name","scan_function_call_without_function_name","scan_index","scan_meta","scan_power","scan_relation","scan_stmt","scan_str","scan_string","scan_subexpr","scan_symbol","scan_tensor","scan_term","scanned","scanningParameters","setM","setSignTo","set_binding","set_component","setq_indexed","sfac_product","sfac_product_f","sgn","shape","show_power_debug","sign","sign_of_term","simfac","simfac_term","simpleComplexityMeasure","simplify","simplifyForCodeGeneration","simplify_1_in_products","simplify_main","simplify_nested_radicals","simplify_polar","simplify_polarRect","simplify_rational_expressions","simplify_rectToClock","simplify_tensor","simplify_trig","simplifyfactorials","sine","sine_of_angle","sine_of_angle_sum","skipRootVariableToBeSolved","sort_stack","square","ssqrt","stack","stackAddsCount","std_symbol","step","step2","stop","strcmp","stringsEmittedByUserPrintouts","subf","subst","subtract","subtract_numbers","swap","symbol","symbolsDependencies","symbolsHavingReassignments","symbolsInExpressionsWithoutAssignments","symbolsLeftOfAssignment","symbolsRightOfAssignment","symbolsinfo","symnum","symtab","take_care_of_nested_radicals","tangent","taylor","tensor","tensor_plus_tensor","tensor_times_scalar","testApprox","test_flag","text_metric","theRandom","token","token_buf","token_str","top","top_level_eval","tos","transform","transpose","transpose_unicode","trigmode","trivial_divide","try_kth_prime","turnErrorMessageToLatex","ucmp","unfreeze","unique","unique_f","update_token_buf","userSimplificationsInListForm","userSimplificationsInStringForm","usr_symbol","verbosing","version","will_be_displayed_as_fraction","ybinomial","ycosh","ydirac","yerf","yerfc","yfloor","yindex","yround","ysinh","yyarg","yybesselj","yybessely","yyceiling","yycondense","yycontract","yycosh","yydegree","yydetg","yydivpoly","yyerf","yyerfc","yyexpand","yyfactorpoly","yyfloat","yyfloor","yyhermite","yyhermite2","yyinvg","yylcm","yylog","yymultiply","yyouter","yypower","yyrationalize","yyround","yysgn","yysimfac","yysinh","yytangent","zero","zzfloat","hasProp","hasOwnProperty","parcelRequire","prototype","a","b","call","this","toString","toLatexString","constructor","q","printname","str","d","k","tag","dim","results","ndim","nelem","h","w","n","ascent","descent","width","ceil","i","j","primes","Math","sqrt","x","p","startCount","isPositive","isZero","equals","exports","theArgument1","console","trace","log","anyFactorsYet","input","subsetOfStack","slice","sort","concat","t","s","l1","m1","ref2","ref3","ref4","ref5","ref6","ref7","ref8","ref9","numberOfDigitsAfterTheDot","precision","splitBeforeAndAfterDot","supposedlyTheFloat","theFloat","theRatio","theArgument","split","pow","decimal","AccuracyFactor","DecimalSign","FractionDenominator","FractionNumerator","PreviousDenominator","ScratchValue","Z","ret","isNaN","Infinity","floor","bestResultSoFar","complexity","error","hypothesis","len","likelyMultiplier","minimumComplexity","ratio","Number","MAX_VALUE","round","len1","approxRadicalsOfRationalsResult","approxRationalsOfRadicalsResult","approxLogsOfRationalsResult","approxRationalsOfLogsResult","approxSineOfRationalMultiplesOfPIResult","approxSineOfRationalsResult","fraction","sin","approxLogsResult","approxRadicalsResult","approxRationalsOfPowersOfEResult","approxRationalsOfPowersOfPIResult","approxTrigonometricResult","bestApproxSoFar","constantsSum","constantsSumMin","aResult","c","theSum","Array","i2","i3","j2","j3","k3","l2","l3","len2","len3","len4","len5","len6","len7","m2","m3","n1","n2","o1","o2","originalValue","q1","q2","r1","r2","returned","returnedFraction","returnedValue","s1","s2","t1","t2","u1","u2","v1","v2","value","x1","x2","z1","z2","toFixed","acos","asin","atan","y","z","jn","yn","geq","MIN_SAFE_INTEGER","leq","MAX_SAFE_INTEGER","isNegative","qsub","ab","ba","minusOne","expo","toJSNumber","quotientAndRemainder","divmod","quotient","remainder","theNewInteger","accumulator","buf","scounter","sign_","substring","parseFloat","signed","aAsString","denominatorString","shiftRight","indexOf","indexFound","variableToBeCleared","variable","polynomial","coeffsCount","constant","polynomialWithoutConstant","prev_expanding","row","col","ai","an","l","m","cos","cosh","toBePushed","generalTransform","breakFromOutherWhile","base","result","theta","op","ref10","printstr","ref11","results1","cc","ss","ans","exp","willEvaluateAsFloats","cycleString","positionIfSymbolAlreadyBeingEvaluated","cons_head","Eval_atomize","Eval_draw","checkResult","dsolve","orig","theTensor","A","AxPlusB","B","checkingTheDivision","dividend","factpoly_expo","firstParam","foundComplexRoot","foundRealRoot","partOfPolynomialFactoredSoFar","polycoeff","previousFactorisation","remainingPoly","secondDegreePloly","secondParam","whichRootsAreWeFinding","ratioInverse","a0","evalPolyResult","na0","nan","rootsTries_i","rootsTries_j","testDenominator","testNumerator","testValue","Q","evaluateAt","nodeToCheck","numberOfEs","numberOfMults","numberOfPIs","numberOfPowers","numberOfSums","loopingVariable","polyVar","difference","moretheArguments","operands","refinedOperands","shift","theArguments","arg1","arg2","arg3","subtractionResult","ak","bk","tree","factors_accumulator","hc","tab","constexp","constbase","tan","sinh","tanh","erf","u","half","arg_hash","name","Error","terms","sum","term","term_set","product","base_hash","exp_hash","f","key","JSON","stringify","eachEntry","results2","valueOrPredicate","evalledArgument","isEven","minussign","compareAbs","v","theNewString","toReturn","isProbablePrime","index","and","shiftLeft","not","or","append","_gamma","r","random","nrabs","firstArgument","patternPosition","secondArgument","stringKey","thirdArgument","patternsinfoToBePrinted","compare","bigint_one","g","xprime","b_isEven_and_c_isItsInverse","hopefullySimplified","inputBase","inputExp","isThisOne","is_a_moreThanZero","original_test_flag","beenPrinted","passedPrintMode","origPrintMode","theString","theTypeOfPrint","parsedString","originalCodeGen","returnedString","replace","denom","numberOneOverSomething","origAccumulator","previousFactorWasANumber","functionBody","numberOfIntegrals","originalIntegral","theIntegral","theVariable","retString","firstLevel","body","lowerlimit","upperlimit","howManyIfs","exponent","denomExponent","newExponent","numExponent","omitParens","pastFirstFactor","fbody","parameters","character","k1","k2","pPrintName","pString","dx","h1","h2","w1","w2","y1","y2","dy","max_x","max_y","min_x","min_y","emit_sign","tmpString","sIndex","tmpBuffer","eh","ew","ncol","nrow","indexVariable","oldIndexVariableValue","gcdBetweenNumeratorAndDenominator","qadd_ab","qadd_ba","qadd_denominator","qadd_frac1","qadd_frac2","qadd_numerator","resultSum","aa","bb","isOdd","stackIndex","divisor","commonDenominator","eachTerm","imaginaryCoefficients","isSimpleRootPolynomial","divideBy","miniStack","lastCoeff","leadingCoeff","aSol","commonPart","rootsOfOne","C_CHECKED_AS_NOT_ZERO","R_18_a_b_c_d","R_27_a2_d","R_2_b3","R_3_a","R_3_a_C","R_3_a_c","R_4_DELTA03","R_6_a_C","R_C","R_C_over_3a","R_C_simplified_toCheckIfZero","R_DELTA0","R_DELTA0_toBeCheckedIfZero","R_DELTA1","R_Q","R_a2","R_a2_d","R_a2_d2","R_a3","R_a_b_c","R_a_b_c_d","R_a_c","R_b2","R_b2_c2","R_b3","R_b3_d","R_c2","R_c3","R_d2","R_determinant","R_e2","R_e3","R_m","R_m27_a2_d2","R_m4_a_c3","R_m4_b3_d","R_m9_a_b_c","R_m_b_over_3a","R_p","R_q","R_r","ThreePPlus2M","TwoQOversqrtPPlus2M","coeff2","coeff3","coeff4","depressedSolutions","eachSolution","flipSignOFQSoCIsNotZero","i_sqrt3","one_minus_i_sqrt3","one_plus_i_sqrt3","resolventCubicSolutions","root_solution","sqrtPPlus2M","toBeCheckedIFZero","assignmentIsOfQuotedType","existingDependencies","indexOfSymbolLeftOfAssignment","symbolLeftOfAssignment","splice","charCodeAt","firstFactorIsNumber","theSymbol","prefixVar","functionName","RegExp","test","errmsg","atLeastOneSuccessInRouldOfRulesApplications","eachConsecutiveRuleApplication","eachSimplification","numberOfRulesApplications","originalexpanding","success","args","eval","carp1","oldp1","oldp2","num","theGCD","simplificationWithCondense","simplificationWithoutCondense","somethingSimplified","C","SOLUTION","anyRadicalSimplificationWorked","checkSize","commonBases","commonInnerExponent","countingTerms","firstTerm","innerbase","innerexponent","lowercase_a","lowercase_b","numberOfTerms","possibleNewExpression","possibleNewExpressionValue","possibleRationalSolutions","possibleSolutions","potentialPower","realOfpossibleRationalSolutions","secondTerm","secondTermFactor","termsThatAreNotPowers","max","apply","expr","newExpr","newTensor","oldExpr","comparison","wholeAndExpression","andPredicates","somePredicateUnknown","orPredicates","wholeOrExpression","bookmarkTosToPrintDecomps","eachTransformEntry","numberOfDecomps","restTerm","theTransform","transform_h","transformationSuccessful","transformedTerms","fea_i","fea_j","innerTranspSwitch1","innerTranspSwitch2","bodyAndFormalArguments","definitionOfInterest","defn_i","str1","str2","maxFixedPrintoutDigits","stringRepresentation","search","needle","message","stringToBeParsed","dontGenerateCode","bodyForReadableSummaryOfGeneratedCode","cyclesDescriptions","deQuotedDep","dependencyInfo","eachDependency","generatedBody","generatedCode","indexOfEachReplacement","indexOfPartRemainingToBeParsed","newUserSymbol","originalUserSymbol","readableSummaryOfGeneratedCode","recursedDependencies","replacementsFrom","replacementsTo","scriptEvaluation","stringToBeRun","testableString","timeStartFromAlgebra","toBePrinted","userVariablesMentioned","variablesWithCycles","Date","getTime","affectsVariables","affectedBy","error1","error11","error12","variableToBeChecked","arrayWhereDependenciesWillBeAdded","variablesAlreadyFleshedOut","chainBeingChecked","cyclesDescription","theErrorMessage","String","fromCharCode","stringToNormalise","generateLatex","allReturnedLatexStrings","allReturnedPlainStrings","collectedLatexResult","collectedPlainResult","stringToBeReturned","timeStart","timingDebugWrite","selftest","originalArgument","shouldAutoexpand","codeFromAlgebraBlock","code","latexResult","readableSummaryOfCode","testableStringIsIgnoredHere","stackPos","elementToBeReturned","symbolsinfoToBePrinted","bindingi","symtabi","latexPrint","theSymnum","argu","warn","data","argus","fn","builtin_fns","bind","frozenContents","frozenSymbols","frozen","frozenPatterns","previousHash","frozenHash","undefined","BASE","MAX_INT","MAX_INT_ARR","smallToArray","DEFAULT_ALPHABET","supportsNativeBigInt","BigInt","Integer","radix","alphabet","caseSensitive","parseBase","parseValue","BigInteger","SmallInteger","NativeBigInt","isPrecise","arrayToSmall","arr","trim","createArray","truncate","l_a","l_b","carry","addAny","addSmall","a_l","b_l","borrow","subtractSmall","multiplyLong","a_i","multiplySmall","multiplyKaratsuba","ac","bd","abcd","multiplySmallAndArray","divModSmall","lambda","divModAny","self","quotientDigit","divisorMostSignificantDigit","divMod1","xlen","highx","highy","check","part","unshift","reverse","divMod2","qSign","mSign","isBasicPrime","isUnit","isDivisibleBy","lesser","millerRabinTest","nPrev","prev","next","modPow","Object","create","plus","subtractAny","minus","small","times","_multiplyBySmall","over","_0","_1","_2","modInv","compareTo","eq","notEquals","neq","greater","gt","lt","greaterOrEquals","lesserOrEquals","isPrime","strict","bits","bitLength","logN","iterations","rng","randBetween","lastT","lastR","newT","newR","powersOfTwo","powers2Length","highestPower2","shift_isSmall","bitwise","xSign","ySign","xRem","yRem","xDigit","yDigit","xDivMod","yDivMod","remQuo","xor","LOBMASK_I","roughLOB","integerLogarithm","tmp","e","min","text","toLowerCase","absBase","alphabetValues","digits","start","parseBaseFromArray","val","toBase","map","valueOf","neg","out","left","digit","toBaseString","join","parseStringValue","decimalPlace","parseNumberValue","toArray","toJSON","parseInt","isInstance","usedRNG","low","range","restricted","fromArray","module","define","amd","window","Algebrite"],"version":3,"file":"index.js.map"}